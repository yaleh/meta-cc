
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yale/meta-cc/cmd/analyze.go (100.0%)</option>
				
				<option value="file1">github.com/yale/meta-cc/cmd/analyze_file_churn.go (6.5%)</option>
				
				<option value="file2">github.com/yale/meta-cc/cmd/analyze_idle.go (4.5%)</option>
				
				<option value="file3">github.com/yale/meta-cc/cmd/analyze_sequences.go (7.5%)</option>
				
				<option value="file4">github.com/yale/meta-cc/cmd/mcp-server/executor.go (2.4%)</option>
				
				<option value="file5">github.com/yale/meta-cc/cmd/mcp-server/jq_filter.go (92.3%)</option>
				
				<option value="file6">github.com/yale/meta-cc/cmd/mcp-server/main.go (0.0%)</option>
				
				<option value="file7">github.com/yale/meta-cc/cmd/mcp-server/server.go (3.4%)</option>
				
				<option value="file8">github.com/yale/meta-cc/cmd/mcp-server/tools.go (0.0%)</option>
				
				<option value="file9">github.com/yale/meta-cc/cmd/mcp.go (33.9%)</option>
				
				<option value="file10">github.com/yale/meta-cc/cmd/mcp_tools.go (100.0%)</option>
				
				<option value="file11">github.com/yale/meta-cc/cmd/parse.go (42.3%)</option>
				
				<option value="file12">github.com/yale/meta-cc/cmd/pipeline.go (91.2%)</option>
				
				<option value="file13">github.com/yale/meta-cc/cmd/query.go (83.3%)</option>
				
				<option value="file14">github.com/yale/meta-cc/cmd/query_context.go (6.6%)</option>
				
				<option value="file15">github.com/yale/meta-cc/cmd/query_errors.go (17.6%)</option>
				
				<option value="file16">github.com/yale/meta-cc/cmd/query_file_access.go (7.9%)</option>
				
				<option value="file17">github.com/yale/meta-cc/cmd/query_messages.go (10.1%)</option>
				
				<option value="file18">github.com/yale/meta-cc/cmd/query_project_state.go (1.1%)</option>
				
				<option value="file19">github.com/yale/meta-cc/cmd/query_sequences.go (4.1%)</option>
				
				<option value="file20">github.com/yale/meta-cc/cmd/query_successful_prompts.go (1.2%)</option>
				
				<option value="file21">github.com/yale/meta-cc/cmd/query_tools.go (4.2%)</option>
				
				<option value="file22">github.com/yale/meta-cc/cmd/root.go (75.0%)</option>
				
				<option value="file23">github.com/yale/meta-cc/cmd/stats_aggregate.go (12.5%)</option>
				
				<option value="file24">github.com/yale/meta-cc/cmd/stats_files.go (10.8%)</option>
				
				<option value="file25">github.com/yale/meta-cc/cmd/stats_timeseries.go (11.1%)</option>
				
				<option value="file26">github.com/yale/meta-cc/internal/analyzer/errors.go (100.0%)</option>
				
				<option value="file27">github.com/yale/meta-cc/internal/analyzer/patterns.go (95.6%)</option>
				
				<option value="file28">github.com/yale/meta-cc/internal/analyzer/stats.go (96.8%)</option>
				
				<option value="file29">github.com/yale/meta-cc/internal/analyzer/workflow.go (82.7%)</option>
				
				<option value="file30">github.com/yale/meta-cc/internal/filter/expression.go (72.0%)</option>
				
				<option value="file31">github.com/yale/meta-cc/internal/filter/filter.go (83.9%)</option>
				
				<option value="file32">github.com/yale/meta-cc/internal/filter/pagination.go (95.5%)</option>
				
				<option value="file33">github.com/yale/meta-cc/internal/filter/parser.go (85.4%)</option>
				
				<option value="file34">github.com/yale/meta-cc/internal/filter/time.go (83.0%)</option>
				
				<option value="file35">github.com/yale/meta-cc/internal/locator/args.go (77.4%)</option>
				
				<option value="file36">github.com/yale/meta-cc/internal/locator/env.go (87.5%)</option>
				
				<option value="file37">github.com/yale/meta-cc/internal/locator/helpers.go (80.0%)</option>
				
				<option value="file38">github.com/yale/meta-cc/internal/locator/locator.go (44.0%)</option>
				
				<option value="file39">github.com/yale/meta-cc/internal/mcp/builder.go (42.0%)</option>
				
				<option value="file40">github.com/yale/meta-cc/internal/mcp/session_tools.go (32.7%)</option>
				
				<option value="file41">github.com/yale/meta-cc/internal/mcp/tools_project.go (81.5%)</option>
				
				<option value="file42">github.com/yale/meta-cc/internal/output/error.go (79.2%)</option>
				
				<option value="file43">github.com/yale/meta-cc/internal/output/exitcode.go (100.0%)</option>
				
				<option value="file44">github.com/yale/meta-cc/internal/output/format.go (100.0%)</option>
				
				<option value="file45">github.com/yale/meta-cc/internal/output/writer.go (100.0%)</option>
				
				<option value="file46">github.com/yale/meta-cc/internal/parser/reader.go (65.7%)</option>
				
				<option value="file47">github.com/yale/meta-cc/internal/parser/tools.go (91.3%)</option>
				
				<option value="file48">github.com/yale/meta-cc/internal/parser/types.go (61.1%)</option>
				
				<option value="file49">github.com/yale/meta-cc/internal/query/context.go (87.7%)</option>
				
				<option value="file50">github.com/yale/meta-cc/internal/query/file_access.go (92.7%)</option>
				
				<option value="file51">github.com/yale/meta-cc/internal/query/sequences.go (96.0%)</option>
				
				<option value="file52">github.com/yale/meta-cc/internal/stats/aggregator.go (100.0%)</option>
				
				<option value="file53">github.com/yale/meta-cc/internal/stats/files.go (94.9%)</option>
				
				<option value="file54">github.com/yale/meta-cc/internal/stats/metrics.go (93.3%)</option>
				
				<option value="file55">github.com/yale/meta-cc/internal/stats/timeseries.go (90.3%)</option>
				
				<option value="file56">github.com/yale/meta-cc/internal/testutil/fixtures.go (81.0%)</option>
				
				<option value="file57">github.com/yale/meta-cc/internal/testutil/time.go (0.0%)</option>
				
				<option value="file58">github.com/yale/meta-cc/main.go (0.0%)</option>
				
				<option value="file59">github.com/yale/meta-cc/pkg/output/chunker.go (75.4%)</option>
				
				<option value="file60">github.com/yale/meta-cc/pkg/output/estimator.go (88.9%)</option>
				
				<option value="file61">github.com/yale/meta-cc/pkg/output/json.go (58.8%)</option>
				
				<option value="file62">github.com/yale/meta-cc/pkg/output/projection.go (95.9%)</option>
				
				<option value="file63">github.com/yale/meta-cc/pkg/output/sort.go (90.0%)</option>
				
				<option value="file64">github.com/yale/meta-cc/pkg/output/stream.go (88.9%)</option>
				
				<option value="file65">github.com/yale/meta-cc/pkg/output/summary.go (93.5%)</option>
				
				<option value="file66">github.com/yale/meta-cc/pkg/output/tsv.go (76.8%)</option>
				
				<option value="file67">github.com/yale/meta-cc/pkg/pipeline/session.go (92.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
)

// analyzeCmd represents the analyze subcommand
var analyzeCmd = &amp;cobra.Command{
        Use:   "analyze",
        Short: "Analyze Claude Code session patterns",
        Long: `Analyze Claude Code session data to detect patterns and insights.

Note: analyze errors has been replaced by 'query errors' in Phase 14.
Use 'meta-cc query errors' for error extraction with jq for aggregation.

Examples:
  meta-cc analyze sequences
  meta-cc analyze file-churn
  meta-cc analyze idle`,
}

func init() <span class="cov8" title="1">{
        // Add analyze subcommand to root
        rootCmd.AddCommand(analyzeCmd)

        // Note: analyze errors subcommand has been removed
        // Use 'query errors' instead
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/analyzer"
        "github.com/yale/meta-cc/pkg/output"
)

var fileChurnThreshold int

// analyzeFileChurnCmd represents the analyze file-churn subcommand
var analyzeFileChurnCmd = &amp;cobra.Command{
        Use:   "file-churn",
        Short: "Detect files with frequent access",
        Long: `Detect files that are frequently accessed in Claude Code session data.

Identifies files that are read, edited, or written multiple times.
Useful for detecting files that may need clarification or refactoring.

Examples:
  meta-cc analyze file-churn
  meta-cc analyze file-churn --threshold 5
  meta-cc analyze file-churn --output json`,
        RunE: runAnalyzeFileChurn,
}

func init() <span class="cov8" title="1">{
        analyzeCmd.AddCommand(analyzeFileChurnCmd)

        analyzeFileChurnCmd.Flags().IntVar(&amp;fileChurnThreshold, "threshold", 5, "Minimum access count to report")
}</span>

func runAnalyzeFileChurn(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session file: %w", err)
        }</span>

        // Step 2: Detect file churn
        <span class="cov0" title="0">entries := p.GetEntries()
        result := analyzer.DetectFileChurn(entries, fileChurnThreshold)

        // Step 4: Format and output
        var outputStr string
        var formatErr error

        switch outputFormat </span>{
        case "jsonl":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatJSONL(result)</span>
        case "tsv":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatTSV(result)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s (supported: jsonl, tsv)", outputFormat)</span>
        }

        <span class="cov0" title="0">if formatErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format output: %w", formatErr)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
        return nil</span>
}

func formatFileChurnMarkdown(result analyzer.FileChurnAnalysis) (string, error) <span class="cov0" title="0">{
        if len(result.HighChurnFiles) == 0 </span><span class="cov0" title="0">{
                return "# File Churn Analysis\n\nNo high churn files detected.\n", nil
        }</span>

        <span class="cov0" title="0">var md string
        md += "# File Churn Analysis\n\n"
        md += fmt.Sprintf("Found %d high churn file(s):\n\n", len(result.HighChurnFiles))

        for i, file := range result.HighChurnFiles </span><span class="cov0" title="0">{
                md += fmt.Sprintf("## %d. %s\n\n", i+1, file.File)
                md += fmt.Sprintf("- **Total Accesses**: %d\n", file.TotalAccesses)
                md += fmt.Sprintf("- **Read**: %d times\n", file.ReadCount)
                md += fmt.Sprintf("- **Edit**: %d times\n", file.EditCount)
                md += fmt.Sprintf("- **Write**: %d times\n", file.WriteCount)
                md += fmt.Sprintf("- **Time Span**: %d minutes\n", file.TimeSpanMin)
                md += "\n---\n\n"
        }</span>

        <span class="cov0" title="0">return md, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/analyzer"
        "github.com/yale/meta-cc/pkg/output"
)

var idleThresholdMin int

// analyzeIdleCmd represents the analyze idle-periods subcommand
var analyzeIdleCmd = &amp;cobra.Command{
        Use:   "idle-periods",
        Short: "Detect idle periods in session",
        Long: `Detect idle periods (time gaps) in Claude Code session data.

Identifies periods where there was no activity for an extended duration.
Useful for detecting points where users may have been stuck or distracted.

Examples:
  meta-cc analyze idle-periods
  meta-cc analyze idle-periods --threshold 5
  meta-cc analyze idle-periods --threshold 10 --output json`,
        RunE: runAnalyzeIdle,
}

func init() <span class="cov8" title="1">{
        analyzeCmd.AddCommand(analyzeIdleCmd)

        analyzeIdleCmd.Flags().IntVar(&amp;idleThresholdMin, "threshold", 5, "Minimum idle duration in minutes")
}</span>

func runAnalyzeIdle(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session file: %w", err)
        }</span>

        // Step 2: Detect idle periods
        <span class="cov0" title="0">entries := p.GetEntries()
        result := analyzer.DetectIdlePeriods(entries, idleThresholdMin)

        // Step 4: Format and output
        var outputStr string
        var formatErr error

        switch outputFormat </span>{
        case "jsonl":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatJSONL(result)</span>
        case "tsv":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatTSV(result)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s (supported: jsonl, tsv)", outputFormat)</span>
        }

        <span class="cov0" title="0">if formatErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format output: %w", formatErr)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
        return nil</span>
}

func formatIdlePeriodsMarkdown(result analyzer.IdlePeriodAnalysis) (string, error) <span class="cov0" title="0">{
        if len(result.IdlePeriods) == 0 </span><span class="cov0" title="0">{
                return "# Idle Period Analysis\n\nNo idle periods detected.\n", nil
        }</span>

        <span class="cov0" title="0">var md string
        md += "# Idle Period Analysis\n\n"
        md += fmt.Sprintf("Found %d idle period(s):\n\n", len(result.IdlePeriods))

        for i, period := range result.IdlePeriods </span><span class="cov0" title="0">{
                md += fmt.Sprintf("## Period %d\n\n", i+1)
                md += fmt.Sprintf("- **Duration**: %.1f minutes\n", period.DurationMin)
                md += fmt.Sprintf("- **Between Turns**: %d → %d\n", period.StartTurn, period.EndTurn)

                if period.ContextBefore != nil </span><span class="cov0" title="0">{
                        md += "\n**Context Before**:\n"
                        md += fmt.Sprintf("- Turn %d (%s)\n", period.ContextBefore.Turn, period.ContextBefore.Role)
                        if period.ContextBefore.Tool != "" </span><span class="cov0" title="0">{
                                md += fmt.Sprintf("- Tool: %s\n", period.ContextBefore.Tool)
                        }</span>
                        <span class="cov0" title="0">if period.ContextBefore.Status != "" </span><span class="cov0" title="0">{
                                md += fmt.Sprintf("- Status: %s\n", period.ContextBefore.Status)
                        }</span>
                        <span class="cov0" title="0">if period.ContextBefore.Preview != "" </span><span class="cov0" title="0">{
                                md += fmt.Sprintf("- Preview: %s\n", period.ContextBefore.Preview)
                        }</span>
                }

                <span class="cov0" title="0">if period.ContextAfter != nil </span><span class="cov0" title="0">{
                        md += "\n**Context After**:\n"
                        md += fmt.Sprintf("- Turn %d (%s)\n", period.ContextAfter.Turn, period.ContextAfter.Role)
                        if period.ContextAfter.Tool != "" </span><span class="cov0" title="0">{
                                md += fmt.Sprintf("- Tool: %s\n", period.ContextAfter.Tool)
                        }</span>
                        <span class="cov0" title="0">if period.ContextAfter.Preview != "" </span><span class="cov0" title="0">{
                                md += fmt.Sprintf("- Preview: %s\n", period.ContextAfter.Preview)
                        }</span>
                }

                <span class="cov0" title="0">md += "\n---\n\n"</span>
        }

        <span class="cov0" title="0">return md, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/analyzer"
        "github.com/yale/meta-cc/pkg/output"
)

var (
        sequencesMinLength      int
        sequencesMinOccurrences int
)

// analyzeSequencesCmd represents the analyze sequences subcommand
var analyzeSequencesCmd = &amp;cobra.Command{
        Use:   "sequences",
        Short: "Detect repeated tool call sequences",
        Long: `Detect repeated tool call sequences in Claude Code session data.

Identifies patterns where the same sequence of tools is called multiple times.
Useful for detecting potentially inefficient workflows.

Examples:
  meta-cc analyze sequences
  meta-cc analyze sequences --min-length 3 --min-occurrences 3
  meta-cc analyze sequences --output json`,
        RunE: runAnalyzeSequences,
}

func init() <span class="cov8" title="1">{
        analyzeCmd.AddCommand(analyzeSequencesCmd)

        analyzeSequencesCmd.Flags().IntVar(&amp;sequencesMinLength, "min-length", 3, "Minimum sequence length")
        analyzeSequencesCmd.Flags().IntVar(&amp;sequencesMinOccurrences, "min-occurrences", 3, "Minimum occurrences to report")
}</span>

func runAnalyzeSequences(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session file: %w", err)
        }</span>

        // Step 2: Detect sequences
        <span class="cov0" title="0">entries := p.GetEntries()
        result := analyzer.DetectToolSequences(entries, sequencesMinLength, sequencesMinOccurrences)

        // Step 4: Format and output
        var outputStr string
        var formatErr error

        switch outputFormat </span>{
        case "jsonl":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatJSONL(result)</span>
        case "tsv":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatTSV(result)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s (supported: jsonl, tsv)", outputFormat)</span>
        }

        <span class="cov0" title="0">if formatErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format output: %w", formatErr)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
        return nil</span>
}

func formatSequencesMarkdown(result analyzer.SequenceAnalysis) (string, error) <span class="cov0" title="0">{
        if len(result.Sequences) == 0 </span><span class="cov0" title="0">{
                return "# Tool Sequence Analysis\n\nNo repeated sequences detected.\n", nil
        }</span>

        <span class="cov0" title="0">var md string
        md += "# Tool Sequence Analysis\n\n"
        md += fmt.Sprintf("Found %d repeated sequence(s):\n\n", len(result.Sequences))

        for i, seq := range result.Sequences </span><span class="cov0" title="0">{
                md += fmt.Sprintf("## Sequence %d: %s\n\n", i+1, seq.Pattern)
                md += fmt.Sprintf("- **Length**: %d tools\n", seq.Length)
                md += fmt.Sprintf("- **Occurrences**: %d times\n", seq.Count)
                md += fmt.Sprintf("- **Time Span**: %d minutes\n", seq.TimeSpanMin)
                md += "\n"

                md += "**Occurrences**:\n\n"
                limit := seq.Count
                if limit &gt; 5 </span><span class="cov0" title="0">{
                        limit = 5
                }</span>
                <span class="cov0" title="0">for j := 0; j &lt; limit; j++ </span><span class="cov0" title="0">{
                        occ := seq.Occurrences[j]
                        md += fmt.Sprintf("- Turn %d → %d\n", occ.StartTurn, occ.EndTurn)
                }</span>
                <span class="cov0" title="0">if seq.Count &gt; 5 </span><span class="cov0" title="0">{
                        md += fmt.Sprintf("- ... and %d more\n", seq.Count-5)
                }</span>
                <span class="cov0" title="0">md += "\n---\n\n"</span>
        }

        <span class="cov0" title="0">return md, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "strconv"
)

const (
        DefaultMaxOutputBytes = 51200 // 50KB
)

type ToolExecutor struct {
        metaCCPath string
}

func NewToolExecutor() *ToolExecutor <span class="cov8" title="1">{
        // Find meta-cc executable
        metaCCPath, err := exec.LookPath("meta-cc")
        if err != nil </span><span class="cov0" title="0">{
                // Assume meta-cc is in the same directory or current directory
                metaCCPath = "./meta-cc"
        }</span>

        <span class="cov8" title="1">return &amp;ToolExecutor{
                metaCCPath: metaCCPath,
        }</span>
}

// ExecuteTool executes a meta-cc command and applies jq filtering
func (e *ToolExecutor) ExecuteTool(toolName string, args map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // Extract common parameters
        jqFilter := getStringParam(args, "jq_filter", ".[]")
        statsOnly := getBoolParam(args, "stats_only", false)
        statsFirst := getBoolParam(args, "stats_first", false)
        maxOutputBytes := getIntParam(args, "max_output_bytes", DefaultMaxOutputBytes)
        scope := getStringParam(args, "scope", "project")
        outputFormat := getStringParam(args, "output_format", "jsonl")

        // Build meta-cc command
        cmdArgs := e.buildCommand(toolName, args, scope, outputFormat)
        if cmdArgs == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unknown tool: %s", toolName)
        }</span>

        // Execute meta-cc
        <span class="cov0" title="0">rawOutput, err := e.executeMetaCC(cmdArgs)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Apply jq filter
        <span class="cov0" title="0">filtered, err := ApplyJQFilter(rawOutput, jqFilter)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("jq filter error: %w", err)
        }</span>

        // Generate stats if requested
        <span class="cov0" title="0">var output string
        if statsOnly </span><span class="cov0" title="0">{
                output, err = GenerateStats(filtered)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        } else<span class="cov0" title="0"> if statsFirst </span><span class="cov0" title="0">{
                stats, _ := GenerateStats(filtered)
                output = stats + "\n---\n" + filtered
        }</span> else<span class="cov0" title="0"> {
                output = filtered
        }</span>

        // Apply output length limit
        <span class="cov0" title="0">if len(output) &gt; maxOutputBytes </span><span class="cov0" title="0">{
                output = output[:maxOutputBytes]
                output += fmt.Sprintf("\n[OUTPUT TRUNCATED: exceeded %d bytes limit]", maxOutputBytes)
        }</span>

        <span class="cov0" title="0">return output, nil</span>
}

func (e *ToolExecutor) buildCommand(toolName string, args map[string]interface{}, scope string, outputFormat string) []string <span class="cov0" title="0">{
        cmdArgs := []string{}

        // Add project flag for project-level queries
        if scope == "project" </span><span class="cov0" title="0">{
                cmdArgs = append(cmdArgs, "--project", ".")
        }</span>

        // Map tool name to meta-cc command
        <span class="cov0" title="0">switch toolName </span>{
        case "query_tools":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "query", "tools")
                if tool := getStringParam(args, "tool", ""); tool != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--tool", tool)
                }</span>
                <span class="cov0" title="0">if status := getStringParam(args, "status", ""); status != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--status", status)
                }</span>
                <span class="cov0" title="0">if limit := getIntParam(args, "limit", 0); limit &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--limit", strconv.Itoa(limit))
                }</span>

        case "extract_tools":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "extract", "tools")
                if limit := getIntParam(args, "limit", 0); limit &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--limit", strconv.Itoa(limit))
                }</span>

        case "query_user_messages":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "query", "user-messages")
                if pattern := getStringParam(args, "pattern", ""); pattern != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--pattern", pattern)
                }</span>
                <span class="cov0" title="0">if limit := getIntParam(args, "limit", 0); limit &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--limit", strconv.Itoa(limit))
                }</span>

        case "get_session_stats":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "parse", "stats")</span>

        case "analyze_errors":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "analyze", "errors")</span>

        case "query_context":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "query", "context")
                if errorSig := getStringParam(args, "error_signature", ""); errorSig != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--error-signature", errorSig)
                }</span>
                <span class="cov0" title="0">if window := getIntParam(args, "window", 0); window &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--window", strconv.Itoa(window))
                }</span>

        case "query_tool_sequences":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "analyze", "sequences")
                if pattern := getStringParam(args, "pattern", ""); pattern != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--pattern", pattern)
                }</span>
                <span class="cov0" title="0">if minOccur := getIntParam(args, "min_occurrences", 0); minOccur &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--min-occurrences", strconv.Itoa(minOccur))
                }</span>

        case "query_file_access":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "query", "file-access")
                if file := getStringParam(args, "file", ""); file != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--file", file)
                }</span>

        case "query_project_state":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "query", "project-state")</span>

        case "query_successful_prompts":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "query", "successful-prompts")
                if limit := getIntParam(args, "limit", 0); limit &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--limit", strconv.Itoa(limit))
                }</span>
                <span class="cov0" title="0">if minQuality := getFloatParam(args, "min_quality_score", 0); minQuality &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--min-quality", fmt.Sprintf("%.2f", minQuality))
                }</span>

        case "query_tools_advanced":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "query", "tools")
                if where := getStringParam(args, "where", ""); where != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--where", where)
                }</span>
                <span class="cov0" title="0">if limit := getIntParam(args, "limit", 0); limit &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--limit", strconv.Itoa(limit))
                }</span>

        case "aggregate_stats":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "stats", "aggregate")
                if groupBy := getStringParam(args, "group_by", ""); groupBy != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--group-by", groupBy)
                }</span>
                <span class="cov0" title="0">if metrics := getStringParam(args, "metrics", ""); metrics != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--metrics", metrics)
                }</span>
                <span class="cov0" title="0">if where := getStringParam(args, "where", ""); where != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--where", where)
                }</span>

        case "query_time_series":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "stats", "timeseries")
                if interval := getStringParam(args, "interval", ""); interval != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--interval", interval)
                }</span>
                <span class="cov0" title="0">if metric := getStringParam(args, "metric", ""); metric != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--metric", metric)
                }</span>
                <span class="cov0" title="0">if where := getStringParam(args, "where", ""); where != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--where", where)
                }</span>

        case "query_files":<span class="cov0" title="0">
                cmdArgs = append(cmdArgs, "analyze", "file-churn")
                if sortBy := getStringParam(args, "sort_by", ""); sortBy != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--sort-by", sortBy)
                }</span>
                <span class="cov0" title="0">if top := getIntParam(args, "top", 0); top &gt; 0 </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--top", strconv.Itoa(top))
                }</span>
                <span class="cov0" title="0">if where := getStringParam(args, "where", ""); where != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--where", where)
                }</span>

        default:<span class="cov0" title="0">
                return nil</span>
        }

        // Always output JSONL (unless specified otherwise)
        <span class="cov0" title="0">cmdArgs = append(cmdArgs, "--output", outputFormat)

        return cmdArgs</span>
}

func (e *ToolExecutor) executeMetaCC(cmdArgs []string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command(e.metaCCPath, cmdArgs...)

        var stdout bytes.Buffer
        var stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Set current directory for meta-cc
        cmd.Dir, _ = os.Getwd()

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("meta-cc error: %s", stderr.String())
        }</span>

        <span class="cov0" title="0">return stdout.String(), nil</span>
}

// Helper functions
func getStringParam(args map[string]interface{}, key, defaultVal string) string <span class="cov0" title="0">{
        if v, ok := args[key].(string); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func getBoolParam(args map[string]interface{}, key string, defaultVal bool) bool <span class="cov0" title="0">{
        if v, ok := args[key].(bool); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func getIntParam(args map[string]interface{}, key string, defaultVal int) int <span class="cov0" title="0">{
        if v, ok := args[key].(float64); ok </span><span class="cov0" title="0">{
                return int(v)
        }</span>
        <span class="cov0" title="0">if v, ok := args[key].(int); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func getFloatParam(args map[string]interface{}, key string, defaultVal float64) float64 <span class="cov0" title="0">{
        if v, ok := args[key].(float64); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/itchyny/gojq"
)

// ApplyJQFilter applies a jq expression to JSONL data
func ApplyJQFilter(jsonlData string, jqExpr string) (string, error) <span class="cov8" title="1">{
        // Default expression: select all
        if jqExpr == "" </span><span class="cov8" title="1">{
                jqExpr = ".[]"
        }</span>

        // Parse jq expression
        <span class="cov8" title="1">query, err := gojq.Parse(jqExpr)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid jq expression: %w", err)
        }</span>

        // Parse JSONL data
        <span class="cov8" title="1">lines := strings.Split(strings.TrimSpace(jsonlData), "\n")
        var data []interface{}

        for _, line := range lines </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">var obj interface{}
                if err := json.Unmarshal([]byte(line), &amp;obj); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid JSON: %w", err)
                }</span>
                <span class="cov8" title="1">data = append(data, obj)</span>
        }

        // Apply jq filter
        <span class="cov8" title="1">var results []interface{}
        iter := query.Run(data)

        for </span><span class="cov8" title="1">{
                v, ok := iter.Next()
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if err, ok := v.(error); ok </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">results = append(results, v)</span>
        }

        // Convert results to JSONL
        <span class="cov8" title="1">var output strings.Builder
        for _, result := range results </span><span class="cov8" title="1">{
                jsonBytes, err := json.Marshal(result)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">output.Write(jsonBytes)
                output.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return output.String(), nil</span>
}

// GenerateStats generates statistics from JSONL data
func GenerateStats(jsonlData string) (string, error) <span class="cov8" title="1">{
        // Parse JSONL
        lines := strings.Split(strings.TrimSpace(jsonlData), "\n")

        // Count by type (assuming objects have a "tool" or "ToolName" field)
        stats := make(map[string]int)

        for _, line := range lines </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">var obj map[string]interface{}
                if err := json.Unmarshal([]byte(line), &amp;obj); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Determine stat key (tool name, error type, etc.)
                <span class="cov8" title="1">key := "unknown"
                if tool, ok := obj["tool"].(string); ok </span><span class="cov8" title="1">{
                        key = tool
                }</span> else<span class="cov8" title="1"> if toolName, ok := obj["ToolName"].(string); ok </span><span class="cov8" title="1">{
                        key = toolName
                }</span>

                <span class="cov8" title="1">stats[key]++</span>
        }

        // Output stats as JSONL
        <span class="cov8" title="1">var output strings.Builder
        for key, count := range stats </span><span class="cov8" title="1">{
                statObj := map[string]interface{}{
                        "key":   key,
                        "count": count,
                }
                jsonBytes, _ := json.Marshal(statObj)
                output.Write(jsonBytes)
                output.WriteString("\n")
        }</span>

        <span class="cov8" title="1">return output.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "bufio"
        "encoding/json"
        "os"
)

func main() <span class="cov0" title="0">{
        scanner := bufio.NewScanner(os.Stdin)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()

                // Parse JSON-RPC request
                var req JSONRPCRequest
                if err := json.Unmarshal([]byte(line), &amp;req); err != nil </span><span class="cov0" title="0">{
                        writeError(nil, -32700, "Parse error")
                        continue</span>
                }

                // Handle request
                <span class="cov0" title="0">handleRequest(req)</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                writeError(nil, -32603, "Input error: "+err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "encoding/json"
        "os"
)

type JSONRPCRequest struct {
        JSONRPC string                 `json:"jsonrpc"`
        ID      interface{}            `json:"id"`
        Method  string                 `json:"method"`
        Params  map[string]interface{} `json:"params"`
}

type JSONRPCResponse struct {
        JSONRPC string        `json:"jsonrpc"`
        ID      interface{}   `json:"id"`
        Result  interface{}   `json:"result,omitempty"`
        Error   *JSONRPCError `json:"error,omitempty"`
}

type JSONRPCError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

var executor *ToolExecutor

func init() <span class="cov8" title="1">{
        executor = NewToolExecutor()
}</span>

func handleRequest(req JSONRPCRequest) <span class="cov0" title="0">{
        switch req.Method </span>{
        case "initialize":<span class="cov0" title="0">
                handleInitialize(req)</span>
        case "tools/list":<span class="cov0" title="0">
                handleToolsList(req)</span>
        case "tools/call":<span class="cov0" title="0">
                handleToolsCall(req)</span>
        default:<span class="cov0" title="0">
                writeError(req.ID, -32601, "Method not found")</span>
        }
}

func handleInitialize(req JSONRPCRequest) <span class="cov0" title="0">{
        result := map[string]interface{}{
                "protocolVersion": "2024-11-05",
                "capabilities": map[string]interface{}{
                        "tools": map[string]bool{},
                },
                "serverInfo": map[string]string{
                        "name":    "meta-cc-mcp",
                        "version": "1.0.0",
                },
        }
        writeResponse(req.ID, result)
}</span>

func handleToolsList(req JSONRPCRequest) <span class="cov0" title="0">{
        tools := getToolDefinitions()
        result := map[string]interface{}{
                "tools": tools,
        }
        writeResponse(req.ID, result)
}</span>

func handleToolsCall(req JSONRPCRequest) <span class="cov0" title="0">{
        // Extract tool name and arguments
        params := req.Params
        toolName, ok := params["name"].(string)
        if !ok </span><span class="cov0" title="0">{
                writeError(req.ID, -32602, "Invalid params: missing tool name")
                return
        }</span>

        <span class="cov0" title="0">arguments, ok := params["arguments"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                arguments = make(map[string]interface{})
        }</span>

        // Execute tool
        <span class="cov0" title="0">output, err := executor.ExecuteTool(toolName, arguments)
        if err != nil </span><span class="cov0" title="0">{
                writeError(req.ID, -32603, err.Error())
                return
        }</span>

        // Return result
        <span class="cov0" title="0">result := map[string]interface{}{
                "content": []map[string]interface{}{
                        {
                                "type": "text",
                                "text": output,
                        },
                },
        }
        writeResponse(req.ID, result)</span>
}

func writeResponse(id interface{}, result interface{}) <span class="cov0" title="0">{
        resp := JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Result:  result,
        }
        json.NewEncoder(os.Stdout).Encode(resp)
}</span>

func writeError(id interface{}, code int, message string) <span class="cov0" title="0">{
        resp := JSONRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error: &amp;JSONRPCError{
                        Code:    code,
                        Message: message,
                },
        }
        json.NewEncoder(os.Stdout).Encode(resp)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

func getToolDefinitions() []Tool <span class="cov0" title="0">{
        return []Tool{
                {
                        Name:        "get_session_stats",
                        Description: "Get session statistics (turn count, tool usage, error rate). Always operates on current session only.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                },
                        },
                },
                {
                        Name:        "analyze_errors",
                        Description: "Analyze error patterns across project history (repeated failures, tool-specific errors, temporal trends). Default project-level scope enables discovery of persistent issues across sessions.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) enables cross-session pattern discovery, 'session' limits to current session only.",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results (default: '.[]')",
                                        },
                                        "stats_only": {
                                                Type:        "boolean",
                                                Description: "Return only statistics (default: false)",
                                        },
                                        "stats_first": {
                                                Type:        "boolean",
                                                Description: "Return stats first, then details (default: false)",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
                {
                        Name:        "extract_tools",
                        Description: "Extract tool call history across all project sessions with pagination. Default project-level scope provides complete workflow timeline for pattern analysis.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "limit": {
                                                Type:        "number",
                                                Description: "Maximum number of tools to extract (default: 100)",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "stats_only": {
                                                Type:        "boolean",
                                                Description: "Return only statistics",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
                {
                        Name:        "query_tools",
                        Description: "Query tool call history across project with filters (tool name, status). Default project-level scope reveals cross-session usage patterns and trends.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "limit": {
                                                Type:        "number",
                                                Description: "Maximum number of results (default: 20)",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "tool": {
                                                Type:        "string",
                                                Description: "Filter by tool name (e.g., 'Bash', 'Read', 'Edit')",
                                        },
                                        "status": {
                                                Type:        "string",
                                                Description: "Filter by execution status (error or success)",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "stats_only": {
                                                Type:        "boolean",
                                                Description: "Return only statistics",
                                        },
                                        "stats_first": {
                                                Type:        "boolean",
                                                Description: "Return stats first, then details",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
                {
                        Name:        "query_user_messages",
                        Description: "Search user messages across all project sessions using regex patterns. Default project-level scope enables discovery of recurring prompt patterns and intent evolution.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "pattern": {
                                                Type:        "string",
                                                Description: "Regex pattern to match in message content (required)",
                                        },
                                        "limit": {
                                                Type:        "number",
                                                Description: "Maximum number of results (default: 10)",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                                Required: []string{"pattern"},
                        },
                },
                {
                        Name:        "query_context",
                        Description: "Query context around specific errors across project history (turns before/after error occurrence). Default project-level scope helps identify if error patterns recur in similar contexts across sessions.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "error_signature": {
                                                Type:        "string",
                                                Description: "Error pattern ID to query (required)",
                                        },
                                        "window": {
                                                Type:        "number",
                                                Description: "Context window size in turns before/after (default: 3)",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                                Required: []string{"error_signature"},
                        },
                },
                {
                        Name:        "query_tool_sequences",
                        Description: "Query repeated tool call sequences across project history (workflow patterns like 'Read-&gt;Edit-&gt;Bash'). Default project-level scope reveals your evolved workflow habits and automation opportunities.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "pattern": {
                                                Type:        "string",
                                                Description: "Specific sequence pattern to match (e.g., 'Read -&gt; Edit -&gt; Bash')",
                                        },
                                        "min_occurrences": {
                                                Type:        "number",
                                                Description: "Minimum occurrences to report (default: 3)",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
                {
                        Name:        "query_file_access",
                        Description: "Query file operation history across project (read/edit/write operations on specific files). Default project-level scope shows complete file evolution timeline.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "file": {
                                                Type:        "string",
                                                Description: "File path to query (required)",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                                Required: []string{"file"},
                        },
                },
                {
                        Name:        "query_project_state",
                        Description: "Query project state evolution across all sessions (active files, task progression, change patterns). Default project-level scope provides comprehensive project timeline.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
                {
                        Name:        "query_successful_prompts",
                        Description: "Query historically successful prompt patterns across all project sessions (prompts that led to successful outcomes). Default project-level scope identifies your most effective prompting strategies over time.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "limit": {
                                                Type:        "number",
                                                Description: "Maximum number of results (default: 10)",
                                        },
                                        "min_quality_score": {
                                                Type:        "number",
                                                Description: "Minimum quality score (0.0-1.0, default: 0.8)",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
                {
                        Name:        "query_tools_advanced",
                        Description: "Query tool calls with SQL-like filter expressions across project sessions. Default project-level scope enables complex multi-condition analysis (e.g., 'tool=\"Bash\" AND status=\"error\" AND duration&gt;5000').",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "where": {
                                                Type:        "string",
                                                Description: "SQL-like filter expression (e.g., \"tool='Bash' AND status='error'\")",
                                        },
                                        "limit": {
                                                Type:        "number",
                                                Description: "Maximum number of results (default: 20)",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                                Required: []string{"where"},
                        },
                },
                {
                        Name:        "aggregate_stats",
                        Description: "Aggregate statistics grouped by field (tool, status, or uuid) across all project sessions. Default project-level scope provides comprehensive summary metrics (tool counts, error rates) for cross-session comparison.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "group_by": {
                                                Type:        "string",
                                                Description: "Field to group by: tool, status, or uuid (default: tool)",
                                        },
                                        "metrics": {
                                                Type:        "string",
                                                Description: "Comma-separated metrics (count, error_rate)",
                                        },
                                        "where": {
                                                Type:        "string",
                                                Description: "Optional filter expression",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
                {
                        Name:        "query_time_series",
                        Description: "Analyze metrics over time (tool call frequency, error rates) bucketed by hour/day/week across project history. Default project-level scope reveals temporal patterns and workflow evolution.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "interval": {
                                                Type:        "string",
                                                Description: "Time interval for bucketing: hour, day, or week (default: hour)",
                                        },
                                        "metric": {
                                                Type:        "string",
                                                Description: "Metric to analyze: tool-calls or error-rate (default: tool-calls)",
                                        },
                                        "where": {
                                                Type:        "string",
                                                Description: "Optional filter expression",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
                {
                        Name:        "query_files",
                        Description: "File-level operation statistics (total operations, edit/read/write counts, error rates) across all project sessions. Default project-level scope identifies files with persistent churn or error patterns.",
                        InputSchema: ToolSchema{
                                Type: "object",
                                Properties: map[string]Property{
                                        "sort_by": {
                                                Type:        "string",
                                                Description: "Sort field: total_ops, edit_count, read_count, write_count, error_count, error_rate (default: total_ops)",
                                        },
                                        "top": {
                                                Type:        "number",
                                                Description: "Limit results to top N files (default: 20)",
                                        },
                                        "where": {
                                                Type:        "string",
                                                Description: "Optional filter expression",
                                        },
                                        "scope": {
                                                Type:        "string",
                                                Description: "Query scope: 'project' (default) or 'session'",
                                        },
                                        "output_format": {
                                                Type:        "string",
                                                Description: "Output format: jsonl or tsv (default: jsonl)",
                                        },
                                        "jq_filter": {
                                                Type:        "string",
                                                Description: "jq expression for filtering results",
                                        },
                                        "max_output_bytes": {
                                                Type:        "number",
                                                Description: "Maximum output size in bytes (default: 51200)",
                                        },
                                },
                        },
                },
        }
}</span>

type Tool struct {
        Name        string     `json:"name"`
        Description string     `json:"description"`
        InputSchema ToolSchema `json:"inputSchema"`
}

type ToolSchema struct {
        Type       string              `json:"type"`
        Properties map[string]Property `json:"properties"`
        Required   []string            `json:"required,omitempty"`
}

type Property struct {
        Type        string `json:"type"`
        Description string `json:"description"`
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "bufio"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/mcp"
)

var mcpCmd = &amp;cobra.Command{
        Use:   "mcp",
        Short: "Start MCP (Model Context Protocol) server",
        Long: `Start an MCP server that exposes meta-cc functionality via the Model Context Protocol.
This allows Claude Code and other MCP clients to query session statistics, analyze errors,
and extract tool usage data.`,
        RunE: runMCPServer,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(mcpCmd)
}</span>

type jsonRPCRequest struct {
        JSONRPC string          `json:"jsonrpc"`
        ID      interface{}     `json:"id"`
        Method  string          `json:"method"`
        Params  json.RawMessage `json:"params,omitempty"`
}

type jsonRPCResponse struct {
        JSONRPC string      `json:"jsonrpc"`
        ID      interface{} `json:"id"`
        Result  interface{} `json:"result,omitempty"`
        Error   interface{} `json:"error,omitempty"`
}

func runMCPServer(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        scanner := bufio.NewScanner(os.Stdin)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Bytes()

                var req jsonRPCRequest
                if err := json.Unmarshal(line, &amp;req); err != nil </span><span class="cov0" title="0">{
                        sendError(req.ID, -32700, "Parse error", err.Error())
                        continue</span>
                }

                <span class="cov0" title="0">handleRequest(req)</span>
        }

        <span class="cov0" title="0">return scanner.Err()</span>
}

func handleRequest(req jsonRPCRequest) <span class="cov0" title="0">{
        switch req.Method </span>{
        case "initialize":<span class="cov0" title="0">
                handleInitialize(req)</span>
        case "tools/list":<span class="cov0" title="0">
                handleToolsList(req)</span>
        case "tools/call":<span class="cov0" title="0">
                handleToolsCall(req)</span>
        default:<span class="cov0" title="0">
                sendError(req.ID, -32601, "Method not found", fmt.Sprintf("Unknown method: %s", req.Method))</span>
        }
}

func handleInitialize(req jsonRPCRequest) <span class="cov0" title="0">{
        result := map[string]interface{}{
                "protocolVersion": "2024-11-05",
                "capabilities": map[string]interface{}{
                        "tools": map[string]interface{}{},
                },
                "serverInfo": map[string]interface{}{
                        "name":    "meta-cc",
                        "version": Version,
                },
        }
        sendResponse(req.ID, result)
}</span>

func handleToolsList(req jsonRPCRequest) <span class="cov0" title="0">{
        // Phase 12 Revision: Use consolidated tools with scope parameter
        tools := getConsolidatedToolsList()

        result := map[string]interface{}{
                "tools": tools,
        }
        sendResponse(req.ID, result)
}</span>

// Phase 12 Note: Legacy _session tools have been consolidated into scope parameter
// Old approach: 22 tools (11 base + 11 _session variants)
// New approach: 14 tools with scope parameter (reduces API complexity by ~36%)

func handleToolsCall(req jsonRPCRequest) <span class="cov0" title="0">{
        var params struct {
                Name      string                 `json:"name"`
                Arguments map[string]interface{} `json:"arguments"`
        }

        if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                sendError(req.ID, ErrInvalidParams, "Invalid params", err.Error())
                return
        }</span>

        // Execute the appropriate meta-cc command based on tool name
        <span class="cov0" title="0">output, err := executeTool(params.Name, params.Arguments)
        if err != nil </span><span class="cov0" title="0">{
                code := categorizeError(err)
                errType := categorizeErrorType(err)
                sendErrorWithType(req.ID, code, errType, categorizeMessage(err), err.Error())
                return
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "content": []map[string]interface{}{
                        {
                                "type": "text",
                                "text": output,
                        },
                },
        }
        sendResponse(req.ID, result)</span>
}

// Phase 13 Enhancement: Error handling with structured codes
const (
        ErrInvalidParams   = -32602 // Invalid method parameters
        ErrNotFound        = -32001 // Session/resource not found
        ErrNoResults       = -32002 // Query returned no results
        ErrExecutionFailed = -32603 // Tool execution failed
)

// categorizeError maps error types to JSON-RPC error codes
func categorizeError(err error) int <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()
        if strings.Contains(errMsg, "session location failed") || strings.Contains(errMsg, "not found") </span><span class="cov8" title="1">{
                return ErrNotFound
        }</span>
        <span class="cov8" title="1">if strings.Contains(errMsg, "no results") || strings.Contains(errMsg, "empty") </span><span class="cov8" title="1">{
                return ErrNoResults
        }</span>
        <span class="cov8" title="1">if strings.Contains(errMsg, "required") || strings.Contains(errMsg, "invalid") </span><span class="cov8" title="1">{
                return ErrInvalidParams
        }</span>
        <span class="cov8" title="1">return ErrExecutionFailed</span>
}

// categorizeMessage provides user-friendly error messages
func categorizeMessage(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()
        switch </span>{
        case strings.Contains(errMsg, "session location failed"):<span class="cov8" title="1">
                return "Session not found"</span>
        case strings.Contains(errMsg, "no results"):<span class="cov8" title="1">
                return "Query returned no results"</span>
        case strings.Contains(errMsg, "required"):<span class="cov8" title="1">
                return "Missing required parameter"</span>
        case strings.Contains(errMsg, "invalid"):<span class="cov8" title="1">
                return "Invalid parameter value"</span>
        default:<span class="cov8" title="1">
                return "Tool execution failed"</span>
        }
}

// categorizeErrorType provides string error type codes for better error categorization
// This complements the numeric JSON-RPC error codes with semantic type identifiers
func categorizeErrorType(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()
        switch </span>{
        case strings.Contains(errMsg, "session location failed") || strings.Contains(errMsg, "not found"):<span class="cov8" title="1">
                return "SESSION_NOT_FOUND"</span>
        case strings.Contains(errMsg, "no results") || strings.Contains(errMsg, "empty"):<span class="cov8" title="1">
                return "NO_RESULTS"</span>
        case strings.Contains(errMsg, "required") || strings.Contains(errMsg, "invalid"):<span class="cov8" title="1">
                return "INVALID_PARAMS"</span>
        default:<span class="cov8" title="1">
                return "EXECUTION_FAILED"</span>
        }
}

// Phase 14.2: Use refactored command builder from internal/mcp
func executeTool(name string, args map[string]interface{}) (string, error) <span class="cov8" title="1">{
        // Phase 12 Revision: Map _session suffix to scope parameter
        toolName := name
        scope := "project" // Phase 13: Default to project for cross-session analysis

        // Handle legacy _session suffix tools
        if strings.HasSuffix(name, "_session") </span><span class="cov0" title="0">{
                toolName = strings.TrimSuffix(name, "_session")
                scope = "session"
        }</span>

        // Inject scope into args if not present (except for get_session_stats)
        <span class="cov8" title="1">if name != "get_session_stats" </span><span class="cov8" title="1">{
                if _, hasScope := args["scope"]; !hasScope </span><span class="cov8" title="1">{
                        args["scope"] = scope
                }</span>
        }

        // Import and use the refactored builder
        // Note: This requires importing internal/mcp, which creates a circular dependency
        // Solution: Move BuildToolCommand to a shared package or keep it here
        <span class="cov8" title="1">cmdArgs, err := buildToolCommandInternal(toolName, args)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Execute meta-cc command internally
        <span class="cov0" title="0">return executeMetaCCCommand(cmdArgs)</span>
}

// buildToolCommandInternal delegates to the refactored builder
func buildToolCommandInternal(name string, args map[string]interface{}) ([]string, error) <span class="cov8" title="1">{
        return mcp.BuildToolCommand(name, args)
}</span>

// Phase 14: Add streaming support for large sessions
func executeMetaCCCommand(args []string) (string, error) <span class="cov0" title="0">{
        // Save original stdout
        oldStdout := os.Stdout
        oldArgs := os.Args

        // Create a pipe to capture output
        r, w, err := os.Pipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Replace stdout
        <span class="cov0" title="0">os.Stdout = w
        os.Args = append([]string{"meta-cc"}, args...)

        // Channel to capture the output with streaming support
        outCh := make(chan string)
        errCh := make(chan error)

        go func() </span><span class="cov0" title="0">{
                var output strings.Builder
                buf := make([]byte, 8192) // 8KB buffer for streaming

                for </span><span class="cov0" title="0">{
                        n, readErr := r.Read(buf)
                        if n &gt; 0 </span><span class="cov0" title="0">{
                                output.Write(buf[:n])
                        }</span>
                        <span class="cov0" title="0">if readErr == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if readErr != nil </span><span class="cov0" title="0">{
                                errCh &lt;- readErr
                                return
                        }</span>
                }
                <span class="cov0" title="0">outCh &lt;- output.String()</span>
        }()

        // Execute the command
        <span class="cov0" title="0">execErr := rootCmd.Execute()

        // Close writer and restore
        w.Close()
        os.Stdout = oldStdout
        os.Args = oldArgs

        // Get output (wait for streaming to complete)
        select </span>{
        case output := &lt;-outCh:<span class="cov0" title="0">
                if execErr != nil </span><span class="cov0" title="0">{
                        return "", execErr
                }</span>
                <span class="cov0" title="0">return output, nil</span>
        case streamErr := &lt;-errCh:<span class="cov0" title="0">
                return "", streamErr</span>
        }
}

func sendResponse(id interface{}, result interface{}) <span class="cov0" title="0">{
        resp := jsonRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Result:  result,
        }
        data, _ := json.Marshal(resp)
        fmt.Println(string(data))
}</span>

func sendError(id interface{}, code int, message string, data interface{}) <span class="cov0" title="0">{
        resp := jsonRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error: map[string]interface{}{
                        "code":    code,
                        "message": message,
                        "data":    data,
                },
        }
        jsonData, _ := json.Marshal(resp)
        fmt.Println(string(jsonData))
}</span>

// sendErrorWithType sends an error response with both numeric code and string type
// Phase 14 enhancement: Adds semantic error type for better error categorization
func sendErrorWithType(id interface{}, code int, errType string, message string, data interface{}) <span class="cov0" title="0">{
        resp := jsonRPCResponse{
                JSONRPC: "2.0",
                ID:      id,
                Error: map[string]interface{}{
                        "code":    code,
                        "type":    errType, // Semantic error type (e.g., "SESSION_NOT_FOUND")
                        "message": message,
                        "data":    data,
                },
        }
        jsonData, _ := json.Marshal(resp)
        fmt.Println(string(jsonData))
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

// getConsolidatedToolsList returns the MCP tool definitions with scope parameter
// Phase 12 Revision: Consolidate _session tools into scope parameter
func getConsolidatedToolsList() []map[string]interface{} <span class="cov8" title="1">{
        // Common scope property for all tools (except get_session_stats for backward compat)
        // Phase 12: Default to 'project' for cross-session meta-cognition analysis
        scopeProperty := map[string]interface{}{
                "type":        "string",
                "enum":        []string{"session", "project"},
                "default":     "project",
                "description": "Query scope: 'project' (default) enables cross-session pattern discovery, 'session' limits to current session only. Project-level analysis is recommended for meta-cognition insights.",
        }

        outputFormatProperty := map[string]interface{}{
                "type":    "string",
                "enum":    []string{"jsonl", "tsv"},
                "default": "jsonl",
        }

        return []map[string]interface{}{
                // Backward compatibility: get_session_stats remains session-only
                {
                        "name":        "get_session_stats",
                        "description": "Get session statistics (turn count, tool usage, error rate). Use when user asks about session performance or workflow efficiency. Always operates on current session only.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "output_format": outputFormatProperty,
                                },
                        },
                },

                // Core analysis tools with scope parameter
                {
                        "name":        "analyze_errors",
                        "description": "[DEPRECATED] Use query_tools with status='error' filter instead. This tool will be removed in a future version. Analyze error patterns across project history (repeated failures, tool-specific errors, temporal trends). Default project-level scope enables discovery of persistent issues across sessions.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope":         scopeProperty,
                                        "output_format": outputFormatProperty,
                                },
                        },
                },
                {
                        "name":        "extract_tools",
                        "description": "Extract tool call history across all project sessions with pagination. Default project-level scope provides complete workflow timeline for pattern analysis. Use for meta-cognition: discovering tool usage evolution, identifying workflow optimization opportunities, or exporting data for external analysis.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "limit": map[string]interface{}{
                                                "type":        "integer",
                                                "default":     100,
                                                "description": "Maximum number of tools to extract (default 100, prevents overflow)",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                        },
                },

                // Query tools with scope parameter
                {
                        "name":        "query_tools",
                        "description": "Query tool call history across project with filters (tool name, status). Default project-level scope reveals cross-session usage patterns and trends. Use for meta-cognition: analyzing tool effectiveness over time, identifying frequently failing operations, or understanding workflow evolution. Supports filtering by tool name and execution status.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "tool": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Filter by tool name (e.g., 'Bash', 'Read', 'Edit')",
                                        },
                                        "status": map[string]interface{}{
                                                "type":        "string",
                                                "enum":        []string{"error", "success"},
                                                "description": "Filter by execution status",
                                        },
                                        "limit": map[string]interface{}{
                                                "type":        "integer",
                                                "default":     20,
                                                "description": "Maximum number of results (default 20)",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                        },
                },
                {
                        "name":        "query_user_messages",
                        "description": "Search user messages across all project sessions using regex patterns. Default project-level scope enables discovery of recurring prompt patterns and intent evolution. Use for meta-cognition: analyzing how your questions change over time, identifying successful prompt strategies, or reviewing conversation context across sessions.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "pattern": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Regex pattern to match in message content (required)",
                                        },
                                        "limit": map[string]interface{}{
                                                "type":        "integer",
                                                "default":     10,
                                                "description": "Maximum number of results (default 10)",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                                "required": []string{"pattern"},
                        },
                },
                {
                        "name":        "query_context",
                        "description": "Query context around specific errors across project history (turns before/after error occurrence). Default project-level scope helps identify if error patterns recur in similar contexts across sessions. Use for meta-cognition: understanding systematic causes of errors, recognizing environmental triggers, or comparing error contexts over time.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "error_signature": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Error pattern ID to query (required)",
                                        },
                                        "window": map[string]interface{}{
                                                "type":        "integer",
                                                "default":     3,
                                                "description": "Context window size in turns before/after (default 3)",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                                "required": []string{"error_signature"},
                        },
                },
                {
                        "name":        "query_tool_sequences",
                        "description": "Query repeated tool call sequences across project history (workflow patterns like 'Read-&gt;Edit-&gt;Bash'). Default project-level scope reveals your evolved workflow habits and automation opportunities. Use for meta-cognition: discovering repetitive patterns worth automating, identifying inefficient workflows, or understanding how your tool usage evolves.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "min_occurrences": map[string]interface{}{
                                                "type":        "integer",
                                                "default":     3,
                                                "description": "Minimum occurrences to report (default 3)",
                                        },
                                        "pattern": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Specific sequence pattern to match (e.g., 'Read -&gt; Edit -&gt; Bash')",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                        },
                },
                {
                        "name":        "query_file_access",
                        "description": "Query file operation history across project (read/edit/write operations on specific files). Default project-level scope shows complete file evolution timeline. Use for meta-cognition: identifying frequently churned files, understanding refactoring patterns, or tracking file modification frequency over time.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "file": map[string]interface{}{
                                                "type":        "string",
                                                "description": "File path to query (required)",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                                "required": []string{"file"},
                        },
                },
                {
                        "name":        "query_project_state",
                        "description": "Query project state evolution across all sessions (active files, task progression, change patterns). Default project-level scope provides comprehensive project timeline. Use for meta-cognition: understanding how project focus shifts over time, tracking long-term progress, or identifying stalled initiatives.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope":         scopeProperty,
                                        "output_format": outputFormatProperty,
                                },
                        },
                },
                {
                        "name":        "query_successful_prompts",
                        "description": "Query historically successful prompt patterns across all project sessions (prompts that led to successful outcomes). Default project-level scope identifies your most effective prompting strategies over time. Use for meta-cognition: learning what prompt patterns work best for you, improving future interactions, or generating prompt templates.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "min_quality_score": map[string]interface{}{
                                                "type":        "number",
                                                "default":     0.8,
                                                "description": "Minimum quality score (0.0-1.0, default 0.8)",
                                        },
                                        "limit": map[string]interface{}{
                                                "type":        "integer",
                                                "default":     10,
                                                "description": "Maximum number of results (default 10)",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                        },
                },

                // Phase 10: Advanced query tools with scope
                {
                        "name":        "query_tools_advanced",
                        "description": "Query tool calls with SQL-like filter expressions across project sessions. Default project-level scope enables complex multi-condition analysis (e.g., 'tool=\"Bash\" AND status=\"error\" AND duration&gt;5000'). Use for meta-cognition: discovering subtle patterns through advanced filtering, analyzing correlations between tool usage and outcomes, or investigating specific workflow hypotheses across sessions.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "where": map[string]interface{}{
                                                "type":        "string",
                                                "description": "SQL-like filter expression (e.g., \"tool='Bash' AND status='error'\")",
                                        },
                                        "limit": map[string]interface{}{
                                                "type":        "integer",
                                                "default":     20,
                                                "description": "Maximum number of results (default 20)",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                                "required": []string{"where"},
                        },
                },
                {
                        "name":        "aggregate_stats",
                        "description": "Aggregate statistics grouped by field (tool, status, or uuid) across all project sessions. Default project-level scope provides comprehensive summary metrics (tool counts, error rates) for cross-session comparison. Use for meta-cognition: identifying which tools are most reliable over time, comparing error rates across different workflow phases, or tracking overall efficiency improvements across the project lifecycle.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "group_by": map[string]interface{}{
                                                "type":        "string",
                                                "enum":        []string{"tool", "status", "uuid"},
                                                "default":     "tool",
                                                "description": "Field to group by (tool, status, or uuid)",
                                        },
                                        "metrics": map[string]interface{}{
                                                "type":        "string",
                                                "default":     "count,error_rate",
                                                "description": "Comma-separated metrics (count, error_rate)",
                                        },
                                        "where": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Optional filter expression",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                        },
                },
                {
                        "name":        "query_time_series",
                        "description": "Analyze metrics over time (tool call frequency, error rates) bucketed by hour/day/week across project history. Default project-level scope reveals temporal patterns and workflow evolution. Use for meta-cognition: discovering peak productivity hours, identifying when errors cluster temporally, understanding how your workflow rhythm changes over project phases, or detecting burnout signals through activity pattern shifts.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "metric": map[string]interface{}{
                                                "type":        "string",
                                                "enum":        []string{"tool-calls", "error-rate"},
                                                "default":     "tool-calls",
                                                "description": "Metric to analyze (tool-calls or error-rate)",
                                        },
                                        "interval": map[string]interface{}{
                                                "type":        "string",
                                                "enum":        []string{"hour", "day", "week"},
                                                "default":     "hour",
                                                "description": "Time interval for bucketing",
                                        },
                                        "where": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Optional filter expression",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                        },
                },
                {
                        "name":        "query_files",
                        "description": "File-level operation statistics (total operations, edit/read/write counts, error rates) across all project sessions. Default project-level scope identifies files with persistent churn or error patterns. Use for meta-cognition: discovering architectural hotspots that require frequent changes, identifying files prone to editing errors, understanding which parts of the codebase consume most attention, or detecting refactoring opportunities through file access patterns.",
                        "inputSchema": map[string]interface{}{
                                "type": "object",
                                "properties": map[string]interface{}{
                                        "scope": scopeProperty,
                                        "sort_by": map[string]interface{}{
                                                "type":        "string",
                                                "enum":        []string{"total_ops", "edit_count", "read_count", "write_count", "error_count", "error_rate"},
                                                "default":     "total_ops",
                                                "description": "Sort field",
                                        },
                                        "top": map[string]interface{}{
                                                "type":        "integer",
                                                "default":     20,
                                                "description": "Limit results to top N files",
                                        },
                                        "where": map[string]interface{}{
                                                "type":        "string",
                                                "description": "Optional filter expression",
                                        },
                                        "output_format": outputFormatProperty,
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/analyzer"
        "github.com/yale/meta-cc/internal/filter"
        internalOutput "github.com/yale/meta-cc/internal/output"
        "github.com/yale/meta-cc/internal/parser"
        "github.com/yale/meta-cc/pkg/output"
)

var (
        extractType   string
        extractFilter string
)

// parseCmd represents the parse subcommand
var parseCmd = &amp;cobra.Command{
        Use:   "parse",
        Short: "Parse Claude Code session files",
        Long: `Parse Claude Code session files and extract structured data.

Examples:
  meta-cc parse extract --type turns
  meta-cc parse extract --type tools --output md
  meta-cc parse extract --type tools --filter "status=error"`,
}

// parseExtractCmd represents the parse extract sub-subcommand
var parseExtractCmd = &amp;cobra.Command{
        Use:   "extract",
        Short: "Extract data from session",
        Long: `Extract structured data from Claude Code session files.

Supported types:
  - turns:  All conversation turns (user and assistant messages)
  - tools:  Tool calls with their results
  - errors: Failed tool calls and error messages`,
        RunE: runParseExtract,
}

func init() <span class="cov8" title="1">{
        // Add parse subcommand to root
        rootCmd.AddCommand(parseCmd)

        // Add extract sub-subcommand to parse
        parseCmd.AddCommand(parseExtractCmd)

        // extract subcommand parameters
        parseExtractCmd.Flags().StringVarP(&amp;extractType, "type", "t", "turns", "Data type to extract: turns|tools|errors")
        parseExtractCmd.Flags().StringVarP(&amp;extractFilter, "filter", "f", "", "Filter data (e.g., \"status=error\")")

        // --output parameter is already defined in root.go as global parameter
}</span>

func runParseExtract(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Step 1: Validate parameters
        validTypes := map[string]bool{
                "turns":  true,
                "tools":  true,
                "errors": true,
        }

        if !validTypes[extractType] </span><span class="cov8" title="1">{
                return internalOutput.OutputError(
                        fmt.Errorf("invalid type '%s': must be one of: turns, tools, errors", extractType),
                        internalOutput.ErrInvalidArgument,
                        outputFormat,
                )
        }</span>

        // Step 2: Initialize and load session using pipeline
        <span class="cov8" title="1">p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov8" title="1">{
                return internalOutput.OutputError(err, internalOutput.ErrSessionNotFound, outputFormat)
        }</span>

        // Step 3: Extract data based on type
        <span class="cov8" title="1">var data interface{}

        switch extractType </span>{
        case "turns":<span class="cov8" title="1">
                data = p.GetEntries()</span>
        case "tools":<span class="cov8" title="1">
                data = p.ExtractToolCalls()</span>
        case "errors":<span class="cov0" title="0">
                // Extract failed tool calls
                toolCalls := p.ExtractToolCalls()
                var errorCalls []parser.ToolCall
                for _, tc := range toolCalls </span><span class="cov0" title="0">{
                        if tc.Status == "error" || tc.Error != "" </span><span class="cov0" title="0">{
                                errorCalls = append(errorCalls, tc)
                        }</span>
                }
                <span class="cov0" title="0">data = errorCalls</span>
        }

        // Step 4.5: Apply filter (if provided)
        <span class="cov8" title="1">if extractFilter != "" </span><span class="cov0" title="0">{
                filterObj, err := filter.ParseFilter(extractFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return internalOutput.OutputError(err, internalOutput.ErrFilterError, outputFormat)
                }</span>

                <span class="cov0" title="0">data = filter.ApplyFilter(data, filterObj)</span>
        }

        // Step 4.6: Handle --estimate-size flag (Phase 9.1)
        <span class="cov8" title="1">if estimateSizeFlag </span><span class="cov0" title="0">{
                // Only estimate for tool calls
                if toolCalls, ok := data.([]parser.ToolCall); ok </span><span class="cov0" title="0">{
                        estimate, err := output.EstimateToolCallsSize(toolCalls, outputFormat)
                        if err != nil </span><span class="cov0" title="0">{
                                return internalOutput.OutputError(err, internalOutput.ErrInternalError, outputFormat)
                        }</span>

                        <span class="cov0" title="0">estimateStr, _ := output.FormatJSONL(estimate)
                        fmt.Fprintln(cmd.OutOrStdout(), estimateStr)
                        return nil</span>
                }
        }

        // Step 4.7: Apply pagination (Phase 9.1)
        <span class="cov8" title="1">if toolCalls, ok := data.([]parser.ToolCall); ok </span><span class="cov8" title="1">{
                paginationConfig := filter.PaginationConfig{
                        Limit:  limitFlag,
                        Offset: offsetFlag,
                }
                data = filter.ApplyPagination(toolCalls, paginationConfig)
        }</span>

        // Step 5: Check for empty results
        <span class="cov8" title="1">switch v := data.(type) </span>{
        case []parser.ToolCall:<span class="cov8" title="1">
                if len(v) == 0 </span><span class="cov0" title="0">{
                        return internalOutput.WarnNoResults(outputFormat)
                }</span>
        case []parser.SessionEntry:<span class="cov8" title="1">
                if len(v) == 0 </span><span class="cov0" title="0">{
                        return internalOutput.WarnNoResults(outputFormat)
                }</span>
        }

        // Step 6: Format output
        <span class="cov8" title="1">outputStr, formatErr := internalOutput.FormatOutput(data, outputFormat)
        if formatErr != nil </span><span class="cov0" title="0">{
                return internalOutput.OutputError(formatErr, internalOutput.ErrInternalError, outputFormat)
        }</span>

        <span class="cov8" title="1">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
        return nil</span>
}

var (
        statsMetrics string // 用于过滤统计指标
)

// parseStatsCmd represents the parse stats sub-subcommand
var parseStatsCmd = &amp;cobra.Command{
        Use:   "stats",
        Short: "Show session statistics",
        Long: `Show statistical analysis of Claude Code session data.

Displays metrics including:
  - Turn counts (total, user, assistant)
  - Tool call counts and frequency
  - Error counts and error rate
  - Session duration
  - Top tools by usage

Examples:
  meta-cc parse stats
  meta-cc parse stats --output md
  meta-cc parse stats --metrics tools,errors`,
        RunE: runParseStats,
}

func init() <span class="cov8" title="1">{
        // Add stats sub-subcommand to parse
        parseCmd.AddCommand(parseStatsCmd)

        // stats subcommand parameters
        parseStatsCmd.Flags().StringVarP(&amp;statsMetrics, "metrics", "m", "", "Filter metrics to display (e.g., \"tools,errors,duration\")")

        // --output parameter is already defined in root.go as global parameter
}</span>

func runParseStats(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov8" title="1">{
                return internalOutput.OutputError(err, internalOutput.ErrSessionNotFound, outputFormat)
        }</span>

        // Step 2: Extract entries and tool calls
        <span class="cov8" title="1">entries := p.GetEntries()
        toolCalls := p.ExtractToolCalls()

        // Step 4: Calculate statistics (using Stage 4.1 analyzer)
        stats := analyzer.CalculateStats(entries, toolCalls)

        // Step 4.5: Handle --estimate-size flag (Phase 9.1)
        if estimateSizeFlag </span><span class="cov0" title="0">{
                estimate := output.EstimateStatsSize(outputFormat)
                estimateStr, _ := output.FormatJSONL(estimate)
                fmt.Fprintln(cmd.OutOrStdout(), estimateStr)
                return nil
        }</span>

        // Step 5: Filter metrics if specified
        <span class="cov8" title="1">var data interface{} = stats
        if statsMetrics != "" </span><span class="cov0" title="0">{
                // Simplified implementation: statsMetrics parameter is documented for future use
                // Complete metric filtering can be extended in subsequent phases
                data = stats
        }</span>

        // Step 6: Format output (using Phase 3 formatters)
        <span class="cov8" title="1">outputStr, formatErr := internalOutput.FormatOutput(data, outputFormat)
        if formatErr != nil </span><span class="cov0" title="0">{
                return internalOutput.OutputError(formatErr, internalOutput.ErrInternalError, outputFormat)
        }</span>

        <span class="cov8" title="1">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
        return nil</span>
}

// formatStatsMarkdown formats statistics as a Markdown report
func formatStatsMarkdown(stats analyzer.SessionStats) (string, error) <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("# Session Statistics\n\n")

        // Overview section
        sb.WriteString("## Overview\n\n")
        sb.WriteString(fmt.Sprintf("- **Total Turns**: %d\n", stats.TurnCount))
        sb.WriteString(fmt.Sprintf("  - User Turns: %d\n", stats.UserTurnCount))
        sb.WriteString(fmt.Sprintf("  - Assistant Turns: %d\n", stats.AssistantTurnCount))
        sb.WriteString(fmt.Sprintf("- **Session Duration**: %d seconds (%.1f minutes)\n",
                stats.DurationSeconds, float64(stats.DurationSeconds)/60))
        sb.WriteString("\n")

        // Tool Usage section
        sb.WriteString("## Tool Usage\n\n")
        sb.WriteString(fmt.Sprintf("- **Total Tool Calls**: %d\n", stats.ToolCallCount))
        sb.WriteString(fmt.Sprintf("- **Successful Calls**: %d\n", stats.ToolCallCount-stats.ErrorCount))
        sb.WriteString(fmt.Sprintf("- **Failed Calls**: %d\n", stats.ErrorCount))
        sb.WriteString(fmt.Sprintf("- **Error Rate**: %.1f%%\n", stats.ErrorRate))
        sb.WriteString("\n")

        // Top Tools section
        if len(stats.TopTools) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("### Top Tools\n\n")
                sb.WriteString("| Tool | Count | Percentage |\n")
                sb.WriteString("|------|-------|------------|\n")

                for _, tool := range stats.TopTools </span><span class="cov0" title="0">{
                        percentage := float64(0)
                        if stats.ToolCallCount &gt; 0 </span><span class="cov0" title="0">{
                                percentage = float64(tool.Count) / float64(stats.ToolCallCount) * 100
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("| %s | %d | %.1f%% |\n",
                                tool.Name, tool.Count, percentage))</span>
                }
                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        // Tool Frequency section
        <span class="cov0" title="0">if len(stats.ToolFrequency) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("### All Tools\n\n")
                for name, count := range stats.ToolFrequency </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("- **%s**: %d calls\n", name, count))
                }</span>
                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        <span class="cov0" title="0">return sb.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cmd

import (
        "fmt"

        "github.com/yale/meta-cc/internal/locator"
        "github.com/yale/meta-cc/internal/parser"
)

// GlobalOptions contains global CLI flags shared across commands.
// These options control session location and scope for all meta-cc commands.
type GlobalOptions struct {
        SessionID   string // Specific session ID to analyze (e.g., "abc-123")
        ProjectPath string // Project path for project-level analysis (e.g., ".")
        SessionOnly bool   // Force session-only mode (disable project-level default)
}

// LoadOptions controls session loading behavior.
// These options configure how the pipeline loads and validates session data.
type LoadOptions struct {
        AutoDetect bool // Enable automatic session detection
        Validate   bool // Enable validation during loading
}

// SessionPipeline encapsulates the session data processing flow.
// It provides a unified interface for locating, loading, and processing
// Claude Code session history across single or multiple sessions.
//
// Pipeline workflow:
//  1. NewSessionPipeline(opts) - Create pipeline with options
//  2. Load(loadOpts) - Locate and parse JSONL file(s)
//  3. Extract data via GetEntries(), ExtractToolCalls(), BuildTurnIndex()
//
// The pipeline supports both session-level and project-level modes:
//   - Session-level: Load single session (latest or specified by ID)
//   - Project-level: Load all sessions from project directory
type SessionPipeline struct {
        opts      GlobalOptions         // Configuration options
        session   string                // Loaded session identifier or path
        entries   []parser.SessionEntry // Parsed session entries
        turnIndex map[string]int        // UUID -&gt; turn sequence index (cached)
}

// NewSessionPipeline creates a new pipeline instance with the given options.
// The pipeline is initially empty; call Load() to populate it with session data.
func NewSessionPipeline(opts GlobalOptions) *SessionPipeline <span class="cov8" title="1">{
        return &amp;SessionPipeline{
                opts:      opts,
                turnIndex: make(map[string]int),
        }
}</span>

// Load locates and loads the session JSONL file(s) into the pipeline.
//
// Loading behavior depends on GlobalOptions:
//   - Project-level mode (ProjectPath set, SessionOnly=false):
//     Loads ALL sessions from the project directory for cross-session analysis
//   - Session-level mode (SessionOnly=true or SessionID specified):
//     Loads only the specified session or latest session from project
//
// The method uses SessionLocator to find session files, then parses them
// using SessionParser. All parsed entries are merged into p.entries.
//
// Returns error if session location fails or JSONL parsing fails.
func (p *SessionPipeline) Load(loadOpts LoadOptions) error <span class="cov8" title="1">{
        loc := locator.NewSessionLocator()

        // Determine if we should load multiple sessions (project-level mode)
        shouldLoadAllSessions := p.opts.ProjectPath != "" &amp;&amp; !p.opts.SessionOnly &amp;&amp; p.opts.SessionID == ""

        if shouldLoadAllSessions </span><span class="cov8" title="1">{
                // Project-level mode: load ALL sessions from project
                sessionPaths, err := loc.AllSessionsFromProject(p.opts.ProjectPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to locate project sessions: %w", err)
                }</span>

                // Parse and merge all sessions
                <span class="cov8" title="1">var allEntries []parser.SessionEntry
                for _, sessionPath := range sessionPaths </span><span class="cov8" title="1">{
                        sessionParser := parser.NewSessionParser(sessionPath)
                        entries, err := sessionParser.ParseEntries()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("JSONL parsing failed for %s: %w", sessionPath, err)
                        }</span>
                        <span class="cov8" title="1">allEntries = append(allEntries, entries...)</span>
                }

                <span class="cov8" title="1">p.entries = allEntries
                p.session = fmt.Sprintf("&lt;project:%s (%d sessions)&gt;", p.opts.ProjectPath, len(sessionPaths))</span>

        } else<span class="cov8" title="1"> {
                // Session-level mode: load single session (latest or specified)
                sessionPath, err := loc.Locate(locator.LocateOptions{
                        SessionID:   p.opts.SessionID,
                        ProjectPath: p.opts.ProjectPath,
                        SessionOnly: p.opts.SessionOnly,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("session location failed: %w", err)
                }</span>

                <span class="cov8" title="1">p.session = sessionPath

                // Parse JSONL
                sessionParser := parser.NewSessionParser(sessionPath)
                p.entries, err = sessionParser.ParseEntries()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("JSONL parsing failed: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ExtractToolCalls extracts all tool calls from loaded session entries.
// This method pairs tool_use and tool_result blocks to create complete ToolCall records
// containing both input parameters and execution results.
//
// Returns empty slice if no tool calls are found in the session(s).
func (p *SessionPipeline) ExtractToolCalls() []parser.ToolCall <span class="cov8" title="1">{
        return parser.ExtractToolCalls(p.entries)
}</span>

// BuildTurnIndex creates a UUID -&gt; turn_sequence mapping for all entries.
// The index maps each entry's UUID to its position in the conversation timeline.
// This is useful for temporal analysis and context retrieval.
//
// The index is cached after first call for performance.
// Returns the mapping where keys are UUIDs and values are 0-based indices.
func (p *SessionPipeline) BuildTurnIndex() map[string]int <span class="cov8" title="1">{
        if len(p.turnIndex) &gt; 0 </span><span class="cov8" title="1">{
                return p.turnIndex // cached
        }</span>

        <span class="cov8" title="1">for i, entry := range p.entries </span><span class="cov8" title="1">{
                p.turnIndex[entry.UUID] = i
        }</span>

        <span class="cov8" title="1">return p.turnIndex</span>
}

// SessionPath returns the loaded session identifier or file path.
// In session-level mode, returns the absolute path to the JSONL file.
// In project-level mode, returns a descriptive string like "&lt;project:path (N sessions)&gt;".
func (p *SessionPipeline) SessionPath() string <span class="cov8" title="1">{
        return p.session
}</span>

// EntryCount returns the total number of entries loaded from session(s).
// In project-level mode, this is the sum of entries across all sessions.
func (p *SessionPipeline) EntryCount() int <span class="cov8" title="1">{
        return len(p.entries)
}</span>

// GetEntries returns all parsed session entries.
// Entries are in chronological order based on the session file(s).
// This is the primary accessor for raw session data.
func (p *SessionPipeline) GetEntries() []parser.SessionEntry <span class="cov8" title="1">{
        return p.entries
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/filter"
        "github.com/yale/meta-cc/internal/parser"
)

var (
        // Common query parameters
        queryLimit   int
        querySortBy  string
        queryReverse bool
        queryOffset  int
        queryStream  bool // Enable JSONL streaming output

        // Time filter parameters
        querySince      string
        queryLastNTurns int
        queryFromTs     int64
        queryToTs       int64
)

// queryCmd represents the query command
var queryCmd = &amp;cobra.Command{
        Use:   "query",
        Short: "Query Claude Code session data",
        Long: `Query and retrieve specific data from Claude Code sessions.

The query command provides specialized subcommands for different data types:
  - tools:         Query tool calls with detailed filtering
  - user-messages: Query user messages with pattern matching

Examples:
  meta-cc query tools --status error --limit 20
  meta-cc query user-messages --match "fix.*bug"
  meta-cc query tools --tool Bash --sort-by timestamp`,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(queryCmd)

        // Common query parameters as persistent flags
        queryCmd.PersistentFlags().IntVarP(&amp;queryLimit, "limit", "l", 0, "Limit number of results (0 = no limit)")
        queryCmd.PersistentFlags().StringVarP(&amp;querySortBy, "sort-by", "s", "", "Sort by field (timestamp, tool, status)")
        queryCmd.PersistentFlags().BoolVarP(&amp;queryReverse, "reverse", "r", false, "Reverse sort order")
        queryCmd.PersistentFlags().IntVar(&amp;queryOffset, "offset", 0, "Skip first N results (for pagination)")
        queryCmd.PersistentFlags().BoolVar(&amp;queryStream, "stream", false, "Output as JSON Lines (JSONL) for streaming")

        // Time filter parameters as persistent flags
        queryCmd.PersistentFlags().StringVar(&amp;querySince, "since", "", "Filter entries since duration ago (e.g., '5 minutes ago', '1 hour ago')")
        queryCmd.PersistentFlags().IntVar(&amp;queryLastNTurns, "last-n-turns", 0, "Query last N turns only")
        queryCmd.PersistentFlags().Int64Var(&amp;queryFromTs, "from", 0, "Start timestamp (Unix)")
        queryCmd.PersistentFlags().Int64Var(&amp;queryToTs, "to", 0, "End timestamp (Unix)")
}</span>

// applyTimeFilter applies time-based filtering to session entries
func applyTimeFilter(entries []parser.SessionEntry) ([]parser.SessionEntry, error) <span class="cov0" title="0">{
        timeFilter := filter.TimeFilter{
                Since:      querySince,
                LastNTurns: queryLastNTurns,
                FromTs:     queryFromTs,
                ToTs:       queryToTs,
        }

        return timeFilter.Apply(entries)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/query"
)

var (
        contextErrorSig string
        contextWindow   int
)

// queryContextCmd represents the context query command
var queryContextCmd = &amp;cobra.Command{
        Use:   "context",
        Short: "Query context around specific events (errors, files, etc.)",
        Long: `Query context around specific events in Claude Code session history.

This command finds error occurrences and returns surrounding context including:
- User messages and assistant responses
- Tool calls before and after the error
- Timestamps and turn numbers

Example:
  meta-cc query context --error-signature abc123 --window 3
  meta-cc query context --error-signature abc123 --window 5 --output md`,
        RunE: runQueryContext,
}

func init() <span class="cov8" title="1">{
        queryContextCmd.Flags().StringVar(&amp;contextErrorSig, "error-signature", "", "Error pattern ID to query (required)")
        queryContextCmd.Flags().IntVar(&amp;contextWindow, "window", 3, "Context window size (turns before/after)")
        queryContextCmd.MarkFlagRequired("error-signature")

        queryCmd.AddCommand(queryContextCmd)
}</span>

func runQueryContext(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Apply time filter
        <span class="cov0" title="0">entries := p.GetEntries()
        entries, err := applyTimeFilter(entries)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply time filter: %w", err)
        }</span>

        // Build context query
        <span class="cov0" title="0">result, err := query.BuildContextQuery(entries, contextErrorSig, contextWindow)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build context query: %w", err)
        }</span>

        // Output result
        <span class="cov0" title="0">if outputFormat == "md" </span><span class="cov0" title="0">{
                return outputContextMarkdown(cmd, result)
        }</span>

        // JSON output (default)
        <span class="cov0" title="0">encoder := json.NewEncoder(cmd.OutOrStdout())
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)</span>
}

func outputContextMarkdown(cmd *cobra.Command, result *query.ContextQuery) error <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("# Context Query Result\n\n")
        sb.WriteString(fmt.Sprintf("**Error Signature**: `%s`\n\n", result.ErrorSignature))
        sb.WriteString(fmt.Sprintf("**Occurrences Found**: %d\n\n", len(result.Occurrences)))

        for i, occ := range result.Occurrences </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("## Occurrence %d (Turn %d)\n\n", i+1, occ.Turn))

                // Context before
                if len(occ.ContextBefore) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString("### Context Before\n\n")
                        sb.WriteString("| Turn | Role | Preview | Tools |\n")
                        sb.WriteString("|------|------|---------|-------|\n")
                        for _, ctx := range occ.ContextBefore </span><span class="cov0" title="0">{
                                toolsStr := formatToolsList(ctx.Tools)
                                sb.WriteString(fmt.Sprintf("| %d | %s | %s | %s |\n",
                                        ctx.Turn, ctx.Role, ctx.Preview, toolsStr))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }

                // Error turn
                <span class="cov0" title="0">sb.WriteString("### Error Turn\n\n")
                sb.WriteString("| Field | Value |\n")
                sb.WriteString("|-------|-------|\n")
                sb.WriteString(fmt.Sprintf("| Turn | %d |\n", occ.ErrorTurn.Turn))
                sb.WriteString(fmt.Sprintf("| Tool | %s |\n", occ.ErrorTurn.Tool))
                if occ.ErrorTurn.Command != "" </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("| Command | %s |\n", occ.ErrorTurn.Command))
                }</span>
                <span class="cov0" title="0">if occ.ErrorTurn.File != "" </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("| File | %s |\n", occ.ErrorTurn.File))
                }</span>
                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("| Error | %s |\n\n", occ.ErrorTurn.Error))

                // Context after
                if len(occ.ContextAfter) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString("### Context After\n\n")
                        sb.WriteString("| Turn | Role | Preview | Tools |\n")
                        sb.WriteString("|------|------|---------|-------|\n")
                        for _, ctx := range occ.ContextAfter </span><span class="cov0" title="0">{
                                toolsStr := formatToolsList(ctx.Tools)
                                sb.WriteString(fmt.Sprintf("| %d | %s | %s | %s |\n",
                                        ctx.Turn, ctx.Role, ctx.Preview, toolsStr))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }
        }

        <span class="cov0" title="0">fmt.Fprint(cmd.OutOrStdout(), sb.String())
        return nil</span>
}

func formatToolsList(tools []string) string <span class="cov0" title="0">{
        if len(tools) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">result := ""
        for i, tool := range tools </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += ", "
                }</span>
                <span class="cov0" title="0">result += tool</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/filter"
        internalOutput "github.com/yale/meta-cc/internal/output"
        "github.com/yale/meta-cc/pkg/output"
)

var queryErrorsCmd = &amp;cobra.Command{
        Use:   "errors",
        Short: "Query tool errors",
        Long: `Extract all tool errors from session.

Returns a simple list of errors with signatures for downstream analysis.
Use jq, awk, or LLM for pattern detection and aggregation.

Examples:
  # All errors
  meta-cc query errors

  # Last 50 errors
  meta-cc query errors | jq '.[-50:]'

  # Group by signature
  meta-cc query errors | jq 'group_by(.signature)'

  # Count patterns
  meta-cc query errors | jq 'group_by(.signature) | map({sig: .[0].signature, count: length})'`,
        RunE: runQueryErrors,
}

func init() <span class="cov8" title="1">{
        queryCmd.AddCommand(queryErrorsCmd)
}</span>

func runQueryErrors(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // 1. Initialize pipeline
        p := NewSessionPipeline(getGlobalOptions())

        // 2. Load session
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return internalOutput.OutputError(err, internalOutput.ErrSessionNotFound, outputFormat)
        }</span>

        // 3. Extract tool calls
        <span class="cov0" title="0">tools := p.ExtractToolCalls()

        // 4. Filter errors only
        var errors []output.ErrorEntry
        for _, tool := range tools </span><span class="cov0" title="0">{
                if tool.Status == "error" || tool.Error != "" </span><span class="cov0" title="0">{
                        errors = append(errors, output.ErrorEntry{
                                UUID:      tool.UUID,
                                Timestamp: tool.Timestamp,
                                ToolName:  tool.ToolName,
                                Error:     tool.Error,
                                Signature: generateErrorSignature(tool.ToolName, tool.Error),
                        })
                }</span>
        }

        // 5. Apply default deterministic sorting (by timestamp)
        // This ensures same query always produces same output order
        <span class="cov0" title="0">output.SortByTimestamp(errors)

        // 6. Apply pagination if specified
        if limitFlag &gt; 0 || offsetFlag &gt; 0 </span><span class="cov0" title="0">{
                paginationConfig := filter.PaginationConfig{
                        Limit:  limitFlag,
                        Offset: offsetFlag,
                }
                errors = applyErrorPagination(errors, paginationConfig)
        }</span>

        // 7. Check for empty results
        <span class="cov0" title="0">if len(errors) == 0 </span><span class="cov0" title="0">{
                return internalOutput.WarnNoResults(outputFormat)
        }</span>

        // 8. Format output
        <span class="cov0" title="0">outputStr, formatErr := internalOutput.FormatOutput(errors, outputFormat)
        if formatErr != nil </span><span class="cov0" title="0">{
                return internalOutput.OutputError(formatErr, internalOutput.ErrInternalError, outputFormat)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
        return nil</span>
}

// generateErrorSignature creates a simple signature: {tool}:{error_prefix}
func generateErrorSignature(toolName, errorText string) string <span class="cov8" title="1">{
        // Take first 50 chars of error for signature
        prefix := errorText
        if len(errorText) &gt; 50 </span><span class="cov8" title="1">{
                prefix = errorText[:50]
        }</span>

        // Normalize whitespace
        <span class="cov8" title="1">prefix = strings.Join(strings.Fields(prefix), " ")

        return fmt.Sprintf("%s:%s", toolName, prefix)</span>
}

// applyErrorPagination applies pagination to error entries
func applyErrorPagination(errors []output.ErrorEntry, config filter.PaginationConfig) []output.ErrorEntry <span class="cov0" title="0">{
        start := config.Offset
        if start &gt;= len(errors) </span><span class="cov0" title="0">{
                return []output.ErrorEntry{}
        }</span>

        <span class="cov0" title="0">end := len(errors)
        if config.Limit &gt; 0 </span><span class="cov0" title="0">{
                end = start + config.Limit
                if end &gt; len(errors) </span><span class="cov0" title="0">{
                        end = len(errors)
                }</span>
        }

        <span class="cov0" title="0">return errors[start:end]</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/query"
)

var (
        fileAccessFile string
)

// queryFileAccessCmd represents the file-access query command
var queryFileAccessCmd = &amp;cobra.Command{
        Use:   "file-access",
        Short: "Query file access history",
        Long: `Query file access history in Claude Code session.

This command tracks all operations (Read/Edit/Write) on a specific file, including:
- Total number of accesses
- Operations breakdown
- Timeline of accesses
- Time span in minutes

Example:
  meta-cc query file-access --file test.js
  meta-cc query file-access --file /path/to/config.yaml --output md`,
        RunE: runQueryFileAccess,
}

func init() <span class="cov8" title="1">{
        queryFileAccessCmd.Flags().StringVar(&amp;fileAccessFile, "file", "", "File path to query (required)")
        queryFileAccessCmd.MarkFlagRequired("file")

        queryCmd.AddCommand(queryFileAccessCmd)
}</span>

func runQueryFileAccess(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Apply time filter
        <span class="cov0" title="0">entries := p.GetEntries()
        entries, err := applyTimeFilter(entries)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply time filter: %w", err)
        }</span>

        // Build file access query
        <span class="cov0" title="0">result, err := query.BuildFileAccessQuery(entries, fileAccessFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build file access query: %w", err)
        }</span>

        // Output result
        <span class="cov0" title="0">if outputFormat == "md" </span><span class="cov0" title="0">{
                return outputFileAccessMarkdown(cmd, result)
        }</span>

        // JSON output (default)
        <span class="cov0" title="0">encoder := json.NewEncoder(cmd.OutOrStdout())
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)</span>
}

func outputFileAccessMarkdown(cmd *cobra.Command, result *query.FileAccessQuery) error <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("# File Access History\n\n")
        sb.WriteString(fmt.Sprintf("**File**: `%s`\n\n", result.File))
        sb.WriteString(fmt.Sprintf("**Total Accesses**: %d\n\n", result.TotalAccesses))
        sb.WriteString(fmt.Sprintf("**Time Span**: %d minutes\n\n", result.TimeSpanMin))

        // Operations breakdown
        if len(result.Operations) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Operations Breakdown\n\n")
                sb.WriteString("| Operation | Count |\n")
                sb.WriteString("|-----------|-------|\n")
                for op, count := range result.Operations </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("| %s | %d |\n", op, count))
                }</span>
                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        // Timeline
        <span class="cov0" title="0">if len(result.Timeline) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Access Timeline\n\n")
                sb.WriteString("| Turn | Action | Timestamp |\n")
                sb.WriteString("|------|--------|----------|\n")
                for _, event := range result.Timeline </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("| %d | %s | %d |\n",
                                event.Turn, event.Action, event.Timestamp))
                }</span>
        }

        <span class="cov0" title="0">fmt.Fprint(cmd.OutOrStdout(), sb.String())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cmd

import (
        "fmt"
        "regexp"
        "sort"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/parser"
        "github.com/yale/meta-cc/pkg/output"
)

var (
        queryMessagesMatch   string
        queryMessagesContext int
)

var queryUserMessagesCmd = &amp;cobra.Command{
        Use:   "user-messages",
        Short: "Query user messages",
        Long: `Query user messages with pattern matching.

Supports:
  - Pattern matching (--match: regex pattern)
  - Timestamp sorting
  - Limit and pagination

Examples:
  meta-cc query user-messages --match "fix.*bug"
  meta-cc query user-messages --match "error" --limit 10
  meta-cc query user-messages --sort-by timestamp --reverse`,
        RunE: runQueryUserMessages,
}

func init() <span class="cov8" title="1">{
        queryCmd.AddCommand(queryUserMessagesCmd)

        queryUserMessagesCmd.Flags().StringVar(&amp;queryMessagesMatch, "match", "", "Match pattern (regex)")
        queryUserMessagesCmd.Flags().IntVar(&amp;queryMessagesContext, "with-context", 0, "Include N turns before/after each match")
}</span>

// UserMessage represents a user message with metadata
type UserMessage struct {
        TurnSequence  int            `json:"turn_sequence"`
        UUID          string         `json:"uuid"`
        Timestamp     string         `json:"timestamp"`
        Content       string         `json:"content"`
        ContextBefore []ContextEntry `json:"context_before,omitempty"`
        ContextAfter  []ContextEntry `json:"context_after,omitempty"`
}

// ContextEntry represents a turn's context (before or after)
type ContextEntry struct {
        Turn      int      `json:"turn"`
        Role      string   `json:"role"`
        Summary   string   `json:"summary"`
        ToolCalls []string `json:"tool_calls,omitempty"`
}

func runQueryUserMessages(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Step 2: Build turn index and extract user messages
        <span class="cov0" title="0">entries := p.GetEntries()
        turnIndex := p.BuildTurnIndex()
        userMessages := extractUserMessages(entries, turnIndex)

        // Step 3: Apply pattern matching
        if queryMessagesMatch != "" </span><span class="cov0" title="0">{
                pattern, err := regexp.Compile(queryMessagesMatch)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid regex pattern: %w", err)
                }</span>

                <span class="cov0" title="0">var filtered []UserMessage
                for _, msg := range userMessages </span><span class="cov0" title="0">{
                        if pattern.MatchString(msg.Content) </span><span class="cov0" title="0">{
                                filtered = append(filtered, msg)
                        }</span>
                }
                <span class="cov0" title="0">userMessages = filtered</span>
        }

        // Step 4: Apply default deterministic sorting (by turn sequence)
        // This ensures same query always produces same output order
        <span class="cov0" title="0">sortUserMessages(userMessages, "turn_sequence", false)

        // Step 4b: Apply custom sort if requested (overrides default)
        if querySortBy != "" </span><span class="cov0" title="0">{
                sortUserMessages(userMessages, querySortBy, queryReverse)
        }</span>

        // Step 5: Add context if requested
        <span class="cov0" title="0">if queryMessagesContext &gt; 0 </span><span class="cov0" title="0">{
                userMessages = addContextToMessages(userMessages, entries, turnIndex, queryMessagesContext)
        }</span>

        // Step 6: Apply offset
        <span class="cov0" title="0">if queryOffset &gt; 0 </span><span class="cov0" title="0">{
                if queryOffset &lt; len(userMessages) </span><span class="cov0" title="0">{
                        userMessages = userMessages[queryOffset:]
                }</span> else<span class="cov0" title="0"> {
                        userMessages = []UserMessage{}
                }</span>
        }

        // Step 7: Apply limit
        <span class="cov0" title="0">if queryLimit &gt; 0 &amp;&amp; len(userMessages) &gt; queryLimit </span><span class="cov0" title="0">{
                userMessages = userMessages[:queryLimit]
        }</span>

        // Step 8: Format output
        <span class="cov0" title="0">var outputStr string
        var formatErr error

        switch outputFormat </span>{
        case "jsonl":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatJSONL(userMessages)</span>
        case "tsv":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatTSV(userMessages)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s (supported: jsonl, tsv)", outputFormat)</span>
        }

        <span class="cov0" title="0">if formatErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format output: %w", formatErr)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
        return nil</span>
}

func extractUserMessages(entries []parser.SessionEntry, turnIndex map[string]int) []UserMessage <span class="cov0" title="0">{
        var messages []UserMessage

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Only process user entries
                if entry.Type != "user" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip entries without Message
                <span class="cov0" title="0">if entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract text content from content blocks
                <span class="cov0" title="0">var content string
                for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "text" </span><span class="cov0" title="0">{
                                content += block.Text
                        }</span>
                }

                // Only include if there's actual content AND it's not a system message
                <span class="cov0" title="0">if content != "" &amp;&amp; !isSystemMessage(content) </span><span class="cov0" title="0">{
                        turn := turnIndex[entry.UUID]
                        messages = append(messages, UserMessage{
                                TurnSequence: turn,
                                UUID:         entry.UUID,
                                Timestamp:    entry.Timestamp,
                                Content:      content,
                        })
                }</span>
        }

        <span class="cov0" title="0">return messages</span>
}

// isSystemMessage checks if the content is a system-generated message
// System messages include:
// - Slash command trigger messages: &lt;command-message&gt;, &lt;command-name&gt;, &lt;command-args&gt;
// - Slash command expanded content: starts with "# meta-"
// - Local command output: &lt;local-command&gt;
// - System warnings: "Caveat:"
func isSystemMessage(content string) bool <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(content)

        // Empty content is not a system message
        if trimmed == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">systemPrefixes := []string{
                "&lt;command-message&gt;",
                "&lt;command-name&gt;",
                "&lt;command-args&gt;",
                "&lt;local-command",
                "Caveat:",
                "# meta-", // Slash command expanded content
        }

        for _, prefix := range systemPrefixes </span><span class="cov8" title="1">{
                if strings.HasPrefix(trimmed, prefix) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// buildTurnIndex builds a map from UUID to turn number
// This is kept as a helper for other commands that still use it
func buildTurnIndex(entries []parser.SessionEntry) map[string]int <span class="cov0" title="0">{
        turnIndex := make(map[string]int)
        turn := 0

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsMessage() </span><span class="cov0" title="0">{
                        turn++
                        turnIndex[entry.UUID] = turn
                }</span>
        }

        <span class="cov0" title="0">return turnIndex</span>
}

// addContextToMessages adds context before and after each message
func addContextToMessages(messages []UserMessage, entries []parser.SessionEntry, turnIndex map[string]int, contextWindow int) []UserMessage <span class="cov0" title="0">{
        // Build reverse index: turn -&gt; entry
        entryByTurn := make(map[int]parser.SessionEntry)
        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsMessage() </span><span class="cov0" title="0">{
                        turn := turnIndex[entry.UUID]
                        entryByTurn[turn] = entry
                }</span>
        }

        // Add context to each message
        <span class="cov0" title="0">for i := range messages </span><span class="cov0" title="0">{
                msg := &amp;messages[i]

                // Context before
                for j := 1; j &lt;= contextWindow; j++ </span><span class="cov0" title="0">{
                        prevTurn := msg.TurnSequence - j
                        if entry, ok := entryByTurn[prevTurn]; ok </span><span class="cov0" title="0">{
                                contextEntry := buildContextEntry(entry, prevTurn, turnIndex)
                                msg.ContextBefore = append([]ContextEntry{contextEntry}, msg.ContextBefore...)
                        }</span>
                }

                // Context after
                <span class="cov0" title="0">for j := 1; j &lt;= contextWindow; j++ </span><span class="cov0" title="0">{
                        nextTurn := msg.TurnSequence + j
                        if entry, ok := entryByTurn[nextTurn]; ok </span><span class="cov0" title="0">{
                                contextEntry := buildContextEntry(entry, nextTurn, turnIndex)
                                msg.ContextAfter = append(msg.ContextAfter, contextEntry)
                        }</span>
                }
        }

        <span class="cov0" title="0">return messages</span>
}

// buildContextEntry builds a context entry from a session entry
func buildContextEntry(entry parser.SessionEntry, turn int, turnIndex map[string]int) ContextEntry <span class="cov0" title="0">{
        contextEntry := ContextEntry{
                Turn: turn,
                Role: entry.Type,
        }

        if entry.Message != nil </span><span class="cov0" title="0">{
                // Extract summary (first 100 chars)
                var content string
                for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "text" </span><span class="cov0" title="0">{
                                content += block.Text
                        }</span>
                }
                <span class="cov0" title="0">if len(content) &gt; 100 </span><span class="cov0" title="0">{
                        contextEntry.Summary = content[:100] + "..."
                }</span> else<span class="cov0" title="0"> {
                        contextEntry.Summary = content
                }</span>

                // Extract tool calls
                <span class="cov0" title="0">for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "tool_use" &amp;&amp; block.ToolUse != nil </span><span class="cov0" title="0">{
                                contextEntry.ToolCalls = append(contextEntry.ToolCalls, block.ToolUse.Name)
                        }</span>
                }
        }

        <span class="cov0" title="0">return contextEntry</span>
}

func sortUserMessages(messages []UserMessage, sortBy string, reverse bool) <span class="cov0" title="0">{
        // Use stable sort to preserve relative order for equal values
        sort.SliceStable(messages, func(i, j int) bool </span><span class="cov0" title="0">{
                var less bool

                switch sortBy </span>{
                case "turn_sequence":<span class="cov0" title="0">
                        less = messages[i].TurnSequence &lt; messages[j].TurnSequence</span>
                case "timestamp":<span class="cov0" title="0">
                        less = messages[i].Timestamp &lt; messages[j].Timestamp</span>
                case "uuid":<span class="cov0" title="0">
                        less = messages[i].UUID &lt; messages[j].UUID</span>
                default:<span class="cov0" title="0">
                        // Default: sort by turn sequence (deterministic)
                        less = messages[i].TurnSequence &lt; messages[j].TurnSequence</span>
                }

                <span class="cov0" title="0">if reverse </span><span class="cov0" title="0">{
                        return !less
                }</span>
                <span class="cov0" title="0">return less</span>
        })
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "regexp"
        "sort"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/parser"
)

var (
        projectStateIncludeTasks bool
)

// queryProjectStateCmd represents the project-state query command
var queryProjectStateCmd = &amp;cobra.Command{
        Use:   "project-state",
        Short: "Query current project state from session",
        Long: `Query current project state including recent files, incomplete tasks, and session quality.

This command analyzes the session to extract:
- Recent files modified (from file-history-snapshot)
- Incomplete stages/tasks mentioned
- Error-free turn count
- Current focus areas

Example:
  meta-cc query project-state --output json
  meta-cc query project-state --include-incomplete-tasks --output md`,
        RunE: runQueryProjectState,
}

func init() <span class="cov8" title="1">{
        queryProjectStateCmd.Flags().BoolVar(&amp;projectStateIncludeTasks, "include-incomplete-tasks", true, "Include incomplete tasks analysis")

        queryCmd.AddCommand(queryProjectStateCmd)
}</span>

func runQueryProjectState(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Build project state
        <span class="cov0" title="0">entries := p.GetEntries()
        state, err := buildProjectState(entries, projectStateIncludeTasks)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build project state: %w", err)
        }</span>

        // Output result
        <span class="cov0" title="0">if outputFormat == "md" </span><span class="cov0" title="0">{
                return outputProjectStateMarkdown(cmd, state)
        }</span>

        // JSON output (default)
        <span class="cov0" title="0">encoder := json.NewEncoder(cmd.OutOrStdout())
        encoder.SetIndent("", "  ")
        return encoder.Encode(state)</span>
}

// ProjectState represents the current project state
type ProjectState struct {
        SessionID          string           `json:"session_id"`
        RecentFiles        []FileActivity   `json:"recent_files"`
        IncompleteStages   []IncompleteTask `json:"incomplete_stages,omitempty"`
        LastErrorFreeTurns int              `json:"last_error_free_turns"`
        CurrentFocus       string           `json:"current_focus"`
        RecentAchievements []string         `json:"recent_achievements"`
}

// FileActivity represents a file's activity
type FileActivity struct {
        Path             string   `json:"path"`
        LastModifiedTurn int      `json:"last_modified_turn"`
        Operations       []string `json:"operations"`
        EditCount        int      `json:"edit_count"`
}

// IncompleteTask represents an incomplete stage or task
type IncompleteTask struct {
        Phase           int    `json:"phase,omitempty"`
        Stage           string `json:"stage,omitempty"`
        Title           string `json:"title"`
        MentionedInTurn int    `json:"mentioned_in_turn"`
}

func buildProjectState(entries []parser.SessionEntry, includeTasks bool) (*ProjectState, error) <span class="cov0" title="0">{
        // Extract session ID
        sessionID := ""
        if len(entries) &gt; 0 </span><span class="cov0" title="0">{
                sessionID = entries[0].SessionID
        }</span>

        // Build turn index
        <span class="cov0" title="0">turnIndex := buildTurnIndex(entries)

        // Extract recent files from file-history-snapshot
        recentFiles := extractRecentFiles(entries, turnIndex)

        // Extract incomplete tasks if requested
        var incompleteTasks []IncompleteTask
        if includeTasks </span><span class="cov0" title="0">{
                incompleteTasks = extractIncompleteTasks(entries, turnIndex)
        }</span>

        // Calculate error-free turns
        <span class="cov0" title="0">errorFreeTurns := calculateErrorFreeTurns(entries, turnIndex)

        // Determine current focus
        currentFocus := determineCurrentFocus(entries, turnIndex)

        // Extract recent achievements
        achievements := extractRecentAchievements(entries, turnIndex)

        return &amp;ProjectState{
                SessionID:          sessionID,
                RecentFiles:        recentFiles,
                IncompleteStages:   incompleteTasks,
                LastErrorFreeTurns: errorFreeTurns,
                CurrentFocus:       currentFocus,
                RecentAchievements: achievements,
        }, nil</span>
}

// extractRecentFiles extracts recently modified files from file-history-snapshot entries
func extractRecentFiles(entries []parser.SessionEntry, turnIndex map[string]int) []FileActivity <span class="cov0" title="0">{
        fileMap := make(map[string]*FileActivity)

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Look for file-history-snapshot entries
                if entry.Type != "file-history-snapshot" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse file operations from the entry
                // Note: file-history-snapshot entries contain file paths in a specific format
                // We'll need to extract this from the entry data
                // For now, use a simple heuristic based on tool calls
                <span class="cov0" title="0">for _, msgEntry := range entries </span><span class="cov0" title="0">{
                        if msgEntry.Message == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, block := range msgEntry.Message.Content </span><span class="cov0" title="0">{
                                if block.Type == "tool_use" &amp;&amp; block.ToolUse != nil </span><span class="cov0" title="0">{
                                        toolName := block.ToolUse.Name
                                        if toolName == "Read" || toolName == "Edit" || toolName == "Write" </span><span class="cov0" title="0">{
                                                // Extract file_path from input
                                                if filePath, ok := block.ToolUse.Input["file_path"].(string); ok </span><span class="cov0" title="0">{
                                                        if _, exists := fileMap[filePath]; !exists </span><span class="cov0" title="0">{
                                                                fileMap[filePath] = &amp;FileActivity{
                                                                        Path:       filePath,
                                                                        Operations: []string{},
                                                                        EditCount:  0,
                                                                }
                                                        }</span>

                                                        <span class="cov0" title="0">activity := fileMap[filePath]
                                                        msgTurn := turnIndex[msgEntry.UUID]

                                                        // Update last modified turn
                                                        if msgTurn &gt; activity.LastModifiedTurn </span><span class="cov0" title="0">{
                                                                activity.LastModifiedTurn = msgTurn
                                                        }</span>

                                                        // Track operation
                                                        <span class="cov0" title="0">if !contains(activity.Operations, toolName) </span><span class="cov0" title="0">{
                                                                activity.Operations = append(activity.Operations, toolName)
                                                        }</span>

                                                        // Count edits
                                                        <span class="cov0" title="0">if toolName == "Edit" || toolName == "Write" </span><span class="cov0" title="0">{
                                                                activity.EditCount++
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Convert map to slice and sort by last modified turn
        <span class="cov0" title="0">var result []FileActivity
        for _, activity := range fileMap </span><span class="cov0" title="0">{
                result = append(result, *activity)
        }</span>

        <span class="cov0" title="0">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                return result[i].LastModifiedTurn &gt; result[j].LastModifiedTurn
        }</span>)

        // Limit to top 10
        <span class="cov0" title="0">if len(result) &gt; 10 </span><span class="cov0" title="0">{
                result = result[:10]
        }</span>

        <span class="cov0" title="0">return result</span>
}

// extractIncompleteTasks extracts incomplete tasks from user messages
func extractIncompleteTasks(entries []parser.SessionEntry, turnIndex map[string]int) []IncompleteTask <span class="cov0" title="0">{
        var tasks []IncompleteTask

        // Patterns to match task mentions
        stagePattern := regexp.MustCompile(`(?i)Stage\s+(\d+)\.(\d+)`)
        phasePattern := regexp.MustCompile(`(?i)Phase\s+(\d+)`)
        todoPattern := regexp.MustCompile(`(?i)(?:TODO|待办|未完成|implement|添加|实现):\s*(.+)`)

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.Type != "user" || entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">turn := turnIndex[entry.UUID]

                // Extract text content
                var content string
                for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "text" </span><span class="cov0" title="0">{
                                content += block.Text
                        }</span>
                }

                // Match stage patterns
                <span class="cov0" title="0">if matches := stagePattern.FindStringSubmatch(content); len(matches) &gt;= 3 </span><span class="cov0" title="0">{
                        tasks = append(tasks, IncompleteTask{
                                Phase:           atoi(matches[1]),
                                Stage:           fmt.Sprintf("%s.%s", matches[1], matches[2]),
                                Title:           extractTaskTitle(content),
                                MentionedInTurn: turn,
                        })
                }</span>

                // Match phase patterns
                <span class="cov0" title="0">if matches := phasePattern.FindStringSubmatch(content); len(matches) &gt;= 2 </span><span class="cov0" title="0">{
                        tasks = append(tasks, IncompleteTask{
                                Phase:           atoi(matches[1]),
                                Title:           extractTaskTitle(content),
                                MentionedInTurn: turn,
                        })
                }</span>

                // Match TODO patterns
                <span class="cov0" title="0">if matches := todoPattern.FindStringSubmatch(content); len(matches) &gt;= 2 </span><span class="cov0" title="0">{
                        tasks = append(tasks, IncompleteTask{
                                Title:           strings.TrimSpace(matches[1]),
                                MentionedInTurn: turn,
                        })
                }</span>
        }

        // Remove duplicates and sort by turn (most recent first)
        <span class="cov0" title="0">tasks = deduplicateTasks(tasks)
        sort.Slice(tasks, func(i, j int) bool </span><span class="cov0" title="0">{
                return tasks[i].MentionedInTurn &gt; tasks[j].MentionedInTurn
        }</span>)

        // Limit to top 10
        <span class="cov0" title="0">if len(tasks) &gt; 10 </span><span class="cov0" title="0">{
                tasks = tasks[:10]
        }</span>

        <span class="cov0" title="0">return tasks</span>
}

// calculateErrorFreeTurns calculates consecutive error-free turns from the end
func calculateErrorFreeTurns(entries []parser.SessionEntry, turnIndex map[string]int) int <span class="cov0" title="0">{
        // Find all error turns
        errorTurns := make(map[int]bool)

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "tool_result" &amp;&amp; block.ToolResult != nil </span><span class="cov0" title="0">{
                                if block.ToolResult.Status == "error" || block.ToolResult.Error != "" </span><span class="cov0" title="0">{
                                        turn := turnIndex[entry.UUID]
                                        errorTurns[turn] = true
                                }</span>
                        }
                }
        }

        // Count from the last turn backwards
        <span class="cov0" title="0">maxTurn := len(turnIndex)
        errorFreeTurns := 0

        for turn := maxTurn; turn &gt;= 1; turn-- </span><span class="cov0" title="0">{
                if errorTurns[turn] </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">errorFreeTurns++</span>
        }

        <span class="cov0" title="0">return errorFreeTurns</span>
}

// determineCurrentFocus determines the current focus area
func determineCurrentFocus(entries []parser.SessionEntry, turnIndex map[string]int) string <span class="cov0" title="0">{
        // Analyze last 5 user messages to determine focus
        userMessages := []string{}

        for i := len(entries) - 1; i &gt;= 0 &amp;&amp; len(userMessages) &lt; 5; i-- </span><span class="cov0" title="0">{
                entry := entries[i]
                if entry.Type != "user" || entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var content string
                for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "text" </span><span class="cov0" title="0">{
                                content += block.Text
                        }</span>
                }

                <span class="cov0" title="0">if content != "" </span><span class="cov0" title="0">{
                        userMessages = append(userMessages, content)
                }</span>
        }

        // Look for common themes
        <span class="cov0" title="0">allText := strings.Join(userMessages, " ")
        allText = strings.ToLower(allText)

        themes := map[string][]string{
                "Testing":        {"test", "测试", "unit test", "e2e"},
                "Implementation": {"implement", "实现", "添加", "add", "create"},
                "Bug fixing":     {"fix", "修复", "bug", "error", "问题"},
                "Documentation":  {"doc", "文档", "readme", "comment"},
                "Refactoring":    {"refactor", "重构", "optimize", "优化"},
                "Phase":          {"phase", "stage", "阶段"},
        }

        for theme, keywords := range themes </span><span class="cov0" title="0">{
                for _, keyword := range keywords </span><span class="cov0" title="0">{
                        if strings.Contains(allText, keyword) </span><span class="cov0" title="0">{
                                return theme
                        }</span>
                }
        }

        <span class="cov0" title="0">return "General development"</span>
}

// extractRecentAchievements extracts recent achievements from assistant messages
func extractRecentAchievements(entries []parser.SessionEntry, turnIndex map[string]int) []string <span class="cov0" title="0">{
        var achievements []string

        // Look for completion patterns in last 10 assistant messages
        achievementPatterns := []*regexp.Regexp{
                regexp.MustCompile(`(?i)(?:completed|完成|finished).*?Stage\s+\d+\.\d+`),
                regexp.MustCompile(`(?i)all tests (?:pass|passed|passing|通过)`),
                regexp.MustCompile(`(?i)successfully (?:implemented|created|added)`),
                regexp.MustCompile(`(?i)(?:实现|添加|完成)了.*`),
        }

        assistantMsgs := 0
        for i := len(entries) - 1; i &gt;= 0 &amp;&amp; assistantMsgs &lt; 10; i-- </span><span class="cov0" title="0">{
                entry := entries[i]
                if entry.Type != "assistant" || entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">assistantMsgs++

                var content string
                for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "text" </span><span class="cov0" title="0">{
                                content += block.Text
                        }</span>
                }

                <span class="cov0" title="0">for _, pattern := range achievementPatterns </span><span class="cov0" title="0">{
                        if match := pattern.FindString(content); match != "" </span><span class="cov0" title="0">{
                                // Clean up and add
                                achievement := strings.TrimSpace(match)
                                if len(achievement) &gt; 100 </span><span class="cov0" title="0">{
                                        achievement = achievement[:100] + "..."
                                }</span>
                                <span class="cov0" title="0">achievements = append(achievements, achievement)
                                break</span> // One achievement per message
                        }
                }
        }

        // Limit to top 5
        <span class="cov0" title="0">if len(achievements) &gt; 5 </span><span class="cov0" title="0">{
                achievements = achievements[:5]
        }</span>

        <span class="cov0" title="0">return achievements</span>
}

// Helper functions
func contains(slice []string, str string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == str </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func atoi(s string) int <span class="cov0" title="0">{
        var result int
        fmt.Sscanf(s, "%d", &amp;result)
        return result
}</span>

func extractTaskTitle(content string) string <span class="cov0" title="0">{
        // Extract first line or first 100 chars as title
        lines := strings.Split(content, "\n")
        title := lines[0]
        if len(title) &gt; 100 </span><span class="cov0" title="0">{
                title = title[:100] + "..."
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(title)</span>
}

func deduplicateTasks(tasks []IncompleteTask) []IncompleteTask <span class="cov0" title="0">{
        seen := make(map[string]bool)
        var result []IncompleteTask

        for _, task := range tasks </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%d-%s-%s", task.Phase, task.Stage, task.Title)
                if !seen[key] </span><span class="cov0" title="0">{
                        seen[key] = true
                        result = append(result, task)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func outputProjectStateMarkdown(cmd *cobra.Command, state *ProjectState) error <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("# Project State\n\n")
        sb.WriteString(fmt.Sprintf("**Session ID**: %s\n\n", state.SessionID))

        // Recent files
        sb.WriteString("## Recent Files\n\n")
        if len(state.RecentFiles) == 0 </span><span class="cov0" title="0">{
                sb.WriteString("No recent file activity.\n\n")
        }</span> else<span class="cov0" title="0"> {
                sb.WriteString("| File | Last Modified Turn | Operations | Edit Count |\n")
                sb.WriteString("|------|-------------------|------------|------------|\n")
                for _, file := range state.RecentFiles </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("| %s | %d | %s | %d |\n",
                                file.Path, file.LastModifiedTurn, strings.Join(file.Operations, ", "), file.EditCount))
                }</span>
                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        // Incomplete stages
        <span class="cov0" title="0">if len(state.IncompleteStages) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Incomplete Stages/Tasks\n\n")
                sb.WriteString("| Phase | Stage | Title | Mentioned in Turn |\n")
                sb.WriteString("|-------|-------|-------|-------------------|\n")
                for _, task := range state.IncompleteStages </span><span class="cov0" title="0">{
                        phase := ""
                        if task.Phase &gt; 0 </span><span class="cov0" title="0">{
                                phase = fmt.Sprintf("%d", task.Phase)
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("| %s | %s | %s | %d |\n",
                                phase, task.Stage, task.Title, task.MentionedInTurn))</span>
                }
                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        // Session quality
        <span class="cov0" title="0">sb.WriteString("## Session Quality\n\n")
        sb.WriteString(fmt.Sprintf("- **Error-Free Turns**: %d\n", state.LastErrorFreeTurns))
        sb.WriteString(fmt.Sprintf("- **Current Focus**: %s\n\n", state.CurrentFocus))

        // Recent achievements
        if len(state.RecentAchievements) &gt; 0 </span><span class="cov0" title="0">{
                sb.WriteString("## Recent Achievements\n\n")
                for _, achievement := range state.RecentAchievements </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("- %s\n", achievement))
                }</span>
        }

        <span class="cov0" title="0">fmt.Fprint(cmd.OutOrStdout(), sb.String())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/parser"
        "github.com/yale/meta-cc/internal/query"
)

var (
        sequencesMinOccur    int
        sequencesPattern     string
        sequencesSuccessOnly bool
        sequencesWithMetrics bool
)

// querySequencesCmd represents the tool-sequences query command
var querySequencesCmd = &amp;cobra.Command{
        Use:   "tool-sequences",
        Short: "Query repeated tool call sequences",
        Long: `Query repeated tool call sequences in Claude Code session history.

This command detects repeated patterns of tool calls, such as:
- Read → Edit → Bash (test cycle)
- Grep → Read → Read (exploration pattern)

Results include occurrence count, turn numbers, and time span.

Example:
  meta-cc query tool-sequences --min-occurrences 3
  meta-cc query tool-sequences --pattern "Read -&gt; Edit -&gt; Bash"
  meta-cc query tool-sequences --min-occurrences 2 --output md`,
        RunE: runQuerySequences,
}

func init() <span class="cov8" title="1">{
        querySequencesCmd.Flags().IntVar(&amp;sequencesMinOccur, "min-occurrences", 3, "Minimum occurrences to report")
        querySequencesCmd.Flags().StringVar(&amp;sequencesPattern, "pattern", "", "Specific sequence pattern to match (e.g., 'Read -&gt; Edit -&gt; Bash')")
        querySequencesCmd.Flags().BoolVar(&amp;sequencesSuccessOnly, "successful-only", false, "Only show sequences with no errors")
        querySequencesCmd.Flags().BoolVar(&amp;sequencesWithMetrics, "with-metrics", false, "Include success rate and duration metrics")

        queryCmd.AddCommand(querySequencesCmd)
}</span>

func runQuerySequences(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Apply time filter
        <span class="cov0" title="0">entries := p.GetEntries()
        entries, err := applyTimeFilter(entries)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply time filter: %w", err)
        }</span>

        // Build tool sequence query
        <span class="cov0" title="0">result, err := query.BuildToolSequenceQuery(entries, sequencesMinOccur, sequencesPattern)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build tool sequence query: %w", err)
        }</span>

        // Apply filters and enhancements
        <span class="cov0" title="0">if sequencesSuccessOnly </span><span class="cov0" title="0">{
                result = filterSuccessfulSequences(result, entries)
        }</span>

        <span class="cov0" title="0">if sequencesWithMetrics </span><span class="cov0" title="0">{
                result = addSequenceMetrics(result, entries)
        }</span>

        // Output result
        <span class="cov0" title="0">if outputFormat == "md" </span><span class="cov0" title="0">{
                return outputSequencesMarkdown(cmd, result)
        }</span>

        // JSON output (default)
        <span class="cov0" title="0">encoder := json.NewEncoder(cmd.OutOrStdout())
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)</span>
}

func outputSequencesMarkdown(cmd *cobra.Command, result *query.ToolSequenceQuery) error <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("# Tool Sequence Patterns\n\n")
        sb.WriteString(fmt.Sprintf("**Patterns Found**: %d\n\n", len(result.Sequences)))

        for i, seq := range result.Sequences </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("## Pattern %d: %s\n\n", i+1, seq.Pattern))
                sb.WriteString(fmt.Sprintf("**Occurrences**: %d\n\n", seq.Count))
                sb.WriteString(fmt.Sprintf("**Time Span**: %d minutes\n\n", seq.TimeSpanMin))

                // Add metrics if available
                if seq.SuccessRate &gt;= 0 </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("**Success Rate**: %.1f%%\n\n", seq.SuccessRate*100))
                }</span>
                <span class="cov0" title="0">if seq.AvgDurationMin &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("**Avg Duration**: %.1f minutes\n\n", seq.AvgDurationMin))
                }</span>
                <span class="cov0" title="0">if seq.Context != "" </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("**Context**: %s\n\n", seq.Context))
                }</span>

                <span class="cov0" title="0">if len(seq.Occurrences) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString("### Occurrence Locations\n\n")
                        sb.WriteString("| # | Start Turn | End Turn |\n")
                        sb.WriteString("|---|------------|----------|\n")
                        for j, occ := range seq.Occurrences </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("| %d | %d | %d |\n",
                                        j+1, occ.StartTurn, occ.EndTurn))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }
        }

        <span class="cov0" title="0">fmt.Fprint(cmd.OutOrStdout(), sb.String())
        return nil</span>
}

// filterSuccessfulSequences filters sequences to only include those with no errors
func filterSuccessfulSequences(result *query.ToolSequenceQuery, entries []parser.SessionEntry) *query.ToolSequenceQuery <span class="cov0" title="0">{
        // Build error turn map
        errorTurns := make(map[int]bool)
        turnIndex := buildTurnIndexFromEntries(entries)

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "tool_result" &amp;&amp; block.ToolResult != nil </span><span class="cov0" title="0">{
                                if block.ToolResult.Status == "error" || block.ToolResult.Error != "" </span><span class="cov0" title="0">{
                                        turn := turnIndex[entry.UUID]
                                        errorTurns[turn] = true
                                }</span>
                        }
                }
        }

        // Filter sequences
        <span class="cov0" title="0">var filtered []query.SequencePattern
        for _, seq := range result.Sequences </span><span class="cov0" title="0">{
                hasError := false
                for _, occ := range seq.Occurrences </span><span class="cov0" title="0">{
                        for turn := occ.StartTurn; turn &lt;= occ.EndTurn; turn++ </span><span class="cov0" title="0">{
                                if errorTurns[turn] </span><span class="cov0" title="0">{
                                        hasError = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasError </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasError </span><span class="cov0" title="0">{
                        filtered = append(filtered, seq)
                }</span>
        }

        <span class="cov0" title="0">return &amp;query.ToolSequenceQuery{
                Sequences: filtered,
        }</span>
}

// addSequenceMetrics adds success rate and duration metrics to sequences
func addSequenceMetrics(result *query.ToolSequenceQuery, entries []parser.SessionEntry) *query.ToolSequenceQuery <span class="cov0" title="0">{
        // Build error turn map and timestamp map
        errorTurns := make(map[int]bool)
        turnTimestamps := make(map[int]int64)
        turnIndex := buildTurnIndexFromEntries(entries)

        for _, entry := range entries </span><span class="cov0" title="0">{
                turn := turnIndex[entry.UUID]

                // Parse timestamp
                var ts int64
                fmt.Sscanf(entry.Timestamp, "%d", &amp;ts)
                turnTimestamps[turn] = ts

                if entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "tool_result" &amp;&amp; block.ToolResult != nil </span><span class="cov0" title="0">{
                                if block.ToolResult.Status == "error" || block.ToolResult.Error != "" </span><span class="cov0" title="0">{
                                        errorTurns[turn] = true
                                }</span>
                        }
                }
        }

        // Calculate metrics for each sequence
        <span class="cov0" title="0">for i := range result.Sequences </span><span class="cov0" title="0">{
                seq := &amp;result.Sequences[i]

                successCount := 0
                totalDuration := 0.0

                for _, occ := range seq.Occurrences </span><span class="cov0" title="0">{
                        // Check if successful
                        hasError := false
                        for turn := occ.StartTurn; turn &lt;= occ.EndTurn; turn++ </span><span class="cov0" title="0">{
                                if errorTurns[turn] </span><span class="cov0" title="0">{
                                        hasError = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !hasError </span><span class="cov0" title="0">{
                                successCount++
                        }</span>

                        // Calculate duration
                        <span class="cov0" title="0">startTs := turnTimestamps[occ.StartTurn]
                        endTs := turnTimestamps[occ.EndTurn]
                        if startTs &gt; 0 &amp;&amp; endTs &gt; 0 </span><span class="cov0" title="0">{
                                duration := float64(endTs-startTs) / 60.0 // convert to minutes
                                totalDuration += duration
                        }</span>
                }

                // Calculate success rate
                <span class="cov0" title="0">if len(seq.Occurrences) &gt; 0 </span><span class="cov0" title="0">{
                        seq.SuccessRate = float64(successCount) / float64(len(seq.Occurrences))
                }</span>

                // Calculate average duration
                <span class="cov0" title="0">if len(seq.Occurrences) &gt; 0 </span><span class="cov0" title="0">{
                        seq.AvgDurationMin = totalDuration / float64(len(seq.Occurrences))
                }</span>

                // Determine context based on pattern
                <span class="cov0" title="0">seq.Context = determineSequenceContext(seq.Pattern)</span>
        }

        <span class="cov0" title="0">return result</span>
}

// buildTurnIndexFromEntries builds a turn index from entries
func buildTurnIndexFromEntries(entries []parser.SessionEntry) map[string]int <span class="cov0" title="0">{
        turnIndex := make(map[string]int)
        turn := 0

        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsMessage() </span><span class="cov0" title="0">{
                        turn++
                        turnIndex[entry.UUID] = turn
                }</span>
        }

        <span class="cov0" title="0">return turnIndex</span>
}

// determineSequenceContext determines the likely context/purpose of a sequence
func determineSequenceContext(pattern string) string <span class="cov0" title="0">{
        lower := strings.ToLower(pattern)

        contexts := map[string][]string{
                "代码修改工作流":  {"read", "grep", "edit"},
                "测试驱动开发循环": {"bash", "read", "edit", "bash"},
                "文件创建和验证":  {"write", "read"},
                "探索性代码阅读":  {"grep", "read", "read"},
                "调试和错误修复":  {"bash", "read", "edit"},
        }

        for context, keywords := range contexts </span><span class="cov0" title="0">{
                matchCount := 0
                for _, keyword := range keywords </span><span class="cov0" title="0">{
                        if strings.Contains(lower, keyword) </span><span class="cov0" title="0">{
                                matchCount++
                        }</span>
                }
                // If most keywords match, return this context
                <span class="cov0" title="0">if matchCount &gt;= len(keywords)-1 </span><span class="cov0" title="0">{
                        return context
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/parser"
)

var (
        successfulPromptsMinQuality float64
)

// querySuccessfulPromptsCmd represents the successful-prompts query command
var querySuccessfulPromptsCmd = &amp;cobra.Command{
        Use:   "successful-prompts",
        Short: "Query successful prompt patterns",
        Long: `Query successful prompt patterns from session history.

This command identifies user prompts that led to successful outcomes, based on:
- Fast completion (few turns)
- No errors during execution
- Clear deliverables
- User confirmation

Example:
  meta-cc query successful-prompts --limit 10 --output json
  meta-cc query successful-prompts --min-quality-score 0.8 --output md`,
        RunE: runQuerySuccessfulPrompts,
}

func init() <span class="cov8" title="1">{
        querySuccessfulPromptsCmd.Flags().Float64Var(&amp;successfulPromptsMinQuality, "min-quality-score", 0.0, "Minimum quality score (0.0-1.0)")

        queryCmd.AddCommand(querySuccessfulPromptsCmd)
}</span>

func runQuerySuccessfulPrompts(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Build successful prompts result
        <span class="cov0" title="0">entries := p.GetEntries()
        result, err := buildSuccessfulPrompts(entries, successfulPromptsMinQuality, queryLimit)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to build successful prompts: %w", err)
        }</span>

        // Output result
        <span class="cov0" title="0">if outputFormat == "md" </span><span class="cov0" title="0">{
                return outputSuccessfulPromptsMarkdown(cmd, result)
        }</span>

        // JSON output (default)
        <span class="cov0" title="0">encoder := json.NewEncoder(cmd.OutOrStdout())
        encoder.SetIndent("", "  ")
        return encoder.Encode(result)</span>
}

// SuccessfulPromptsResult represents successful prompts query result
type SuccessfulPromptsResult struct {
        Prompts []SuccessfulPrompt `json:"prompts"`
}

// SuccessfulPrompt represents a successful prompt with metadata
type SuccessfulPrompt struct {
        TurnSequence    int             `json:"turn_sequence"`
        UserPrompt      string          `json:"user_prompt"`
        Context         PromptContext   `json:"context"`
        Outcome         PromptOutcome   `json:"outcome"`
        QualityScore    float64         `json:"quality_score"`
        PatternFeatures PatternFeatures `json:"pattern_features"`
}

// PromptContext represents the context when prompt was given
type PromptContext struct {
        Phase    string `json:"phase,omitempty"`
        TaskType string `json:"task_type,omitempty"`
}

// PromptOutcome represents the outcome of the prompt
type PromptOutcome struct {
        Status          string   `json:"status"`
        TurnsToComplete int      `json:"turns_to_complete"`
        ErrorCount      int      `json:"error_count"`
        Deliverables    []string `json:"deliverables,omitempty"`
}

// PatternFeatures represents structural features of the prompt
type PatternFeatures struct {
        HasClearGoal          bool `json:"has_clear_goal"`
        HasConstraints        bool `json:"has_constraints"`
        HasAcceptanceCriteria bool `json:"has_acceptance_criteria"`
        HasContext            bool `json:"has_context"`
}

func buildSuccessfulPrompts(entries []parser.SessionEntry, minQuality float64, limit int) (*SuccessfulPromptsResult, error) <span class="cov0" title="0">{
        // Build turn index
        turnIndex := buildTurnIndex(entries)

        // Extract user prompts
        var prompts []SuccessfulPrompt

        for i, entry := range entries </span><span class="cov0" title="0">{
                if entry.Type != "user" || entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract user prompt content
                <span class="cov0" title="0">var promptText string
                for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                        if block.Type == "text" </span><span class="cov0" title="0">{
                                promptText += block.Text
                        }</span>
                }

                <span class="cov0" title="0">if promptText == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">turn := turnIndex[entry.UUID]

                // Analyze the outcome of this prompt
                outcome, _ := analyzePromptOutcome(entries, i, turnIndex)

                // Calculate quality score
                qualityScore := calculateQualityScore(outcome, promptText)

                // Skip if below minimum quality
                if qualityScore &lt; minQuality </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Extract context
                <span class="cov0" title="0">context := extractPromptContext(promptText)

                // Extract pattern features
                features := extractPatternFeatures(promptText)

                prompts = append(prompts, SuccessfulPrompt{
                        TurnSequence:    turn,
                        UserPrompt:      promptText,
                        Context:         context,
                        Outcome:         outcome,
                        QualityScore:    qualityScore,
                        PatternFeatures: features,
                })</span>
        }

        // Sort by quality score (descending)
        <span class="cov0" title="0">for i := 0; i &lt; len(prompts); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(prompts); j++ </span><span class="cov0" title="0">{
                        if prompts[j].QualityScore &gt; prompts[i].QualityScore </span><span class="cov0" title="0">{
                                prompts[i], prompts[j] = prompts[j], prompts[i]
                        }</span>
                }
        }

        // Apply limit
        <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; len(prompts) &gt; limit </span><span class="cov0" title="0">{
                prompts = prompts[:limit]
        }</span>

        <span class="cov0" title="0">return &amp;SuccessfulPromptsResult{
                Prompts: prompts,
        }, nil</span>
}

// analyzePromptOutcome analyzes the outcome of a user prompt
func analyzePromptOutcome(entries []parser.SessionEntry, userEntryIdx int, turnIndex map[string]int) (PromptOutcome, int) <span class="cov0" title="0">{
        outcome := PromptOutcome{
                Status:       "unknown",
                ErrorCount:   0,
                Deliverables: []string{},
        }

        startTurn := turnIndex[entries[userEntryIdx].UUID]
        endTurn := startTurn

        // Look ahead for assistant responses and next user message
        for i := userEntryIdx + 1; i &lt; len(entries); i++ </span><span class="cov0" title="0">{
                entry := entries[i]

                // Stop at next user message
                if entry.Type == "user" </span><span class="cov0" title="0">{
                        endTurn = turnIndex[entry.UUID] - 1

                        // Check if user confirmed success
                        if entry.Message != nil </span><span class="cov0" title="0">{
                                var content string
                                for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                                        if block.Type == "text" </span><span class="cov0" title="0">{
                                                content += block.Text
                                        }</span>
                                }

                                <span class="cov0" title="0">content = strings.ToLower(content)
                                if containsAny(content, []string{"good", "great", "perfect", "thanks", "好的", "很好", "完成", "通过"}) </span><span class="cov0" title="0">{
                                        outcome.Status = "success"
                                }</span>
                        }
                        <span class="cov0" title="0">break</span>
                }

                // Count errors
                <span class="cov0" title="0">if entry.Message != nil </span><span class="cov0" title="0">{
                        for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                                if block.Type == "tool_result" &amp;&amp; block.ToolResult != nil </span><span class="cov0" title="0">{
                                        if block.ToolResult.Status == "error" || block.ToolResult.Error != "" </span><span class="cov0" title="0">{
                                                outcome.ErrorCount++
                                        }</span>
                                }
                        }
                }

                // Extract deliverables (files created/modified)
                <span class="cov0" title="0">if entry.Message != nil </span><span class="cov0" title="0">{
                        for _, block := range entry.Message.Content </span><span class="cov0" title="0">{
                                if block.Type == "tool_use" &amp;&amp; block.ToolUse != nil </span><span class="cov0" title="0">{
                                        if block.ToolUse.Name == "Write" || block.ToolUse.Name == "Edit" </span><span class="cov0" title="0">{
                                                if filePath, ok := block.ToolUse.Input["file_path"].(string); ok </span><span class="cov0" title="0">{
                                                        if !contains(outcome.Deliverables, filePath) </span><span class="cov0" title="0">{
                                                                outcome.Deliverables = append(outcome.Deliverables, filePath)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">endTurn = turnIndex[entry.UUID]</span>
        }

        // Calculate turns to complete
        <span class="cov0" title="0">outcome.TurnsToComplete = endTurn - startTurn + 1

        // Determine status if not already set
        if outcome.Status == "unknown" </span><span class="cov0" title="0">{
                if outcome.ErrorCount == 0 &amp;&amp; len(outcome.Deliverables) &gt; 0 </span><span class="cov0" title="0">{
                        outcome.Status = "success"
                }</span> else<span class="cov0" title="0"> if outcome.ErrorCount &gt; 0 </span><span class="cov0" title="0">{
                        outcome.Status = "partial"
                }</span>
        }

        <span class="cov0" title="0">return outcome, endTurn</span>
}

// calculateQualityScore calculates quality score for a prompt
func calculateQualityScore(outcome PromptOutcome, promptText string) float64 <span class="cov0" title="0">{
        score := 0.0

        // Error rate component (40%)
        if outcome.ErrorCount == 0 </span><span class="cov0" title="0">{
                score += 0.4
        }</span> else<span class="cov0" title="0"> {
                errorRate := float64(outcome.ErrorCount) / float64(outcome.TurnsToComplete)
                score += 0.4 * (1.0 - min(errorRate, 1.0))
        }</span>

        // Speed component (30%)
        <span class="cov0" title="0">if outcome.TurnsToComplete &lt;= 3 </span><span class="cov0" title="0">{
                score += 0.3
        }</span> else<span class="cov0" title="0"> if outcome.TurnsToComplete &lt;= 5 </span><span class="cov0" title="0">{
                score += 0.2
        }</span> else<span class="cov0" title="0"> if outcome.TurnsToComplete &lt;= 10 </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        // Deliverable component (20%)
        <span class="cov0" title="0">if len(outcome.Deliverables) &gt; 0 </span><span class="cov0" title="0">{
                score += 0.2
        }</span>

        // Confirmation component (10%)
        <span class="cov0" title="0">if outcome.Status == "success" </span><span class="cov0" title="0">{
                score += 0.1
        }</span>

        <span class="cov0" title="0">return score</span>
}

// extractPromptContext extracts context from prompt text
func extractPromptContext(promptText string) PromptContext <span class="cov0" title="0">{
        context := PromptContext{}

        lower := strings.ToLower(promptText)

        // Detect phase
        if strings.Contains(lower, "phase") || strings.Contains(lower, "阶段") </span><span class="cov0" title="0">{
                context.Phase = "Phase-based development"
        }</span> else<span class="cov0" title="0"> if strings.Contains(lower, "stage") </span><span class="cov0" title="0">{
                context.Phase = "Stage-based development"
        }</span>

        // Detect task type
        <span class="cov0" title="0">taskTypes := map[string][]string{
                "implementation": {"implement", "实现", "添加", "add", "create"},
                "bug_fix":        {"fix", "修复", "bug", "error"},
                "testing":        {"test", "测试", "验证"},
                "refactoring":    {"refactor", "重构", "optimize", "优化"},
                "documentation":  {"doc", "文档", "comment"},
        }

        for taskType, keywords := range taskTypes </span><span class="cov0" title="0">{
                for _, keyword := range keywords </span><span class="cov0" title="0">{
                        if strings.Contains(lower, keyword) </span><span class="cov0" title="0">{
                                context.TaskType = taskType
                                break</span>
                        }
                }
                <span class="cov0" title="0">if context.TaskType != "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">return context</span>
}

// extractPatternFeatures extracts structural features from prompt
func extractPatternFeatures(promptText string) PatternFeatures <span class="cov0" title="0">{
        features := PatternFeatures{}

        lower := strings.ToLower(promptText)

        // Has clear goal (action verbs)
        actionVerbs := []string{"implement", "add", "fix", "create", "update", "实现", "添加", "修复", "创建"}
        for _, verb := range actionVerbs </span><span class="cov0" title="0">{
                if strings.Contains(lower, verb) </span><span class="cov0" title="0">{
                        features.HasClearGoal = true
                        break</span>
                }
        }

        // Has constraints (mentions limits, requirements)
        <span class="cov0" title="0">constraintKeywords := []string{"constraint", "limit", "requirement", "must", "should", "约束", "限制", "要求"}
        for _, keyword := range constraintKeywords </span><span class="cov0" title="0">{
                if strings.Contains(lower, keyword) </span><span class="cov0" title="0">{
                        features.HasConstraints = true
                        break</span>
                }
        }

        // Has acceptance criteria (mentions tests, verification)
        <span class="cov0" title="0">criteriaKeywords := []string{"test", "verify", "ensure", "validate", "测试", "验证", "确保"}
        for _, keyword := range criteriaKeywords </span><span class="cov0" title="0">{
                if strings.Contains(lower, keyword) </span><span class="cov0" title="0">{
                        features.HasAcceptanceCriteria = true
                        break</span>
                }
        }

        // Has context (mentions phase, stage, background)
        <span class="cov0" title="0">contextKeywords := []string{"phase", "stage", "context", "background", "阶段", "背景", "上下文"}
        for _, keyword := range contextKeywords </span><span class="cov0" title="0">{
                if strings.Contains(lower, keyword) </span><span class="cov0" title="0">{
                        features.HasContext = true
                        break</span>
                }
        }

        <span class="cov0" title="0">return features</span>
}

// Helper functions
func containsAny(text string, keywords []string) bool <span class="cov0" title="0">{
        for _, keyword := range keywords </span><span class="cov0" title="0">{
                if strings.Contains(text, keyword) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func min(a, b float64) float64 <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func outputSuccessfulPromptsMarkdown(cmd *cobra.Command, result *SuccessfulPromptsResult) error <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString("# Successful Prompt Patterns\n\n")
        sb.WriteString(fmt.Sprintf("**Total Prompts**: %d\n\n", len(result.Prompts)))

        for i, prompt := range result.Prompts </span><span class="cov0" title="0">{
                sb.WriteString(fmt.Sprintf("## Prompt %d (Turn %d, Quality: %.2f)\n\n", i+1, prompt.TurnSequence, prompt.QualityScore))

                // Prompt text
                sb.WriteString("### User Prompt\n\n")
                sb.WriteString(fmt.Sprintf("&gt; %s\n\n", strings.ReplaceAll(prompt.UserPrompt, "\n", "\n&gt; ")))

                // Context
                if prompt.Context.Phase != "" || prompt.Context.TaskType != "" </span><span class="cov0" title="0">{
                        sb.WriteString("### Context\n\n")
                        if prompt.Context.Phase != "" </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("- **Phase**: %s\n", prompt.Context.Phase))
                        }</span>
                        <span class="cov0" title="0">if prompt.Context.TaskType != "" </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("- **Task Type**: %s\n", prompt.Context.TaskType))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }

                // Outcome
                <span class="cov0" title="0">sb.WriteString("### Outcome\n\n")
                sb.WriteString(fmt.Sprintf("- **Status**: %s\n", prompt.Outcome.Status))
                sb.WriteString(fmt.Sprintf("- **Turns to Complete**: %d\n", prompt.Outcome.TurnsToComplete))
                sb.WriteString(fmt.Sprintf("- **Error Count**: %d\n", prompt.Outcome.ErrorCount))
                if len(prompt.Outcome.Deliverables) &gt; 0 </span><span class="cov0" title="0">{
                        sb.WriteString(fmt.Sprintf("- **Deliverables**: %s\n", strings.Join(prompt.Outcome.Deliverables, ", ")))
                }</span>
                <span class="cov0" title="0">sb.WriteString("\n")

                // Pattern features
                sb.WriteString("### Pattern Features\n\n")
                sb.WriteString(fmt.Sprintf("- Clear Goal: %v\n", prompt.PatternFeatures.HasClearGoal))
                sb.WriteString(fmt.Sprintf("- Constraints: %v\n", prompt.PatternFeatures.HasConstraints))
                sb.WriteString(fmt.Sprintf("- Acceptance Criteria: %v\n", prompt.PatternFeatures.HasAcceptanceCriteria))
                sb.WriteString(fmt.Sprintf("- Context: %v\n\n", prompt.PatternFeatures.HasContext))

                sb.WriteString("---\n\n")</span>
        }

        <span class="cov0" title="0">fmt.Fprint(cmd.OutOrStdout(), sb.String())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package cmd

import (
        "fmt"
        "path/filepath"
        "sort"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/filter"
        internalOutput "github.com/yale/meta-cc/internal/output"
        "github.com/yale/meta-cc/internal/parser"
        "github.com/yale/meta-cc/pkg/output"
)

var (
        queryToolsStatus string
        queryToolsTool   string
        queryToolsWhere  string
        queryToolsFilter string
)

var queryToolsCmd = &amp;cobra.Command{
        Use:   "tools",
        Short: "Query tool calls",
        Long: `Query tool calls with advanced filtering options.

Supports filtering by:
  - Tool name (--tool)
  - Status (--status: success|error)
  - General condition (--where: "field=value")
  - Advanced expressions (--filter: SQL-like syntax)

Examples:
  meta-cc query tools --status error
  meta-cc query tools --tool Bash --limit 20
  meta-cc query tools --where "status=error" --sort-by timestamp
  meta-cc query tools --filter "tool='Bash' AND status='error'"
  meta-cc query tools --filter "tool IN ('Bash', 'Edit') OR duration&gt;1000"`,
        RunE: runQueryTools,
}

func init() <span class="cov8" title="1">{
        queryCmd.AddCommand(queryToolsCmd)

        // Tool-specific filters
        queryToolsCmd.Flags().StringVar(&amp;queryToolsStatus, "status", "", "Filter by status (success|error)")
        queryToolsCmd.Flags().StringVar(&amp;queryToolsTool, "tool", "", "Filter by tool name")
        queryToolsCmd.Flags().StringVar(&amp;queryToolsWhere, "where", "", "Filter condition (key=value)")
        queryToolsCmd.Flags().StringVar(&amp;queryToolsFilter, "filter", "", "Advanced filter expression (SQL-like)")
}</span>

func runQueryTools(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return internalOutput.OutputError(err, internalOutput.ErrSessionNotFound, outputFormat)
        }</span>

        // Step 2: Extract tool calls using pipeline
        <span class="cov0" title="0">toolCalls := p.ExtractToolCalls()

        // Step 3: Apply filters
        filtered, err := applyToolFilters(toolCalls)
        if err != nil </span><span class="cov0" title="0">{
                return internalOutput.OutputError(err, internalOutput.ErrFilterError, outputFormat)
        }</span>

        // Step 4: Apply default deterministic sorting (by timestamp)
        // This ensures same query always produces same output order
        <span class="cov0" title="0">output.SortByTimestamp(filtered)

        // Step 4b: Apply custom sort if requested (overrides default)
        if querySortBy != "" </span><span class="cov0" title="0">{
                sortToolCalls(filtered, querySortBy, queryReverse)
        }</span>

        // Step 5: Handle --estimate-size flag
        <span class="cov0" title="0">if estimateSizeFlag </span><span class="cov0" title="0">{
                estimate, err := output.EstimateToolCallsSize(filtered, outputFormat)
                if err != nil </span><span class="cov0" title="0">{
                        return internalOutput.OutputError(err, internalOutput.ErrInternalError, outputFormat)
                }</span>

                // Output estimate as JSONL
                <span class="cov0" title="0">estimateStr, _ := output.FormatJSONL(estimate)
                fmt.Fprintln(cmd.OutOrStdout(), estimateStr)
                return nil</span>
        }

        // Step 6: Apply pagination using new filter package
        // Use global flags (limitFlag, offsetFlag) if set, otherwise fall back to queryLimit/queryOffset
        <span class="cov0" title="0">limit := limitFlag
        offset := offsetFlag
        if limit == 0 &amp;&amp; queryLimit &gt; 0 </span><span class="cov0" title="0">{
                limit = queryLimit
        }</span>
        <span class="cov0" title="0">if offset == 0 &amp;&amp; queryOffset &gt; 0 </span><span class="cov0" title="0">{
                offset = queryOffset
        }</span>

        <span class="cov0" title="0">paginationConfig := filter.PaginationConfig{
                Limit:  limit,
                Offset: offset,
        }
        paginated := filter.ApplyPagination(filtered, paginationConfig)

        // Step 7: Handle chunking mode
        if chunkSizeFlag &gt; 0 </span><span class="cov0" title="0">{
                // Validate output directory is specified
                if outputDirFlag == "" </span><span class="cov0" title="0">{
                        return internalOutput.OutputError(
                                fmt.Errorf("--output-dir is required when using --chunk-size"),
                                internalOutput.ErrInvalidArgument,
                                outputFormat,
                        )
                }</span>

                // Create chunks
                <span class="cov0" title="0">metadata, err := output.ChunkToolCalls(paginated, chunkSizeFlag, outputDirFlag, outputFormat)
                if err != nil </span><span class="cov0" title="0">{
                        return internalOutput.OutputError(err, internalOutput.ErrInternalError, outputFormat)
                }</span>

                // Output chunk summary to stderr (not stdout)
                <span class="cov0" title="0">fmt.Fprintf(cmd.ErrOrStderr(), "Generated %d chunk(s)\n", len(metadata))
                for _, meta := range metadata </span><span class="cov0" title="0">{
                        fmt.Fprintf(cmd.ErrOrStderr(), "  Chunk %d: %s (%d records, %d bytes)\n",
                                meta.Index, filepath.Base(meta.File), meta.Records, meta.SizeBytes)
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(cmd.ErrOrStderr(), "Manifest: %s\n", filepath.Join(outputDirFlag, "manifest.json"))

                return nil</span>
        }

        // Step 8: Handle summary-first mode
        <span class="cov0" title="0">if summaryFirstFlag </span><span class="cov0" title="0">{
                summaryOutput, err := output.FormatSummaryFirst(paginated, topNFlag, outputFormat)
                if err != nil </span><span class="cov0" title="0">{
                        return internalOutput.OutputError(err, internalOutput.ErrInternalError, outputFormat)
                }</span>

                // Check for empty results first
                <span class="cov0" title="0">if len(paginated) == 0 </span><span class="cov0" title="0">{
                        return internalOutput.WarnNoResults(outputFormat)
                }</span>

                // Print summary followed by details
                <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), summaryOutput.Summary)
                fmt.Fprintln(cmd.OutOrStdout(), summaryOutput.Details)

                return nil</span>
        }

        // Step 9: Handle streaming output if requested
        <span class="cov0" title="0">if queryStream </span><span class="cov0" title="0">{
                // Check for empty results first
                if len(paginated) == 0 </span><span class="cov0" title="0">{
                        return internalOutput.WarnNoResults(outputFormat)
                }</span>

                <span class="cov0" title="0">streamWriter := output.NewStreamWriter(cmd.OutOrStdout())
                for _, tool := range paginated </span><span class="cov0" title="0">{
                        if err := streamWriter.WriteRecord(tool); err != nil </span><span class="cov0" title="0">{
                                return internalOutput.OutputError(err, internalOutput.ErrInternalError, outputFormat)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        // Step 10: Apply field projection if requested
        <span class="cov0" title="0">projectionConfig := output.ParseProjectionConfig(fieldsFlag, ifErrorIncludeFlag)

        // If projection is requested, project the fields
        if len(projectionConfig.Fields) &gt; 0 </span><span class="cov0" title="0">{
                // Check for empty results first
                if len(paginated) == 0 </span><span class="cov0" title="0">{
                        return internalOutput.WarnNoResults(outputFormat)
                }</span>

                <span class="cov0" title="0">projected, err := output.ProjectToolCalls(paginated, projectionConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return internalOutput.OutputError(err, internalOutput.ErrInternalError, outputFormat)
                }</span>

                // Format projected output
                <span class="cov0" title="0">outputStr, formatErr := output.FormatProjectedOutput(projected, outputFormat)
                if formatErr != nil </span><span class="cov0" title="0">{
                        return internalOutput.OutputError(formatErr, internalOutput.ErrInternalError, outputFormat)
                }</span>

                <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
                return nil</span>
        }

        // Step 11: Format output (non-chunked, non-projected, non-summary mode)
        // Check for empty results first
        <span class="cov0" title="0">if len(paginated) == 0 </span><span class="cov0" title="0">{
                return internalOutput.WarnNoResults(outputFormat)
        }</span>

        <span class="cov0" title="0">outputStr, formatErr := internalOutput.FormatOutput(paginated, outputFormat)
        if formatErr != nil </span><span class="cov0" title="0">{
                return internalOutput.OutputError(formatErr, internalOutput.ErrInternalError, outputFormat)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)
        return nil</span>
}

func applyToolFilters(toolCalls []parser.ToolCall) ([]parser.ToolCall, error) <span class="cov0" title="0">{
        // Apply --filter expression first (most powerful)
        if queryToolsFilter != "" </span><span class="cov0" title="0">{
                expr, err := filter.ParseExpression(queryToolsFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid filter expression: %w", err)
                }</span>

                <span class="cov0" title="0">var filtered []parser.ToolCall
                for _, tc := range toolCalls </span><span class="cov0" title="0">{
                        // Convert ToolCall to map for expression evaluation
                        record := map[string]interface{}{
                                "tool":   tc.ToolName,
                                "status": tc.Status,
                                "uuid":   tc.UUID,
                                "error":  tc.Error,
                        }

                        match, err := expr.Evaluate(record)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("filter evaluation error: %w", err)
                        }</span>

                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                filtered = append(filtered, tc)
                        }</span>
                }
                <span class="cov0" title="0">toolCalls = filtered</span>
        }

        // Apply --where filter (simple key=value pairs)
        <span class="cov0" title="0">if queryToolsWhere != "" </span><span class="cov0" title="0">{
                filtered, err := filter.ApplyWhere(toolCalls, queryToolsWhere, "tool_calls")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid where condition: %w", err)
                }</span>
                <span class="cov0" title="0">toolCalls = filtered.([]parser.ToolCall)</span>
        }

        // Apply individual flag filters (for backwards compatibility)
        <span class="cov0" title="0">var result []parser.ToolCall
        for _, tc := range toolCalls </span><span class="cov0" title="0">{
                // Apply status filter
                if queryToolsStatus != "" </span><span class="cov0" title="0">{
                        if queryToolsStatus == "error" </span><span class="cov0" title="0">{
                                if tc.Status != "error" &amp;&amp; tc.Error == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        } else<span class="cov0" title="0"> if queryToolsStatus == "success" </span><span class="cov0" title="0">{
                                if tc.Status == "error" || tc.Error != "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                        }
                }

                // Apply tool name filter
                <span class="cov0" title="0">if queryToolsTool != "" &amp;&amp; tc.ToolName != queryToolsTool </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If all filters pass, include this tool call
                <span class="cov0" title="0">result = append(result, tc)</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

func sortToolCalls(toolCalls []parser.ToolCall, sortBy string, reverse bool) <span class="cov0" title="0">{
        // Use stable sort to preserve relative order for equal values
        sort.SliceStable(toolCalls, func(i, j int) bool </span><span class="cov0" title="0">{
                var less bool

                switch sortBy </span>{
                case "timestamp":<span class="cov0" title="0">
                        less = toolCalls[i].Timestamp &lt; toolCalls[j].Timestamp</span>
                case "tool":<span class="cov0" title="0">
                        less = toolCalls[i].ToolName &lt; toolCalls[j].ToolName</span>
                case "status":<span class="cov0" title="0">
                        less = toolCalls[i].Status &lt; toolCalls[j].Status</span>
                case "uuid":<span class="cov0" title="0">
                        less = toolCalls[i].UUID &lt; toolCalls[j].UUID</span>
                default:<span class="cov0" title="0">
                        // Default: sort by timestamp (deterministic)
                        less = toolCalls[i].Timestamp &lt; toolCalls[j].Timestamp</span>
                }

                <span class="cov0" title="0">if reverse </span><span class="cov0" title="0">{
                        return !less
                }</span>
                <span class="cov0" title="0">return less</span>
        })
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package cmd

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "github.com/yale/meta-cc/internal/output"
)

var (
        cfgFile      string
        sessionID    string
        projectPath  string
        outputFormat string
        sessionOnly  bool // Phase 13: Force session-only analysis (opt-out of project default)

        // Phase 9.1: Pagination and size estimation flags
        limitFlag        int
        offsetFlag       int
        estimateSizeFlag bool

        // Phase 9.2: Chunking flags
        chunkSizeFlag int
        outputDirFlag string

        // Phase 9.3: Field projection flags
        fieldsFlag         string
        ifErrorIncludeFlag string

        // Phase 9.4: Compact output format flags
        summaryFirstFlag bool
        topNFlag         int
)

// Build information (injected during build via -ldflags)
var (
        Version   = "dev"
        Commit    = "unknown"
        BuildTime = "unknown"
)

var rootCmd = &amp;cobra.Command{
        Use:   "meta-cc",
        Short: "Meta-Cognition tool for Claude Code",
        Long: `meta-cc analyzes Claude Code session history to provide
metacognitive insights and workflow optimization.`,
        SilenceErrors: true, // We handle errors ourselves
        SilenceUsage:  true, // Don't show usage on errors
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                cmd.Help()
        }</span>,
}

func Execute() error <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's an ExitCodeError
                if exitErr, ok := err.(*output.ExitCodeError); ok </span><span class="cov0" title="0">{
                        // ExitCodeError already has the message printed by Cobra
                        // We just need to exit with the appropriate code
                        os.Exit(exitErr.Code)
                }</span>
                // For other errors, Cobra will handle them (exit 1)
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// getGlobalOptions returns GlobalOptions from global flags
func getGlobalOptions() GlobalOptions <span class="cov8" title="1">{
        return GlobalOptions{
                SessionID:   sessionID,
                ProjectPath: projectPath,
                SessionOnly: sessionOnly,
        }
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // Set version string with build info
        rootCmd.Version = fmt.Sprintf("%s (commit: %s, built: %s)", Version, Commit, BuildTime)

        // Global flags
        rootCmd.PersistentFlags().StringVar(&amp;sessionID, "session", "", "Session ID (or use $CC_SESSION_ID)")
        rootCmd.PersistentFlags().StringVar(&amp;projectPath, "project", "", "Project path (defaults to current directory)")
        rootCmd.PersistentFlags().BoolVar(&amp;sessionOnly, "session-only", false, "Analyze current session only (opt-out of project-level default)")
        rootCmd.PersistentFlags().StringVarP(&amp;outputFormat, "output", "o", "jsonl", "Output format: jsonl|tsv")

        // Phase 9.1: Pagination and size estimation flags
        rootCmd.PersistentFlags().IntVar(&amp;limitFlag, "limit", 0, "Limit output to N records (0 = no limit)")
        rootCmd.PersistentFlags().IntVar(&amp;offsetFlag, "offset", 0, "Skip first M records")
        rootCmd.PersistentFlags().BoolVar(&amp;estimateSizeFlag, "estimate-size", false, "Estimate output size without generating full output")

        // Phase 9.2: Chunking flags
        rootCmd.PersistentFlags().IntVar(&amp;chunkSizeFlag, "chunk-size", 0, "Split output into chunks of N records (0 = no chunking)")
        rootCmd.PersistentFlags().StringVar(&amp;outputDirFlag, "output-dir", "", "Output directory for chunks (required with --chunk-size)")

        // Phase 9.3: Field projection flags
        rootCmd.PersistentFlags().StringVar(&amp;fieldsFlag, "fields", "", "Output only specified fields (comma-separated, e.g., 'UUID,ToolName,Status')")
        rootCmd.PersistentFlags().StringVar(&amp;ifErrorIncludeFlag, "if-error-include", "", "Include additional fields for error records (comma-separated)")

        // Phase 9.4: Compact output format flags
        rootCmd.PersistentFlags().BoolVar(&amp;summaryFirstFlag, "summary-first", false, "Output summary before detailed records")
        rootCmd.PersistentFlags().IntVar(&amp;topNFlag, "top", 0, "Show only top N detailed records (requires --summary-first, 0 = all)")

        // Bind environment variables
        viper.BindPFlag("session", rootCmd.PersistentFlags().Lookup("session"))
        viper.BindPFlag("project", rootCmd.PersistentFlags().Lookup("project"))
        viper.BindEnv("session", "CC_SESSION_ID")
        viper.BindEnv("project", "CC_PROJECT_PATH")
}</span>

func initConfig() <span class="cov8" title="1">{
        viper.AutomaticEnv()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/filter"
        internalOutput "github.com/yale/meta-cc/internal/output"
        "github.com/yale/meta-cc/internal/parser"
        "github.com/yale/meta-cc/internal/stats"
        "github.com/yale/meta-cc/pkg/output"
)

var (
        aggregateGroupBy string
        aggregateMetrics string
        aggregateFilter  string
)

// statsCmd represents the stats parent command
var statsCmd = &amp;cobra.Command{
        Use:   "stats",
        Short: "Statistical analysis of session data",
        Long:  `Perform statistical analysis and aggregation on Claude Code session data.`,
}

// statsAggregateCmd represents the stats aggregate subcommand
var statsAggregateCmd = &amp;cobra.Command{
        Use:   "aggregate",
        Short: "Aggregate data with group-by and metrics",
        Long: `Aggregate tool call data by grouping and calculating metrics.

Supported group-by fields:
  - tool:   Group by tool name
  - status: Group by execution status
  - uuid:   Group by session entry UUID

Supported metrics:
  - count:      Number of records in group
  - error_rate: Percentage of errors (0.0-1.0)

Examples:
  # Error rate by tool
  meta-cc stats aggregate --group-by tool --metrics error_rate

  # Multiple metrics
  meta-cc stats aggregate --group-by tool --metrics "count,error_rate"

  # With filtering
  meta-cc stats aggregate --group-by status --metrics count --filter "tool='Bash'"`,
        RunE: runStatsAggregate,
}

func init() <span class="cov8" title="1">{
        // Add stats command to root
        rootCmd.AddCommand(statsCmd)

        // Add aggregate subcommand to stats
        statsCmd.AddCommand(statsAggregateCmd)

        // Flags for aggregate
        statsAggregateCmd.Flags().StringVar(&amp;aggregateGroupBy, "group-by", "tool", "Field to group by (tool|status|uuid)")
        statsAggregateCmd.Flags().StringVar(&amp;aggregateMetrics, "metrics", "count", "Metrics to calculate (comma-separated)")
        statsAggregateCmd.Flags().StringVar(&amp;aggregateFilter, "filter", "", "Filter expression (SQL-like)")
}</span>

func runStatsAggregate(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Step 2: Extract tool calls
        <span class="cov0" title="0">toolCalls := p.ExtractToolCalls()

        // Step 3: Apply filter if provided (using Stage 10.1 filter engine)
        if aggregateFilter != "" </span><span class="cov0" title="0">{
                expr, err := filter.ParseExpression(aggregateFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid filter: %w", err)
                }</span>

                <span class="cov0" title="0">var filtered []parser.ToolCall
                for _, tc := range toolCalls </span><span class="cov0" title="0">{
                        // Convert ToolCall to map for expression evaluation
                        record := map[string]interface{}{
                                "tool":   tc.ToolName,
                                "status": tc.Status,
                                "uuid":   tc.UUID,
                                "error":  tc.Error,
                        }

                        match, err := expr.Evaluate(record)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("filter evaluation error: %w", err)
                        }</span>

                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                filtered = append(filtered, tc)
                        }</span>
                }
                <span class="cov0" title="0">toolCalls = filtered</span>
        }

        // Step 4: Parse metrics
        <span class="cov0" title="0">metricsList := strings.Split(aggregateMetrics, ",")
        for i, m := range metricsList </span><span class="cov0" title="0">{
                metricsList[i] = strings.TrimSpace(m)
        }</span>

        // Step 5: Perform aggregation
        <span class="cov0" title="0">config := stats.AggregateConfig{
                GroupBy: aggregateGroupBy,
                Metrics: metricsList,
        }

        results, err := stats.Aggregate(toolCalls, config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("aggregation failed: %w", err)
        }</span>

        // Step 6: Format output
        <span class="cov0" title="0">var outputStr string
        switch outputFormat </span>{
        case "jsonl":<span class="cov0" title="0">
                outputStr, err = output.FormatJSONL(results)</span>
        case "tsv":<span class="cov0" title="0">
                outputStr, err = output.FormatTSV(results)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s (supported: jsonl, tsv)", outputFormat)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format output: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)

        // Check for empty results and return appropriate exit code
        if len(results) == 0 </span><span class="cov0" title="0">{
                return internalOutput.NewExitCodeError(internalOutput.ExitNoResults, "No results found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/filter"
        internalOutput "github.com/yale/meta-cc/internal/output"
        "github.com/yale/meta-cc/internal/stats"
        "github.com/yale/meta-cc/pkg/output"
)

var (
        filesSortBy string
        filesTop    int
        filesFilter string
)

// statsFilesCmd represents the stats files subcommand
var statsFilesCmd = &amp;cobra.Command{
        Use:   "files",
        Short: "Analyze file-level statistics",
        Long: `Show statistics for files accessed during the session.

Tracks read, edit, write operations and error counts per file.

Supported sort fields:
  - total_ops:   Total number of operations (default)
  - edit_count:  Number of edit operations
  - read_count:  Number of read operations
  - write_count: Number of write operations
  - error_count: Number of errors
  - error_rate:  Percentage of operations that failed (0.0-1.0)

Examples:
  # Most edited files
  meta-cc stats files --sort-by edit_count --top 20

  # Files with most errors
  meta-cc stats files --sort-by error_count --top 10

  # Files with highest error rate
  meta-cc stats files --sort-by error_rate --filter "error_count&gt;0"`,
        RunE: runStatsFiles,
}

func init() <span class="cov8" title="1">{
        // Add files subcommand to stats
        statsCmd.AddCommand(statsFilesCmd)

        // Flags for files
        statsFilesCmd.Flags().StringVar(&amp;filesSortBy, "sort-by", "total_ops", "Sort by field (total_ops|edit_count|read_count|write_count|error_count|error_rate)")
        statsFilesCmd.Flags().IntVar(&amp;filesTop, "top", 0, "Show only top N files (0 = all)")
        statsFilesCmd.Flags().StringVar(&amp;filesFilter, "filter", "", "Filter expression (SQL-like)")
}</span>

func runStatsFiles(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Step 2: Extract tool calls
        <span class="cov0" title="0">toolCalls := p.ExtractToolCalls()

        // Step 3: Analyze file statistics
        fileStats := stats.AnalyzeFileStats(toolCalls)

        // Step 4: Apply filter if provided
        if filesFilter != "" </span><span class="cov0" title="0">{
                expr, err := filter.ParseExpression(filesFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid filter: %w", err)
                }</span>

                <span class="cov0" title="0">var filtered []stats.FileStats
                for _, fs := range fileStats </span><span class="cov0" title="0">{
                        // Convert FileStats to map for expression evaluation
                        record := map[string]interface{}{
                                "file_path":   fs.FilePath,
                                "read_count":  fs.ReadCount,
                                "edit_count":  fs.EditCount,
                                "write_count": fs.WriteCount,
                                "error_count": fs.ErrorCount,
                                "total_ops":   fs.TotalOps,
                                "error_rate":  fs.ErrorRate,
                        }

                        match, err := expr.Evaluate(record)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("filter evaluation error: %w", err)
                        }</span>

                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                filtered = append(filtered, fs)
                        }</span>
                }
                <span class="cov0" title="0">fileStats = filtered</span>
        }

        // Step 5: Apply sorting
        <span class="cov0" title="0">stats.SortFileStats(fileStats, filesSortBy)

        // Step 6: Apply top N limit
        if filesTop &gt; 0 &amp;&amp; filesTop &lt; len(fileStats) </span><span class="cov0" title="0">{
                fileStats = fileStats[:filesTop]
        }</span>

        // Step 7: Format output
        <span class="cov0" title="0">var outputStr string
        var formatErr error
        switch outputFormat </span>{
        case "jsonl":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatJSONL(fileStats)</span>
        case "tsv":<span class="cov0" title="0">
                outputStr, formatErr = output.FormatTSV(fileStats)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s (supported: jsonl, tsv)", outputFormat)</span>
        }

        <span class="cov0" title="0">if formatErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format output: %w", formatErr)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)

        // Check for empty results and return appropriate exit code
        if len(fileStats) == 0 </span><span class="cov0" title="0">{
                return internalOutput.NewExitCodeError(internalOutput.ExitNoResults, "No results found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/yale/meta-cc/internal/filter"
        internalOutput "github.com/yale/meta-cc/internal/output"
        "github.com/yale/meta-cc/internal/parser"
        "github.com/yale/meta-cc/internal/stats"
        "github.com/yale/meta-cc/pkg/output"
)

var (
        timeSeriesMetric   string
        timeSeriesInterval string
        timeSeriesFilter   string
)

// statsTimeSeriesCmd represents the stats time-series subcommand
var statsTimeSeriesCmd = &amp;cobra.Command{
        Use:   "time-series",
        Short: "Analyze metrics over time",
        Long: `Generate time series data for specified metrics.

Supported metrics:
  - tool-calls: Count of tool calls per time bucket
  - error-rate: Percentage of errors per time bucket (0.0-1.0)

Supported intervals:
  - hour: Bucket by hour
  - day:  Bucket by day
  - week: Bucket by week (ISO week, Monday start)

Examples:
  # Tool calls per hour
  meta-cc stats time-series --metric tool-calls --interval hour

  # Error rate per day
  meta-cc stats time-series --metric error-rate --interval day

  # Tool calls per week with filtering
  meta-cc stats time-series --metric tool-calls --interval week --filter "tool='Bash'"`,
        RunE: runStatsTimeSeries,
}

func init() <span class="cov8" title="1">{
        // Add time-series subcommand to stats
        statsCmd.AddCommand(statsTimeSeriesCmd)

        // Flags for time-series
        statsTimeSeriesCmd.Flags().StringVar(&amp;timeSeriesMetric, "metric", "tool-calls", "Metric to analyze (tool-calls|error-rate)")
        statsTimeSeriesCmd.Flags().StringVar(&amp;timeSeriesInterval, "interval", "hour", "Time interval (hour|day|week)")
        statsTimeSeriesCmd.Flags().StringVar(&amp;timeSeriesFilter, "filter", "", "Filter expression (SQL-like)")
}</span>

func runStatsTimeSeries(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Step 1: Initialize and load session using pipeline
        p := NewSessionPipeline(getGlobalOptions())
        if err := p.Load(LoadOptions{AutoDetect: true}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to locate session: %w", err)
        }</span>

        // Step 2: Extract tool calls
        <span class="cov0" title="0">toolCalls := p.ExtractToolCalls()

        // Step 3: Apply filter if provided
        if timeSeriesFilter != "" </span><span class="cov0" title="0">{
                expr, err := filter.ParseExpression(timeSeriesFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid filter: %w", err)
                }</span>

                <span class="cov0" title="0">var filtered []parser.ToolCall
                for _, tc := range toolCalls </span><span class="cov0" title="0">{
                        // Convert ToolCall to map for expression evaluation
                        record := map[string]interface{}{
                                "tool":   tc.ToolName,
                                "status": tc.Status,
                                "uuid":   tc.UUID,
                                "error":  tc.Error,
                        }

                        match, err := expr.Evaluate(record)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("filter evaluation error: %w", err)
                        }</span>

                        <span class="cov0" title="0">if match </span><span class="cov0" title="0">{
                                filtered = append(filtered, tc)
                        }</span>
                }
                <span class="cov0" title="0">toolCalls = filtered</span>
        }

        // Step 4: Perform time series analysis
        <span class="cov0" title="0">config := stats.TimeSeriesConfig{
                Metric:   timeSeriesMetric,
                Interval: timeSeriesInterval,
        }

        points, err := stats.AnalyzeTimeSeries(toolCalls, config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("time series analysis failed: %w", err)
        }</span>

        // Step 5: Format output
        <span class="cov0" title="0">var outputStr string
        switch outputFormat </span>{
        case "jsonl":<span class="cov0" title="0">
                outputStr, err = output.FormatJSONL(points)</span>
        case "tsv":<span class="cov0" title="0">
                outputStr, err = output.FormatTSV(points)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s (supported: jsonl, tsv)", outputFormat)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format output: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(cmd.OutOrStdout(), outputStr)

        // Check for empty results and return appropriate exit code
        if len(points) == 0 </span><span class="cov0" title="0">{
                return internalOutput.NewExitCodeError(internalOutput.ExitNoResults, "No results found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package analyzer

import (
        "crypto/sha256"
        "fmt"
)

// CalculateErrorSignature 计算错误签名
// 签名基于工具名和错误文本的前 100 个字符的哈希值
// 相同的错误类型会生成相同的签名，用于模式检测
func CalculateErrorSignature(toolName, errorText string) string <span class="cov8" title="1">{
        // 限制错误文本长度为前 100 个字符
        truncatedError := errorText
        if len(errorText) &gt; 100 </span><span class="cov8" title="1">{
                truncatedError = errorText[:100]
        }</span>

        // 组合工具名和错误文本
        <span class="cov8" title="1">combined := fmt.Sprintf("%s:%s", toolName, truncatedError)

        // 计算 SHA256 哈希
        hash := sha256.Sum256([]byte(combined))

        // 返回哈希的十六进制表示（前 16 个字符作为签名）
        return fmt.Sprintf("%x", hash)[:16]</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package analyzer

import (
        "sort"
        "time"

        "github.com/yale/meta-cc/internal/parser"
)

// ErrorPattern 表示检测到的错误模式
type ErrorPattern struct {
        PatternID       string         `json:"pattern_id"`        // 模式唯一标识符（基于签名）
        Type            string         `json:"type"`              // 模式类型（目前为 "repeated_error"）
        Occurrences     int            `json:"occurrences"`       // 出现次数
        Signature       string         `json:"signature"`         // 错误签名
        ToolName        string         `json:"tool_name"`         // 工具名称
        ErrorText       string         `json:"error_text"`        // 错误文本示例（第一次出现的错误文本）
        FirstSeen       string         `json:"first_seen"`        // 首次出现的时间戳
        LastSeen        string         `json:"last_seen"`         // 最后一次出现的时间戳
        TimeSpanSeconds int            `json:"time_span_seconds"` // 时间跨度（秒）
        Context         PatternContext `json:"context"`           // 模式上下文信息
}

// PatternContext 表示错误模式的上下文信息
type PatternContext struct {
        TurnUUIDs   []string `json:"turn_uuids"`   // 包含此错误的 Turn UUID 序列
        TurnIndices []int    `json:"turn_indices"` // Turn 在 entries 中的索引
}

// DetectErrorPatterns 检测错误模式
// 返回在会话中重复出现的错误（出现次数 &gt;= 3）
func DetectErrorPatterns(entries []parser.SessionEntry, toolCalls []parser.ToolCall) []ErrorPattern <span class="cov8" title="1">{
        // 构建 UUID -&gt; 索引映射
        uuidToIndex := make(map[string]int)
        for i, entry := range entries </span><span class="cov8" title="1">{
                uuidToIndex[entry.UUID] = i
        }</span>

        // 构建 UUID -&gt; 时间戳映射
        <span class="cov8" title="1">uuidToTimestamp := make(map[string]string)
        for _, entry := range entries </span><span class="cov8" title="1">{
                uuidToTimestamp[entry.UUID] = entry.Timestamp
        }</span>

        // 按签名分组错误
        <span class="cov8" title="1">errorGroups := make(map[string][]parser.ToolCall)

        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                // 仅处理错误状态的工具调用
                if tc.Status != "error" &amp;&amp; tc.Error == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // 计算错误签名
                <span class="cov8" title="1">signature := CalculateErrorSignature(tc.ToolName, tc.Error)

                // 按签名分组
                errorGroups[signature] = append(errorGroups[signature], tc)</span>
        }

        // 检测模式（出现次数 &gt;= 3）
        <span class="cov8" title="1">var patterns []ErrorPattern

        for signature, group := range errorGroups </span><span class="cov8" title="1">{
                if len(group) &lt; 3 </span><span class="cov8" title="1">{
                        continue</span> // 少于 3 次不形成模式
                }

                // 构建模式
                <span class="cov8" title="1">pattern := ErrorPattern{
                        PatternID:   signature,
                        Type:        "repeated_error",
                        ToolName:    group[0].ToolName,
                        Occurrences: len(group),
                        Signature:   signature,
                        ErrorText:   group[0].Error,
                        Context:     buildPatternContext(group, uuidToIndex, uuidToTimestamp),
                }

                // 设置时间信息
                timestamps := extractTimestamps(group, uuidToTimestamp)
                if len(timestamps) &gt; 0 </span><span class="cov8" title="1">{
                        pattern.FirstSeen = timestamps[0]
                        pattern.LastSeen = timestamps[len(timestamps)-1]
                        pattern.TimeSpanSeconds = calculateTimeSpan(timestamps[0], timestamps[len(timestamps)-1])
                }</span>

                <span class="cov8" title="1">patterns = append(patterns, pattern)</span>
        }

        // 按出现次数降序排序
        <span class="cov8" title="1">sort.Slice(patterns, func(i, j int) bool </span><span class="cov8" title="1">{
                return patterns[i].Occurrences &gt; patterns[j].Occurrences
        }</span>)

        <span class="cov8" title="1">return patterns</span>
}

// buildPatternContext 构建模式上下文
func buildPatternContext(toolCalls []parser.ToolCall, uuidToIndex map[string]int, uuidToTimestamp map[string]string) PatternContext <span class="cov8" title="1">{
        context := PatternContext{
                TurnUUIDs:   make([]string, 0, len(toolCalls)),
                TurnIndices: make([]int, 0, len(toolCalls)),
        }

        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                context.TurnUUIDs = append(context.TurnUUIDs, tc.UUID)
                if index, found := uuidToIndex[tc.UUID]; found </span><span class="cov8" title="1">{
                        context.TurnIndices = append(context.TurnIndices, index)
                }</span>
        }

        <span class="cov8" title="1">return context</span>
}

// extractTimestamps 提取时间戳并排序
func extractTimestamps(toolCalls []parser.ToolCall, uuidToTimestamp map[string]string) []string <span class="cov8" title="1">{
        timestamps := make([]string, 0, len(toolCalls))

        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                if ts, found := uuidToTimestamp[tc.UUID]; found &amp;&amp; ts != "" </span><span class="cov8" title="1">{
                        timestamps = append(timestamps, ts)
                }</span>
        }

        // 按时间排序
        <span class="cov8" title="1">sort.Strings(timestamps)

        return timestamps</span>
}

// calculateTimeSpan 计算时间跨度（秒）
func calculateTimeSpan(first, last string) int <span class="cov8" title="1">{
        if first == "" || last == "" </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">firstTime, err1 := time.Parse(time.RFC3339, first)
        lastTime, err2 := time.Parse(time.RFC3339, last)

        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return int(lastTime.Sub(firstTime).Seconds())</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package analyzer

import (
        "sort"
        "time"

        "github.com/yale/meta-cc/internal/parser"
)

// SessionStats represents statistical information about a session
type SessionStats struct {
        TurnCount          int            // Total turn count (all message rounds)
        UserTurnCount      int            // User turn count
        AssistantTurnCount int            // Assistant turn count
        ToolCallCount      int            // Total tool calls
        ErrorCount         int            // Error tool calls count
        DurationSeconds    int64          // Session duration (seconds)
        ToolFrequency      map[string]int // Tool usage frequency (tool name -&gt; count)
        ErrorRate          float64        // Error rate (percentage)
        TopTools           []ToolFreq     // Most frequently used tools (Top 5)
}

// ToolFreq represents tool usage frequency
type ToolFreq struct {
        Name  string // Tool name
        Count int    // Call count
}

// CalculateStats calculates session statistics
func CalculateStats(entries []parser.SessionEntry, toolCalls []parser.ToolCall) SessionStats <span class="cov8" title="1">{
        stats := SessionStats{
                ToolFrequency: make(map[string]int),
        }

        // Calculate turn counts
        stats.TurnCount = len(entries)
        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.Type == "user" </span><span class="cov8" title="1">{
                        stats.UserTurnCount++
                }</span> else<span class="cov8" title="1"> if entry.Type == "assistant" </span><span class="cov8" title="1">{
                        stats.AssistantTurnCount++
                }</span>
        }

        // Calculate tool call statistics
        <span class="cov8" title="1">stats.ToolCallCount = len(toolCalls)
        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                // Count errors
                if tc.Status == "error" || tc.Error != "" </span><span class="cov8" title="1">{
                        stats.ErrorCount++
                }</span>

                // Count tool usage frequency
                <span class="cov8" title="1">stats.ToolFrequency[tc.ToolName]++</span>
        }

        // Calculate error rate
        <span class="cov8" title="1">if stats.ToolCallCount &gt; 0 </span><span class="cov8" title="1">{
                stats.ErrorRate = float64(stats.ErrorCount) / float64(stats.ToolCallCount) * 100
        }</span>

        // Calculate session duration
        <span class="cov8" title="1">if len(entries) &gt;= 2 </span><span class="cov8" title="1">{
                firstTime, err1 := time.Parse(time.RFC3339, entries[0].Timestamp)
                lastTime, err2 := time.Parse(time.RFC3339, entries[len(entries)-1].Timestamp)

                if err1 == nil &amp;&amp; err2 == nil </span><span class="cov8" title="1">{
                        stats.DurationSeconds = int64(lastTime.Sub(firstTime).Seconds())
                }</span>
        }

        // Calculate TopTools (sorted by frequency)
        <span class="cov8" title="1">stats.TopTools = calculateTopTools(stats.ToolFrequency, 5)

        return stats</span>
}

// calculateTopTools calculates the most frequently used tools (Top N)
func calculateTopTools(frequency map[string]int, topN int) []ToolFreq <span class="cov8" title="1">{
        var tools []ToolFreq

        for name, count := range frequency </span><span class="cov8" title="1">{
                tools = append(tools, ToolFreq{Name: name, Count: count})
        }</span>

        // Sort by count descending
        <span class="cov8" title="1">sort.Slice(tools, func(i, j int) bool </span><span class="cov8" title="1">{
                if tools[i].Count == tools[j].Count </span><span class="cov8" title="1">{
                        // When counts are equal, sort by name alphabetically
                        return tools[i].Name &lt; tools[j].Name
                }</span>
                <span class="cov8" title="1">return tools[i].Count &gt; tools[j].Count</span>
        })

        // Return top N
        <span class="cov8" title="1">if len(tools) &gt; topN </span><span class="cov0" title="0">{
                tools = tools[:topN]
        }</span>

        <span class="cov8" title="1">return tools</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package analyzer

import (
        "sort"
        "strings"
        "time"

        "github.com/yale/meta-cc/internal/parser"
)

// SequenceAnalysis represents tool sequence analysis results
type SequenceAnalysis struct {
        Sequences []SequencePattern `json:"sequences"`
}

// SequencePattern represents a repeated tool call sequence
type SequencePattern struct {
        Pattern     string               `json:"pattern"`
        Length      int                  `json:"length"`
        Count       int                  `json:"count"`
        Occurrences []SequenceOccurrence `json:"occurrences"`
        TimeSpanMin int                  `json:"time_span_minutes"`
}

// SequenceOccurrence represents a single occurrence of a sequence
type SequenceOccurrence struct {
        StartTurn int              `json:"start_turn"`
        EndTurn   int              `json:"end_turn"`
        Tools     []ToolInSequence `json:"tools"`
}

// ToolInSequence represents a tool call within a sequence
type ToolInSequence struct {
        Turn    int    `json:"turn"`
        Tool    string `json:"tool"`
        File    string `json:"file,omitempty"`
        Command string `json:"command,omitempty"`
}

// FileChurnAnalysis represents file churn analysis results
type FileChurnAnalysis struct {
        HighChurnFiles []FileChurnDetail `json:"high_churn_files"`
}

// FileChurnDetail represents detailed file access statistics
type FileChurnDetail struct {
        File          string `json:"file"`
        ReadCount     int    `json:"read_count"`
        EditCount     int    `json:"edit_count"`
        WriteCount    int    `json:"write_count"`
        TotalAccesses int    `json:"total_accesses"`
        TimeSpanMin   int    `json:"time_span_minutes"`
        FirstAccess   int64  `json:"first_access"`
        LastAccess    int64  `json:"last_access"`
}

// IdlePeriodAnalysis represents idle period analysis results
type IdlePeriodAnalysis struct {
        IdlePeriods []IdlePeriod `json:"idle_periods"`
}

// IdlePeriod represents a detected idle period
type IdlePeriod struct {
        StartTurn      int          `json:"start_turn"`
        EndTurn        int          `json:"end_turn"`
        DurationMin    float64      `json:"duration_minutes"`
        StartTimestamp int64        `json:"start_timestamp"`
        EndTimestamp   int64        `json:"end_timestamp"`
        ContextBefore  *TurnContext `json:"context_before,omitempty"`
        ContextAfter   *TurnContext `json:"context_after,omitempty"`
}

// TurnContext represents context around an event
type TurnContext struct {
        Turn    int    `json:"turn"`
        Role    string `json:"role,omitempty"`
        Tool    string `json:"tool,omitempty"`
        Status  string `json:"status,omitempty"`
        Preview string `json:"preview,omitempty"`
}

// DetectToolSequences detects repeated tool call sequences
func DetectToolSequences(entries []parser.SessionEntry, minLength, minOccurrences int) SequenceAnalysis <span class="cov8" title="1">{
        // Build turn index
        turnIndex := buildTurnIndex(entries)

        // Extract tool calls with turn numbers
        toolCalls := extractToolCallsWithTurns(entries, turnIndex)

        // Sort by turn
        sort.Slice(toolCalls, func(i, j int) bool </span><span class="cov8" title="1">{
                return toolCalls[i].turn &lt; toolCalls[j].turn
        }</span>)

        // Find all sequences
        <span class="cov8" title="1">sequences := findAllSequences(toolCalls, minLength, minOccurrences, entries)

        return SequenceAnalysis{
                Sequences: sequences,
        }</span>
}

// DetectFileChurn detects files with frequent access
func DetectFileChurn(entries []parser.SessionEntry, threshold int) FileChurnAnalysis <span class="cov8" title="1">{
        // Extract file access events
        fileAccess := make(map[string]*fileAccessStats)

        toolCalls := parser.ExtractToolCalls(entries)
        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                // Extract file path
                filePath := extractFileFromToolCall(tc)
                if filePath == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get action type
                <span class="cov8" title="1">action := getActionType(tc.ToolName)
                if action == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get timestamp
                <span class="cov8" title="1">timestamp := getToolCallTimestamp(entries, tc.UUID)

                // Initialize or update stats
                if _, exists := fileAccess[filePath]; !exists </span><span class="cov8" title="1">{
                        fileAccess[filePath] = &amp;fileAccessStats{
                                file:        filePath,
                                firstAccess: timestamp,
                                lastAccess:  timestamp,
                        }
                }</span>

                <span class="cov8" title="1">stats := fileAccess[filePath]
                stats.totalAccesses++

                switch action </span>{
                case "Read":<span class="cov8" title="1">
                        stats.readCount++</span>
                case "Edit":<span class="cov8" title="1">
                        stats.editCount++</span>
                case "Write":<span class="cov0" title="0">
                        stats.writeCount++</span>
                }

                <span class="cov8" title="1">if timestamp &lt; stats.firstAccess </span><span class="cov8" title="1">{
                        stats.firstAccess = timestamp
                }</span>
                <span class="cov8" title="1">if timestamp &gt; stats.lastAccess </span><span class="cov8" title="1">{
                        stats.lastAccess = timestamp
                }</span>
        }

        // Filter by threshold and build result
        <span class="cov8" title="1">var highChurnFiles []FileChurnDetail
        for _, stats := range fileAccess </span><span class="cov8" title="1">{
                if stats.totalAccesses &gt;= threshold </span><span class="cov8" title="1">{
                        timeSpan := 0
                        if stats.lastAccess &gt; stats.firstAccess </span><span class="cov8" title="1">{
                                timeSpan = int((stats.lastAccess - stats.firstAccess) / 60)
                        }</span>

                        <span class="cov8" title="1">highChurnFiles = append(highChurnFiles, FileChurnDetail{
                                File:          stats.file,
                                ReadCount:     stats.readCount,
                                EditCount:     stats.editCount,
                                WriteCount:    stats.writeCount,
                                TotalAccesses: stats.totalAccesses,
                                TimeSpanMin:   timeSpan,
                                FirstAccess:   stats.firstAccess,
                                LastAccess:    stats.lastAccess,
                        })</span>
                }
        }

        // Sort by total accesses (descending)
        <span class="cov8" title="1">sort.Slice(highChurnFiles, func(i, j int) bool </span><span class="cov8" title="1">{
                return highChurnFiles[i].TotalAccesses &gt; highChurnFiles[j].TotalAccesses
        }</span>)

        <span class="cov8" title="1">return FileChurnAnalysis{
                HighChurnFiles: highChurnFiles,
        }</span>
}

// DetectIdlePeriods detects idle periods in the session
func DetectIdlePeriods(entries []parser.SessionEntry, thresholdMin int) IdlePeriodAnalysis <span class="cov8" title="1">{
        // Build turn index
        turnIndex := buildTurnIndex(entries)

        // Extract all entries with timestamps (both user and assistant)
        type entryWithTurn struct {
                entry parser.SessionEntry
                turn  int
        }

        var entriesWithTurns []entryWithTurn
        for _, entry := range entries </span><span class="cov8" title="1">{
                if turn, ok := turnIndex[entry.UUID]; ok </span><span class="cov8" title="1">{
                        entriesWithTurns = append(entriesWithTurns, entryWithTurn{
                                entry: entry,
                                turn:  turn,
                        })
                }</span>
        }

        // Sort by turn
        <span class="cov8" title="1">sort.Slice(entriesWithTurns, func(i, j int) bool </span><span class="cov8" title="1">{
                return entriesWithTurns[i].turn &lt; entriesWithTurns[j].turn
        }</span>)

        // Find idle periods
        <span class="cov8" title="1">var idlePeriods []IdlePeriod
        thresholdSec := float64(thresholdMin * 60)

        for i := 0; i &lt; len(entriesWithTurns)-1; i++ </span><span class="cov8" title="1">{
                current := entriesWithTurns[i]
                next := entriesWithTurns[i+1]

                currentTs := parseTimestamp(current.entry.Timestamp)
                nextTs := parseTimestamp(next.entry.Timestamp)

                if currentTs == 0 || nextTs == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">gapSec := float64(nextTs - currentTs)
                if gapSec &gt;= thresholdSec </span><span class="cov8" title="1">{
                        // Found an idle period
                        period := IdlePeriod{
                                StartTurn:      current.turn,
                                EndTurn:        next.turn,
                                DurationMin:    gapSec / 60,
                                StartTimestamp: currentTs,
                                EndTimestamp:   nextTs,
                        }

                        // Add context
                        period.ContextBefore = extractTurnContext(current.entry, current.turn)
                        period.ContextAfter = extractTurnContext(next.entry, next.turn)

                        idlePeriods = append(idlePeriods, period)
                }</span>
        }

        <span class="cov8" title="1">return IdlePeriodAnalysis{
                IdlePeriods: idlePeriods,
        }</span>
}

// Helper types and functions

type fileAccessStats struct {
        file          string
        readCount     int
        editCount     int
        writeCount    int
        totalAccesses int
        firstAccess   int64
        lastAccess    int64
}

type toolCallWithTurn struct {
        toolName string
        turn     int
        uuid     string
        filePath string
        command  string
}

func buildTurnIndex(entries []parser.SessionEntry) map[string]int <span class="cov8" title="1">{
        turnIndex := make(map[string]int)
        turn := 1
        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsMessage() </span><span class="cov8" title="1">{
                        turnIndex[entry.UUID] = turn
                        turn++
                }</span>
        }
        <span class="cov8" title="1">return turnIndex</span>
}

func extractToolCallsWithTurns(entries []parser.SessionEntry, turnIndex map[string]int) []toolCallWithTurn <span class="cov8" title="1">{
        var result []toolCallWithTurn

        toolCalls := parser.ExtractToolCalls(entries)
        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                if turn, ok := turnIndex[tc.UUID]; ok </span><span class="cov8" title="1">{
                        result = append(result, toolCallWithTurn{
                                toolName: tc.ToolName,
                                turn:     turn,
                                uuid:     tc.UUID,
                                filePath: extractFileFromToolCall(tc),
                                command:  extractCommandFromToolCall(tc),
                        })
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

func findAllSequences(toolCalls []toolCallWithTurn, minLength, minOccurrences int, entries []parser.SessionEntry) []SequencePattern <span class="cov8" title="1">{
        sequenceMap := make(map[string][]SequenceOccurrence)

        // Try sequences of different lengths
        maxLen := 5
        if maxLen &gt; len(toolCalls) </span><span class="cov8" title="1">{
                maxLen = len(toolCalls)
        }</span>

        <span class="cov8" title="1">for seqLen := minLength; seqLen &lt;= maxLen; seqLen++ </span><span class="cov8" title="1">{
                for i := 0; i &lt;= len(toolCalls)-seqLen; i++ </span><span class="cov8" title="1">{
                        // Extract sequence
                        tools := make([]string, seqLen)
                        for j := 0; j &lt; seqLen; j++ </span><span class="cov8" title="1">{
                                tools[j] = toolCalls[i+j].toolName
                        }</span>

                        // Create pattern string
                        <span class="cov8" title="1">pattern := strings.Join(tools, " → ")

                        // Build occurrence with tool details
                        var toolsInSeq []ToolInSequence
                        for j := 0; j &lt; seqLen; j++ </span><span class="cov8" title="1">{
                                tc := toolCalls[i+j]
                                toolsInSeq = append(toolsInSeq, ToolInSequence{
                                        Turn:    tc.turn,
                                        Tool:    tc.toolName,
                                        File:    tc.filePath,
                                        Command: tc.command,
                                })
                        }</span>

                        <span class="cov8" title="1">occurrence := SequenceOccurrence{
                                StartTurn: toolCalls[i].turn,
                                EndTurn:   toolCalls[i+seqLen-1].turn,
                                Tools:     toolsInSeq,
                        }

                        sequenceMap[pattern] = append(sequenceMap[pattern], occurrence)</span>
                }
        }

        // Filter by minimum occurrences and build result
        <span class="cov8" title="1">var result []SequencePattern
        for pattern, occurrences := range sequenceMap </span><span class="cov8" title="1">{
                if len(occurrences) &gt;= minOccurrences </span><span class="cov8" title="1">{
                        // Calculate length
                        length := len(strings.Split(pattern, " → "))

                        // Calculate time span
                        timeSpan := calculateSequenceTimeSpan(occurrences, entries)

                        result = append(result, SequencePattern{
                                Pattern:     pattern,
                                Length:      length,
                                Count:       len(occurrences),
                                Occurrences: occurrences,
                                TimeSpanMin: timeSpan,
                        })
                }</span>
        }

        // Sort by count (descending), then by length (descending)
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                if result[i].Count != result[j].Count </span><span class="cov0" title="0">{
                        return result[i].Count &gt; result[j].Count
                }</span>
                <span class="cov0" title="0">return result[i].Length &gt; result[j].Length</span>
        })

        <span class="cov8" title="1">return result</span>
}

func calculateSequenceTimeSpan(occurrences []SequenceOccurrence, entries []parser.SessionEntry) int <span class="cov8" title="1">{
        if len(occurrences) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">var minTs, maxTs int64

        for _, occ := range occurrences </span><span class="cov8" title="1">{
                // Find timestamps for turns in this occurrence
                for _, entry := range entries </span><span class="cov8" title="1">{
                        ts := parseTimestamp(entry.Timestamp)
                        if ts == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Check if this entry is part of the occurrence
                        <span class="cov8" title="1">for range occ.Tools </span><span class="cov8" title="1">{
                                if entry.UUID != "" &amp;&amp; ts &gt; 0 </span><span class="cov8" title="1">{
                                        // Update min/max
                                        if minTs == 0 || ts &lt; minTs </span><span class="cov8" title="1">{
                                                minTs = ts
                                        }</span>
                                        <span class="cov8" title="1">if ts &gt; maxTs </span><span class="cov8" title="1">{
                                                maxTs = ts
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if minTs == 0 || maxTs == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return int((maxTs - minTs) / 60)</span>
}

func extractFileFromToolCall(tc parser.ToolCall) string <span class="cov8" title="1">{
        fileParams := []string{"file_path", "notebook_path", "path"}

        for _, param := range fileParams </span><span class="cov8" title="1">{
                if val, ok := tc.Input[param]; ok </span><span class="cov8" title="1">{
                        if filePath, ok := val.(string); ok &amp;&amp; filePath != "" </span><span class="cov8" title="1">{
                                return filePath
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

func extractCommandFromToolCall(tc parser.ToolCall) string <span class="cov8" title="1">{
        if tc.ToolName == "Bash" </span><span class="cov8" title="1">{
                if val, ok := tc.Input["command"]; ok </span><span class="cov0" title="0">{
                        if cmd, ok := val.(string); ok </span><span class="cov0" title="0">{
                                // Return first line only for preview
                                lines := strings.Split(cmd, "\n")
                                if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                                        return lines[0]
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return ""</span>
}

func getActionType(toolName string) string <span class="cov8" title="1">{
        switch toolName </span>{
        case "Read":<span class="cov8" title="1">
                return "Read"</span>
        case "Edit":<span class="cov8" title="1">
                return "Edit"</span>
        case "Write":<span class="cov0" title="0">
                return "Write"</span>
        case "NotebookEdit":<span class="cov0" title="0">
                return "Edit"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func getToolCallTimestamp(entries []parser.SessionEntry, uuid string) int64 <span class="cov8" title="1">{
        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.UUID == uuid </span><span class="cov8" title="1">{
                        return parseTimestamp(entry.Timestamp)
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func parseTimestamp(ts string) int64 <span class="cov8" title="1">{
        t, err := time.Parse(time.RFC3339, ts)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return t.Unix()</span>
}

func extractTurnContext(entry parser.SessionEntry, turn int) *TurnContext <span class="cov8" title="1">{
        ctx := &amp;TurnContext{
                Turn: turn,
                Role: entry.Type,
        }

        if entry.Message != nil </span><span class="cov8" title="1">{
                // Extract tool info
                for _, block := range entry.Message.Content </span><span class="cov8" title="1">{
                        if block.Type == "tool_use" &amp;&amp; block.ToolUse != nil </span><span class="cov8" title="1">{
                                ctx.Tool = block.ToolUse.Name
                        }</span> else<span class="cov0" title="0"> if block.Type == "tool_result" &amp;&amp; block.ToolResult != nil </span><span class="cov0" title="0">{
                                ctx.Status = block.ToolResult.Status
                                if ctx.Status == "" &amp;&amp; block.ToolResult.Error != "" </span><span class="cov0" title="0">{
                                        ctx.Status = "error"
                                }</span>
                        } else<span class="cov0" title="0"> if block.Type == "text" &amp;&amp; block.Text != "" </span><span class="cov0" title="0">{
                                // Extract preview (first 100 chars)
                                preview := block.Text
                                if len(preview) &gt; 100 </span><span class="cov0" title="0">{
                                        preview = preview[:100] + "..."
                                }</span>
                                <span class="cov0" title="0">ctx.Preview = preview</span>
                        }
                }
        }

        <span class="cov8" title="1">return ctx</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package filter

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

// Expression represents a filter expression that can be evaluated
type Expression interface {
        Evaluate(record map[string]interface{}) (bool, error)
}

// ComparisonExpression represents a comparison operation (=, !=, &gt;, &lt;, &gt;=, &lt;=)
type ComparisonExpression struct {
        Field    string
        Operator string
        Value    interface{}
}

func (e *ComparisonExpression) Evaluate(record map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        fieldValue, exists := record[e.Field]
        if !exists </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return compareValues(fieldValue, e.Operator, e.Value)</span>
}

// BinaryExpression represents a binary operation (AND, OR)
type BinaryExpression struct {
        Operator string
        Left     Expression
        Right    Expression
}

func (e *BinaryExpression) Evaluate(record map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        left, err := e.Left.Evaluate(record)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">right, err := e.Right.Evaluate(record)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">switch e.Operator </span>{
        case "AND":<span class="cov8" title="1">
                return left &amp;&amp; right, nil</span>
        case "OR":<span class="cov8" title="1">
                return left || right, nil</span>
        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unknown operator: %s", e.Operator)</span>
        }
}

// UnaryExpression represents a unary operation (NOT)
type UnaryExpression struct {
        Operator string
        Operand  Expression
}

func (e *UnaryExpression) Evaluate(record map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        result, err := e.Operand.Evaluate(record)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return !result, nil</span>
}

// InExpression represents set membership check (IN, NOT IN)
type InExpression struct {
        Field  string
        Values []interface{}
        Negate bool
}

func (e *InExpression) Evaluate(record map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        fieldValue, exists := record[e.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">found := false
        for _, v := range e.Values </span><span class="cov8" title="1">{
                if valueEquals(fieldValue, v) </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if e.Negate </span><span class="cov8" title="1">{
                return !found, nil
        }</span>
        <span class="cov8" title="1">return found, nil</span>
}

// BetweenExpression represents range check (BETWEEN ... AND ...)
type BetweenExpression struct {
        Field string
        Lower interface{}
        Upper interface{}
}

func (e *BetweenExpression) Evaluate(record map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        fieldValue, exists := record[e.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">lowerOk, _ := compareValues(fieldValue, "&gt;=", e.Lower)
        upperOk, _ := compareValues(fieldValue, "&lt;=", e.Upper)

        return lowerOk &amp;&amp; upperOk, nil</span>
}

// LikeExpression represents SQL LIKE pattern matching
type LikeExpression struct {
        Field   string
        Pattern string
}

func (e *LikeExpression) Evaluate(record map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        fieldValue, exists := record[e.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">str, ok := fieldValue.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Convert SQL LIKE pattern to regex
        <span class="cov8" title="1">var pattern strings.Builder
        pattern.WriteString("^")

        for i := 0; i &lt; len(e.Pattern); i++ </span><span class="cov8" title="1">{
                ch := e.Pattern[i]
                switch ch </span>{
                case '%':<span class="cov8" title="1">
                        pattern.WriteString(".*")</span>
                case '_':<span class="cov0" title="0">
                        pattern.WriteString(".")</span>
                default:<span class="cov8" title="1">
                        // Escape regex special characters
                        pattern.WriteString(regexp.QuoteMeta(string(ch)))</span>
                }
        }

        <span class="cov8" title="1">pattern.WriteString("$")

        matched, _ := regexp.MatchString(pattern.String(), str)
        return matched, nil</span>
}

// RegexpExpression represents regular expression matching
type RegexpExpression struct {
        Field   string
        Pattern string
}

func (e *RegexpExpression) Evaluate(record map[string]interface{}) (bool, error) <span class="cov8" title="1">{
        fieldValue, exists := record[e.Field]
        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">str, ok := fieldValue.(string)
        if !ok </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">matched, err := regexp.MatchString(e.Pattern, str)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid regexp: %v", err)
        }</span>

        <span class="cov8" title="1">return matched, nil</span>
}

// compareValues compares two values with the given operator
func compareValues(left interface{}, operator string, right interface{}) (bool, error) <span class="cov8" title="1">{
        // String comparison
        leftStr, leftIsStr := left.(string)
        rightStr, rightIsStr := right.(string)

        if leftIsStr &amp;&amp; rightIsStr </span><span class="cov8" title="1">{
                switch operator </span>{
                case "=":<span class="cov8" title="1">
                        return leftStr == rightStr, nil</span>
                case "!=":<span class="cov8" title="1">
                        return leftStr != rightStr, nil</span>
                case "&gt;":<span class="cov0" title="0">
                        return leftStr &gt; rightStr, nil</span>
                case "&lt;":<span class="cov0" title="0">
                        return leftStr &lt; rightStr, nil</span>
                case "&gt;=":<span class="cov0" title="0">
                        return leftStr &gt;= rightStr, nil</span>
                case "&lt;=":<span class="cov0" title="0">
                        return leftStr &lt;= rightStr, nil</span>
                }
        }

        // Numeric comparison
        <span class="cov8" title="1">leftNum, leftErr := toFloat64(left)
        rightNum, rightErr := toFloat64(right)

        if leftErr == nil &amp;&amp; rightErr == nil </span><span class="cov8" title="1">{
                switch operator </span>{
                case "=":<span class="cov0" title="0">
                        return leftNum == rightNum, nil</span>
                case "!=":<span class="cov0" title="0">
                        return leftNum != rightNum, nil</span>
                case "&gt;":<span class="cov8" title="1">
                        return leftNum &gt; rightNum, nil</span>
                case "&lt;":<span class="cov0" title="0">
                        return leftNum &lt; rightNum, nil</span>
                case "&gt;=":<span class="cov8" title="1">
                        return leftNum &gt;= rightNum, nil</span>
                case "&lt;=":<span class="cov8" title="1">
                        return leftNum &lt;= rightNum, nil</span>
                }
        }

        <span class="cov0" title="0">return false, fmt.Errorf("unsupported comparison: %v %s %v", left, operator, right)</span>
}

// valueEquals checks if two values are equal
func valueEquals(left, right interface{}) bool <span class="cov8" title="1">{
        if left == right </span><span class="cov8" title="1">{
                return true
        }</span>

        // String comparison
        <span class="cov8" title="1">leftStr, leftIsStr := left.(string)
        rightStr, rightIsStr := right.(string)
        if leftIsStr &amp;&amp; rightIsStr </span><span class="cov8" title="1">{
                return leftStr == rightStr
        }</span>

        // Numeric comparison
        <span class="cov0" title="0">leftNum, leftErr := toFloat64(left)
        rightNum, rightErr := toFloat64(right)
        if leftErr == nil &amp;&amp; rightErr == nil </span><span class="cov0" title="0">{
                return leftNum == rightNum
        }</span>

        <span class="cov0" title="0">return false</span>
}

// toFloat64 converts a value to float64
func toFloat64(val interface{}) (float64, error) <span class="cov8" title="1">{
        switch v := val.(type) </span>{
        case float64:<span class="cov0" title="0">
                return v, nil</span>
        case int:<span class="cov8" title="1">
                return float64(v), nil</span>
        case int64:<span class="cov0" title="0">
                return float64(v), nil</span>
        case string:<span class="cov0" title="0">
                return strconv.ParseFloat(v, 64)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("cannot convert to float64: %v", val)</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package filter

import (
        "fmt"
        "strings"

        "github.com/yale/meta-cc/internal/parser"
)

// Valid filter fields for different data types
var validFields = map[string][]string{
        "tool_calls": {"status", "tool", "uuid"},
        "entries":    {"type", "uuid", "role"},
}

// Condition represents a filter condition
type Condition struct {
        Field string // Field name (e.g., "status", "tool", "type")
        Value string // Value
}

// Filter represents a set of filter conditions
type Filter struct {
        Conditions []Condition
}

// ParseFilter parses a filter string (format: key=value,key2=value2)
func ParseFilter(filterStr string) (*Filter, error) <span class="cov8" title="1">{
        if filterStr == "" </span><span class="cov0" title="0">{
                return &amp;Filter{}, nil
        }</span>

        <span class="cov8" title="1">filter := &amp;Filter{}
        parts := strings.Split(filterStr, ",")

        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">kv := strings.SplitN(part, "=", 2)
                if len(kv) != 2 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid filter format: %s (expected key=value)", part)
                }</span>

                <span class="cov8" title="1">filter.Conditions = append(filter.Conditions, Condition{
                        Field: strings.TrimSpace(kv[0]),
                        Value: strings.TrimSpace(kv[1]),
                })</span>
        }

        <span class="cov8" title="1">return filter, nil</span>
}

// ApplyFilter applies filter to data
// Supports []parser.ToolCall and []parser.SessionEntry
func ApplyFilter(data interface{}, filter *Filter) interface{} <span class="cov8" title="1">{
        if filter == nil || len(filter.Conditions) == 0 </span><span class="cov8" title="1">{
                return data
        }</span>

        <span class="cov8" title="1">switch v := data.(type) </span>{
        case []parser.ToolCall:<span class="cov8" title="1">
                return filterToolCalls(v, filter)</span>
        case []parser.SessionEntry:<span class="cov8" title="1">
                return filterSessionEntries(v, filter)</span>
        default:<span class="cov0" title="0">
                // Unsupported type, return original data
                return data</span>
        }
}

func filterToolCalls(toolCalls []parser.ToolCall, filter *Filter) []parser.ToolCall <span class="cov8" title="1">{
        var result []parser.ToolCall

        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                if matchesToolCall(tc, filter) </span><span class="cov8" title="1">{
                        result = append(result, tc)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

func matchesToolCall(tc parser.ToolCall, filter *Filter) bool <span class="cov8" title="1">{
        for _, cond := range filter.Conditions </span><span class="cov8" title="1">{
                switch cond.Field </span>{
                case "status":<span class="cov8" title="1">
                        if tc.Status != cond.Value </span><span class="cov8" title="1">{
                                return false
                        }</span>
                case "tool":<span class="cov8" title="1">
                        if tc.ToolName != cond.Value </span><span class="cov8" title="1">{
                                return false
                        }</span>
                case "uuid":<span class="cov0" title="0">
                        if tc.UUID != cond.Value </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

func filterSessionEntries(entries []parser.SessionEntry, filter *Filter) []parser.SessionEntry <span class="cov8" title="1">{
        var result []parser.SessionEntry

        for _, entry := range entries </span><span class="cov8" title="1">{
                if matchesSessionEntry(entry, filter) </span><span class="cov8" title="1">{
                        result = append(result, entry)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

func matchesSessionEntry(entry parser.SessionEntry, filter *Filter) bool <span class="cov8" title="1">{
        for _, cond := range filter.Conditions </span><span class="cov8" title="1">{
                switch cond.Field </span>{
                case "type":<span class="cov8" title="1">
                        if entry.Type != cond.Value </span><span class="cov8" title="1">{
                                return false
                        }</span>
                case "uuid":<span class="cov0" title="0">
                        if entry.UUID != cond.Value </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "role":<span class="cov0" title="0">
                        if entry.Message == nil || entry.Message.Role != cond.Value </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}

// ValidateFilterField checks if a field name is valid for the data type
func ValidateFilterField(field string, dataType string) error <span class="cov8" title="1">{
        allowed, ok := validFields[dataType]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("unknown data type: %s", dataType)
        }</span>

        <span class="cov8" title="1">for _, valid := range allowed </span><span class="cov8" title="1">{
                if field == valid </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return fmt.Errorf("invalid field '%s' for %s (valid fields: %v)", field, dataType, allowed)</span>
}

// ParseWhereCondition is an alias for ParseFilter with more SQL-like naming
// Syntax: "field=value,field2=value2" (comma-separated AND conditions)
func ParseWhereCondition(where string) (*Filter, error) <span class="cov8" title="1">{
        return ParseFilter(where)
}</span>

// ApplyWhere applies a WHERE-style filter with field validation
func ApplyWhere(data interface{}, where string, dataType string) (interface{}, error) <span class="cov8" title="1">{
        filter, err := ParseWhereCondition(where)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate filter fields
        <span class="cov8" title="1">for _, cond := range filter.Conditions </span><span class="cov8" title="1">{
                if err := ValidateFilterField(cond.Field, dataType); err != nil </span><span class="cov8" title="1">{
                        // Return error for invalid fields
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return ApplyFilter(data, filter), nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package filter

import "github.com/yale/meta-cc/internal/parser"

// PaginationConfig defines pagination parameters
type PaginationConfig struct {
        Limit  int // 0 means no limit
        Offset int
}

// PaginationMetadata contains pagination information
type PaginationMetadata struct {
        TotalRecords    int  `json:"total_records"`
        ReturnedRecords int  `json:"returned_records"`
        Offset          int  `json:"offset"`
        Limit           int  `json:"limit"`
        HasMore         bool `json:"has_more"`
}

// ApplyPagination applies pagination to ToolCall slice
func ApplyPagination(tools []parser.ToolCall, config PaginationConfig) []parser.ToolCall <span class="cov8" title="1">{
        // Handle negative offset
        if config.Offset &lt; 0 </span><span class="cov8" title="1">{
                config.Offset = 0
        }</span>

        // Handle offset beyond length
        <span class="cov8" title="1">if config.Offset &gt;= len(tools) </span><span class="cov8" title="1">{
                return []parser.ToolCall{}
        }</span>

        <span class="cov8" title="1">start := config.Offset
        end := len(tools)

        // Apply limit if specified and positive
        if config.Limit &gt; 0 </span><span class="cov8" title="1">{
                end = start + config.Limit
                if end &gt; len(tools) </span><span class="cov8" title="1">{
                        end = len(tools)
                }</span>
        }

        <span class="cov8" title="1">return tools[start:end]</span>
}

// CalculateMetadata calculates pagination metadata
func CalculateMetadata(totalRecords int, config PaginationConfig) PaginationMetadata <span class="cov8" title="1">{
        // Handle negative offset
        if config.Offset &lt; 0 </span><span class="cov0" title="0">{
                config.Offset = 0
        }</span>

        // Calculate returned records
        <span class="cov8" title="1">returned := totalRecords - config.Offset
        if config.Limit &gt; 0 &amp;&amp; returned &gt; config.Limit </span><span class="cov8" title="1">{
                returned = config.Limit
        }</span>
        <span class="cov8" title="1">if returned &lt; 0 </span><span class="cov8" title="1">{
                returned = 0
        }</span>

        // Calculate hasMore
        <span class="cov8" title="1">hasMore := false
        if config.Limit &gt; 0 </span><span class="cov8" title="1">{
                hasMore = config.Offset+config.Limit &lt; totalRecords
        }</span>

        <span class="cov8" title="1">return PaginationMetadata{
                TotalRecords:    totalRecords,
                ReturnedRecords: returned,
                Offset:          config.Offset,
                Limit:           config.Limit,
                HasMore:         hasMore,
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package filter

import (
        "fmt"
        "strconv"
        "strings"
)

// ParseExpression parses a filter expression string into an Expression tree
func ParseExpression(expr string) (Expression, error) <span class="cov8" title="1">{
        expr = strings.TrimSpace(expr)
        if expr == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("empty expression")
        }</span>

        <span class="cov8" title="1">parser := &amp;ExpressionParser{
                input: expr,
                pos:   0,
        }

        return parser.parse()</span>
}

// ExpressionParser is a simple recursive descent parser
type ExpressionParser struct {
        input string
        pos   int
}

func (p *ExpressionParser) parse() (Expression, error) <span class="cov8" title="1">{
        return p.parseOr()
}</span>

func (p *ExpressionParser) parseOr() (Expression, error) <span class="cov8" title="1">{
        left, err := p.parseAnd()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for p.matchKeyword("OR") </span><span class="cov8" title="1">{
                right, err := p.parseAnd()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">left = &amp;BinaryExpression{
                        Operator: "OR",
                        Left:     left,
                        Right:    right,
                }</span>
        }

        <span class="cov8" title="1">return left, nil</span>
}

func (p *ExpressionParser) parseAnd() (Expression, error) <span class="cov8" title="1">{
        left, err := p.parseUnary()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for p.matchKeyword("AND") </span><span class="cov8" title="1">{
                right, err := p.parseUnary()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">left = &amp;BinaryExpression{
                        Operator: "AND",
                        Left:     left,
                        Right:    right,
                }</span>
        }

        <span class="cov8" title="1">return left, nil</span>
}

func (p *ExpressionParser) parseUnary() (Expression, error) <span class="cov8" title="1">{
        if p.matchKeyword("NOT") </span><span class="cov8" title="1">{
                operand, err := p.parsePrimary()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;UnaryExpression{
                        Operator: "NOT",
                        Operand:  operand,
                }, nil</span>
        }

        <span class="cov8" title="1">return p.parsePrimary()</span>
}

func (p *ExpressionParser) parsePrimary() (Expression, error) <span class="cov8" title="1">{
        p.skipWhitespace()

        // Handle parenthesized expressions
        if p.match("(") </span><span class="cov8" title="1">{
                expr, err := p.parse()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !p.match(")") </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("missing closing parenthesis")
                }</span>
                <span class="cov8" title="1">return expr, nil</span>
        }

        // Parse field name
        <span class="cov8" title="1">field := p.parseIdentifier()
        if field == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected field name at position %d", p.pos)
        }</span>

        <span class="cov8" title="1">p.skipWhitespace()

        // Check for special operators
        if p.match("IN (") </span><span class="cov8" title="1">{
                values, err := p.parseValueList()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;InExpression{Field: field, Values: values, Negate: false}, nil</span>
        }

        <span class="cov8" title="1">if p.match("NOT IN (") </span><span class="cov8" title="1">{
                values, err := p.parseValueList()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;InExpression{Field: field, Values: values, Negate: true}, nil</span>
        }

        <span class="cov8" title="1">if p.match("BETWEEN ") </span><span class="cov8" title="1">{
                lower, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">p.skipWhitespace()
                // Match AND (without leading/trailing space check to avoid conflict with boolean AND)
                if !p.matchExact("AND") </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("BETWEEN requires AND")
                }</span>
                <span class="cov8" title="1">p.skipWhitespace()
                upper, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;BetweenExpression{Field: field, Lower: lower, Upper: upper}, nil</span>
        }

        <span class="cov8" title="1">if p.match("LIKE ") </span><span class="cov8" title="1">{
                pattern, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">patternStr, ok := pattern.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("LIKE pattern must be a string")
                }</span>
                <span class="cov8" title="1">return &amp;LikeExpression{Field: field, Pattern: patternStr}, nil</span>
        }

        <span class="cov8" title="1">if p.match("REGEXP ") </span><span class="cov8" title="1">{
                pattern, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">patternStr, ok := pattern.(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("REGEXP pattern must be a string")
                }</span>
                <span class="cov8" title="1">return &amp;RegexpExpression{Field: field, Pattern: patternStr}, nil</span>
        }

        // Parse comparison operator
        <span class="cov8" title="1">var op string
        if p.match("!=") </span><span class="cov8" title="1">{
                op = "!="
        }</span> else<span class="cov8" title="1"> if p.match("&gt;=") </span><span class="cov0" title="0">{
                op = "&gt;="
        }</span> else<span class="cov8" title="1"> if p.match("&lt;=") </span><span class="cov8" title="1">{
                op = "&lt;="
        }</span> else<span class="cov8" title="1"> if p.match("=") </span><span class="cov8" title="1">{
                op = "="
        }</span> else<span class="cov8" title="1"> if p.match("&gt;") </span><span class="cov8" title="1">{
                op = "&gt;"
        }</span> else<span class="cov8" title="1"> if p.match("&lt;") </span><span class="cov0" title="0">{
                op = "&lt;"
        }</span> else<span class="cov8" title="1"> {
                return nil, fmt.Errorf("expected operator at position %d", p.pos)
        }</span>

        <span class="cov8" title="1">value, err := p.parseValue()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ComparisonExpression{Field: field, Operator: op, Value: value}, nil</span>
}

func (p *ExpressionParser) parseIdentifier() string <span class="cov8" title="1">{
        p.skipWhitespace()
        start := p.pos

        for p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                ch := p.input[p.pos]
                if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= '0' &amp;&amp; ch &lt;= '9') || ch == '_' </span><span class="cov8" title="1">{
                        p.pos++
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">return p.input[start:p.pos]</span>
}

func (p *ExpressionParser) parseValue() (interface{}, error) <span class="cov8" title="1">{
        p.skipWhitespace()

        if p.pos &gt;= len(p.input) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unexpected end of input")
        }</span>

        // String value (quoted)
        <span class="cov8" title="1">if p.input[p.pos] == '\'' </span><span class="cov8" title="1">{
                return p.parseQuotedString()
        }</span>

        // Numeric value
        <span class="cov8" title="1">start := p.pos
        for p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                ch := p.input[p.pos]
                if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') || ch == '.' || ch == '-' </span><span class="cov8" title="1">{
                        p.pos++
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">if p.pos &gt; start </span><span class="cov8" title="1">{
                numStr := p.input[start:p.pos]
                if num, err := strconv.ParseInt(numStr, 10, 64); err == nil </span><span class="cov8" title="1">{
                        return int(num), nil
                }</span>
                <span class="cov0" title="0">if num, err := strconv.ParseFloat(numStr, 64); err == nil </span><span class="cov0" title="0">{
                        return num, nil
                }</span>
                <span class="cov0" title="0">return numStr, nil</span> // Return as string if not numeric
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("expected value at position %d", p.pos)</span>
}

func (p *ExpressionParser) parseQuotedString() (string, error) <span class="cov8" title="1">{
        if p.pos &gt;= len(p.input) || p.input[p.pos] != '\'' </span><span class="cov0" title="0">{
                return "", fmt.Errorf("expected quoted string")
        }</span>

        <span class="cov8" title="1">p.pos++ // Skip opening quote
        start := p.pos

        for p.pos &lt; len(p.input) </span><span class="cov8" title="1">{
                if p.input[p.pos] == '\'' </span><span class="cov8" title="1">{
                        str := p.input[start:p.pos]
                        p.pos++ // Skip closing quote
                        return str, nil
                }</span>
                <span class="cov8" title="1">p.pos++</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("unclosed quote")</span>
}

func (p *ExpressionParser) parseValueList() ([]interface{}, error) <span class="cov8" title="1">{
        var values []interface{}

        for </span><span class="cov8" title="1">{
                p.skipWhitespace()
                value, err := p.parseValue()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">values = append(values, value)

                p.skipWhitespace()
                if p.match(",") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if p.match(")") </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("expected ',' or ')' in value list")</span>
        }

        <span class="cov8" title="1">return values, nil</span>
}

func (p *ExpressionParser) match(s string) bool <span class="cov8" title="1">{
        p.skipWhitespace()
        if strings.HasPrefix(p.input[p.pos:], s) </span><span class="cov8" title="1">{
                p.pos += len(s)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (p *ExpressionParser) matchKeyword(keyword string) bool <span class="cov8" title="1">{
        p.skipWhitespace()
        if strings.HasPrefix(p.input[p.pos:], keyword) </span><span class="cov8" title="1">{
                // Check word boundary (next char should be whitespace or end of input)
                endPos := p.pos + len(keyword)
                if endPos &lt; len(p.input) </span><span class="cov8" title="1">{
                        nextCh := p.input[endPos]
                        if !(nextCh == ' ' || nextCh == '\t' || nextCh == ')' || nextCh == '(') </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">p.pos = endPos
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (p *ExpressionParser) matchExact(s string) bool <span class="cov8" title="1">{
        if strings.HasPrefix(p.input[p.pos:], s) </span><span class="cov8" title="1">{
                p.pos += len(s)
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (p *ExpressionParser) skipWhitespace() <span class="cov8" title="1">{
        for p.pos &lt; len(p.input) &amp;&amp; (p.input[p.pos] == ' ' || p.input[p.pos] == '\t') </span><span class="cov8" title="1">{
                p.pos++
        }</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package filter

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/yale/meta-cc/internal/parser"
)

// TimeFilter represents time-based filtering options
type TimeFilter struct {
        Since      string // "5 minutes ago", "1 hour ago"
        LastNTurns int    // Last N entries
        FromTs     int64  // Unix timestamp (start)
        ToTs       int64  // Unix timestamp (end)
}

// Apply applies the time filter to session entries
func (f *TimeFilter) Apply(entries []parser.SessionEntry) ([]parser.SessionEntry, error) <span class="cov8" title="1">{
        // No filter, return all
        if f.Since == "" &amp;&amp; f.LastNTurns == 0 &amp;&amp; f.FromTs == 0 &amp;&amp; f.ToTs == 0 </span><span class="cov8" title="1">{
                return entries, nil
        }</span>

        // Handle LastNTurns first (simple slice operation)
        <span class="cov8" title="1">if f.LastNTurns &gt; 0 </span><span class="cov8" title="1">{
                if f.LastNTurns &gt;= len(entries) </span><span class="cov0" title="0">{
                        return entries, nil
                }</span>
                <span class="cov8" title="1">return entries[len(entries)-f.LastNTurns:], nil</span>
        }

        // Parse Since duration
        <span class="cov8" title="1">var cutoffTime time.Time
        if f.Since != "" </span><span class="cov8" title="1">{
                duration, err := ParseDuration(f.Since)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid --since format: %w", err)
                }</span>
                <span class="cov8" title="1">cutoffTime = time.Now().Add(-duration)</span>
        }

        // Filter by timestamp
        <span class="cov8" title="1">var result []parser.SessionEntry
        for _, entry := range entries </span><span class="cov8" title="1">{
                entryTime, err := time.Parse(time.RFC3339Nano, entry.Timestamp)
                if err != nil </span><span class="cov0" title="0">{
                        // Skip entries with invalid timestamps
                        continue</span>
                }

                // Check Since filter
                <span class="cov8" title="1">if f.Since != "" &amp;&amp; entryTime.Before(cutoffTime) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check FromTs filter
                <span class="cov8" title="1">if f.FromTs &gt; 0 &amp;&amp; entryTime.Unix() &lt; f.FromTs </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check ToTs filter
                <span class="cov8" title="1">if f.ToTs &gt; 0 &amp;&amp; entryTime.Unix() &gt; f.ToTs </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">result = append(result, entry)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// ParseDuration parses human-readable duration strings like "5 minutes ago"
func ParseDuration(s string) (time.Duration, error) <span class="cov8" title="1">{
        // Expected format: "&lt;number&gt; &lt;unit&gt; ago"
        // Examples: "5 minutes ago", "1 hour ago", "30 seconds ago"

        s = strings.ToLower(strings.TrimSpace(s))

        if !strings.HasSuffix(s, " ago") </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("duration must end with ' ago'")
        }</span>

        // Remove " ago" suffix
        <span class="cov8" title="1">s = strings.TrimSuffix(s, " ago")
        s = strings.TrimSpace(s)

        // Split into number and unit
        parts := strings.Fields(s)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid duration format (expected '&lt;number&gt; &lt;unit&gt; ago')")
        }</span>

        // Parse number
        <span class="cov8" title="1">num, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid number: %w", err)
        }</span>

        // Parse unit
        <span class="cov8" title="1">unit := parts[1]

        // Handle plural forms
        if strings.HasSuffix(unit, "s") &amp;&amp; len(unit) &gt; 1 </span><span class="cov8" title="1">{
                unit = unit[:len(unit)-1]
        }</span>

        <span class="cov8" title="1">var duration time.Duration
        switch unit </span>{
        case "second":<span class="cov8" title="1">
                duration = time.Duration(num) * time.Second</span>
        case "minute":<span class="cov8" title="1">
                duration = time.Duration(num) * time.Minute</span>
        case "hour":<span class="cov8" title="1">
                duration = time.Duration(num) * time.Hour</span>
        case "day":<span class="cov0" title="0">
                duration = time.Duration(num) * 24 * time.Hour</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unknown time unit: %s", unit)</span>
        }

        <span class="cov8" title="1">return duration, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package locator

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

// FromSessionID 通过会话 ID 查找会话文件
// 遍历 ~/.claude/projects/*/，查找匹配的 {session-id}.jsonl
// 如果找到多个（跨项目同名会话），返回最新的
func (l *SessionLocator) FromSessionID(sessionID string) (string, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">projectsRoot := filepath.Join(homeDir, ".claude", "projects")
        if _, err := os.Stat(projectsRoot); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Claude Code projects directory not found: %s", projectsRoot)
        }</span>

        // 遍历所有项目目录
        <span class="cov8" title="1">projectDirs, err := os.ReadDir(projectsRoot)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read projects directory: %w", err)
        }</span>

        <span class="cov8" title="1">var candidates []string
        sessionFilename := sessionID + ".jsonl"

        for _, projectDir := range projectDirs </span><span class="cov8" title="1">{
                if !projectDir.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">sessionPath := filepath.Join(projectsRoot, projectDir.Name(), sessionFilename)
                if _, err := os.Stat(sessionPath); err == nil </span><span class="cov8" title="1">{
                        candidates = append(candidates, sessionPath)
                }</span>
        }

        <span class="cov8" title="1">if len(candidates) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("session file not found for ID: %s", sessionID)
        }</span>

        // 如果找到多个，返回最新的
        <span class="cov8" title="1">return findNewestFile(candidates)</span>
}

// FromProjectPath 通过项目路径查找最新会话
// 1. 将项目路径转换为哈希（/ → -）
// 2. 定位 ~/.claude/projects/{hash}/
// 3. 返回该目录下最新的 .jsonl 文件
func (l *SessionLocator) FromProjectPath(projectPath string) (string, error) <span class="cov8" title="1">{
        // 解析相对路径为绝对路径（如 "." -&gt; "/home/yale/work/meta-cc"）
        absPath, err := filepath.Abs(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to resolve project path: %w", err)
        }</span>

        // 计算项目哈希
        <span class="cov8" title="1">projectHash := pathToHash(absPath)

        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">sessionDir := filepath.Join(homeDir, ".claude", "projects", projectHash)
        if _, err := os.Stat(sessionDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no sessions found for project: %s (hash: %s)", projectPath, projectHash)
        }</span>

        // 查找所有 .jsonl 文件
        <span class="cov8" title="1">sessions, err := filepath.Glob(filepath.Join(sessionDir, "*.jsonl"))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to search session files: %w", err)
        }</span>

        <span class="cov8" title="1">if len(sessions) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no session files found in: %s", sessionDir)
        }</span>

        // 返回最新的会话文件
        <span class="cov8" title="1">return findNewestFile(sessions)</span>
}

// AllSessionsFromProject 通过项目路径查找所有会话文件
// 1. 将项目路径转换为哈希（/ → -）
// 2. 定位 ~/.claude/projects/{hash}/
// 3. 返回该目录下所有 .jsonl 文件的路径
func (l *SessionLocator) AllSessionsFromProject(projectPath string) ([]string, error) <span class="cov8" title="1">{
        // 解析相对路径为绝对路径（如 "." -&gt; "/home/yale/work/meta-cc"）
        absPath, err := filepath.Abs(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve project path: %w", err)
        }</span>

        // 计算项目哈希
        <span class="cov8" title="1">projectHash := pathToHash(absPath)

        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">sessionDir := filepath.Join(homeDir, ".claude", "projects", projectHash)
        if _, err := os.Stat(sessionDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no sessions found for project: %s (hash: %s)", projectPath, projectHash)
        }</span>

        // 查找所有 .jsonl 文件
        <span class="cov8" title="1">sessions, err := filepath.Glob(filepath.Join(sessionDir, "*.jsonl"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search session files: %w", err)
        }</span>

        <span class="cov8" title="1">if len(sessions) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no session files found in: %s", sessionDir)
        }</span>

        // 返回所有会话文件
        <span class="cov8" title="1">return sessions, nil</span>
}

// pathToHash 将项目路径转换为哈希目录名
// 例如：/home/yale/work/myproject → -home-yale-work-myproject
func pathToHash(path string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(path, "/", "-")
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package locator

import (
        "fmt"
        "os"
        "path/filepath"
)

// SessionLocator 负责定位会话文件
type SessionLocator struct{}

// NewSessionLocator 创建 SessionLocator 实例
func NewSessionLocator() *SessionLocator <span class="cov8" title="1">{
        return &amp;SessionLocator{}
}</span>

// FromEnv 从环境变量读取会话 ID 和项目哈希，构造文件路径
// 环境变量：
//   - CC_SESSION_ID: 会话 UUID
//   - CC_PROJECT_HASH: 项目路径哈希（已转换，如 -home-yale-work-myproject）
//
// 返回：
//   - 会话文件的完整路径
//   - 错误（如果环境变量缺失或文件不存在）
func (l *SessionLocator) FromEnv() (string, error) <span class="cov8" title="1">{
        sessionID := os.Getenv("CC_SESSION_ID")
        if sessionID == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("CC_SESSION_ID environment variable not set")
        }</span>

        <span class="cov8" title="1">projectHash := os.Getenv("CC_PROJECT_HASH")
        if projectHash == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("CC_PROJECT_HASH environment variable not set")
        }</span>

        // 构造会话文件路径
        <span class="cov8" title="1">homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">sessionPath := filepath.Join(
                homeDir,
                ".claude",
                "projects",
                projectHash,
                fmt.Sprintf("%s.jsonl", sessionID),
        )

        // 验证文件存在
        if _, err := os.Stat(sessionPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("session file not found: %s", sessionPath)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to access session file: %w", err)
        }</span>

        <span class="cov8" title="1">return sessionPath, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package locator

import (
        "fmt"
        "os"
)

// findNewestFile 返回文件列表中修改时间最新的文件
func findNewestFile(files []string) (string, error) <span class="cov8" title="1">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file list is empty")
        }</span>

        <span class="cov8" title="1">var newestFile string
        var newestTime int64

        for _, file := range files </span><span class="cov8" title="1">{
                info, err := os.Stat(file)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">modTime := info.ModTime().Unix()
                if modTime &gt; newestTime </span><span class="cov8" title="1">{
                        newestTime = modTime
                        newestFile = file
                }</span>
        }

        <span class="cov8" title="1">if newestFile == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no accessible files found")
        }</span>

        <span class="cov8" title="1">return newestFile, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package locator

import (
        "fmt"
        "os"
)

// LocateOptions 定位选项
type LocateOptions struct {
        SessionID   string // 命令行参数 --session
        ProjectPath string // 命令行参数 --project
        SessionOnly bool   // Phase 13: 强制仅分析当前会话（禁用项目级默认行为）
}

// Locate 统一的会话文件定位入口
// Phase 13: 默认使用项目级分析（--project .），除非设置 --session-only
// 按优先级尝试以下策略：
//
//  1. 环境变量 CC_SESSION_ID + CC_PROJECT_HASH (仅当 --session-only 时)
//  2. 命令行参数 --session
//  3. 命令行参数 --project
//  4. 默认：当前工作目录（Phase 13: 项目级默认）
func (l *SessionLocator) Locate(opts LocateOptions) (string, error) <span class="cov8" title="1">{
        // 策略1: 环境变量（仅在 --session-only 模式下）
        if !opts.SessionOnly &amp;&amp; os.Getenv("CC_SESSION_ID") != "" </span><span class="cov0" title="0">{
                path, err := l.FromEnv()
                if err == nil </span><span class="cov0" title="0">{
                        return path, nil
                }</span>
                // 环境变量设置了但失败，记录警告但继续尝试其他策略
        }

        // 策略2: --session 参数
        <span class="cov8" title="1">if opts.SessionID != "" </span><span class="cov0" title="0">{
                path, err := l.FromSessionID(opts.SessionID)
                if err == nil </span><span class="cov0" title="0">{
                        return path, nil
                }</span>
                // 明确指定了 session 但找不到，直接返回错误
                <span class="cov0" title="0">return "", fmt.Errorf("session ID %q not found: %w", opts.SessionID, err)</span>
        }

        // Phase 13: 默认使用当前工作目录作为项目路径（除非明确指定 --project）
        <span class="cov8" title="1">projectPath := opts.ProjectPath
        if projectPath == "" &amp;&amp; !opts.SessionOnly </span><span class="cov8" title="1">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get current directory: %w", err)
                }</span>
                <span class="cov8" title="1">projectPath = cwd</span>
        }

        // 策略3: --project 参数或默认项目路径
        <span class="cov8" title="1">if projectPath != "" </span><span class="cov8" title="1">{
                path, err := l.FromProjectPath(projectPath)
                if err == nil </span><span class="cov0" title="0">{
                        return path, nil
                }</span>
                // 明确指定了 project 但找不到，直接返回错误
                <span class="cov8" title="1">return "", fmt.Errorf("no sessions found for project %q: %w", projectPath, err)</span>
        }

        // 策略4: --session-only 模式下的后备策略（环境变量检测）
        <span class="cov0" title="0">if opts.SessionOnly &amp;&amp; os.Getenv("CC_SESSION_ID") != "" </span><span class="cov0" title="0">{
                path, err := l.FromEnv()
                if err == nil </span><span class="cov0" title="0">{
                        return path, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("failed to locate session file: tried session ID, project path, and env vars")</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package mcp

import (
        "fmt"
)

// Semantic default limits (Phase 9 + Phase 14 standardization)
const (
        DefaultLimitSmall  = 10  // user messages, prompts (high signal)
        DefaultLimitMedium = 20  // tool calls (moderate signal)
        DefaultLimitLarge  = 100 // extract operations (bulk data)
)

// CommandBuilder provides fluent interface for building meta-cc commands
// Reduces duplication and improves maintainability (Phase 14 refactoring)
type CommandBuilder struct {
        baseCmd      []string               // Base command parts (e.g., ["query", "tools"])
        scope        string                 // "project" or "session" (default: "session")
        filters      map[string]string      // Key-value filters (e.g., "tool" -&gt; "Bash")
        params       map[string]string      // Required parameters (e.g., "match" -&gt; "pattern")
        limit        int                    // Result limit (0 = no limit)
        outputFormat string                 // Output format (default: "jsonl")
        extraFlags   map[string]interface{} // Additional flags (window, min-occurrences, etc.)
}

// NewCommandBuilder creates a new command builder with base command parts
func NewCommandBuilder(parts ...string) *CommandBuilder <span class="cov8" title="1">{
        return &amp;CommandBuilder{
                baseCmd:      parts,
                scope:        "project", // Default to project scope (Phase 12: cross-session analysis)
                filters:      make(map[string]string),
                params:       make(map[string]string),
                outputFormat: "jsonl", // Phase 13: default to jsonl
                extraFlags:   make(map[string]interface{}),
        }
}</span>

// WithScope sets the scope (project or session)
// Project scope adds "--project ." prefix to command
func (b *CommandBuilder) WithScope(scope string) *CommandBuilder <span class="cov8" title="1">{
        b.scope = scope
        return b
}</span>

// WithFilter adds a filter flag (e.g., --tool, --status)
func (b *CommandBuilder) WithFilter(key, value string) *CommandBuilder <span class="cov8" title="1">{
        if value != "" </span><span class="cov8" title="1">{
                b.filters[key] = value
        }</span>
        <span class="cov8" title="1">return b</span>
}

// WithRequiredParam adds a required parameter (e.g., --match for user-messages)
func (b *CommandBuilder) WithRequiredParam(key, value string) *CommandBuilder <span class="cov8" title="1">{
        b.params[key] = value
        return b
}</span>

// WithLimit sets the result limit
func (b *CommandBuilder) WithLimit(limit int) *CommandBuilder <span class="cov8" title="1">{
        b.limit = limit
        return b
}</span>

// WithOutputFormat sets the output format
func (b *CommandBuilder) WithOutputFormat(format string) *CommandBuilder <span class="cov8" title="1">{
        if format != "" </span><span class="cov8" title="1">{
                b.outputFormat = format
        }</span>
        <span class="cov8" title="1">return b</span>
}

// WithExtraFlag adds additional flags (e.g., --window, --min-occurrences)
func (b *CommandBuilder) WithExtraFlag(key string, value interface{}) *CommandBuilder <span class="cov0" title="0">{
        b.extraFlags[key] = value
        return b
}</span>

// Build constructs the final command array
func (b *CommandBuilder) Build() []string <span class="cov8" title="1">{
        cmd := []string{}

        // Add project scope prefix if needed
        if b.scope == "project" </span><span class="cov8" title="1">{
                cmd = append(cmd, "--project", ".")
        }</span>

        // Add base command
        <span class="cov8" title="1">cmd = append(cmd, b.baseCmd...)

        // Add required parameters first
        for key, value := range b.params </span><span class="cov8" title="1">{
                cmd = append(cmd, "--"+key, value)
        }</span>

        // Add filters
        <span class="cov8" title="1">for key, value := range b.filters </span><span class="cov8" title="1">{
                cmd = append(cmd, "--"+key, value)
        }</span>

        // Add extra flags
        <span class="cov8" title="1">for key, value := range b.extraFlags </span><span class="cov0" title="0">{
                cmd = append(cmd, "--"+key, fmt.Sprintf("%v", value))
        }</span>

        // Add limit if non-zero
        <span class="cov8" title="1">if b.limit &gt; 0 </span><span class="cov8" title="1">{
                cmd = append(cmd, "--limit", fmt.Sprintf("%d", b.limit))
        }</span>

        // Add output format at the end
        <span class="cov8" title="1">cmd = append(cmd, "--output", b.outputFormat)

        return cmd</span>
}

// BuildToolCommand builds a command from MCP tool name and arguments
// This is the main entry point for MCP server integration
func BuildToolCommand(toolName string, args map[string]interface{}) ([]string, error) <span class="cov8" title="1">{
        // Extract common parameters
        outputFormat := getStringArg(args, "output_format", "jsonl")
        scope := getStringArg(args, "scope", "project") // Phase 12: default to project for cross-session analysis

        // Route to appropriate builder based on tool name
        switch toolName </span>{
        case "get_session_stats":<span class="cov8" title="1">
                // Backward compatibility: always session-only
                return NewCommandBuilder("parse", "stats").
                        WithScope("session").
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "analyze_errors":<span class="cov0" title="0">
                // Phase 14.2: Deprecated - redirect to query errors
                // TODO: Remove in future version, use query_errors directly
                return NewCommandBuilder("query", "errors").
                        WithScope(scope).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "extract_tools":<span class="cov0" title="0">
                limit := getIntArg(args, "limit", DefaultLimitLarge)
                return NewCommandBuilder("query", "tools").
                        WithScope(scope).
                        WithLimit(limit).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "query_tools":<span class="cov8" title="1">
                tool := getStringArg(args, "tool", "")
                status := getStringArg(args, "status", "")
                limit := getIntArg(args, "limit", DefaultLimitMedium)

                return NewCommandBuilder("query", "tools").
                        WithScope(scope).
                        WithFilter("tool", tool).
                        WithFilter("status", status).
                        WithLimit(limit).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "query_user_messages":<span class="cov8" title="1">
                pattern := getStringArg(args, "pattern", "")
                if pattern == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("pattern parameter is required")
                }</span>
                <span class="cov0" title="0">limit := getIntArg(args, "limit", DefaultLimitSmall)

                return NewCommandBuilder("query", "user-messages").
                        WithScope(scope).
                        WithRequiredParam("match", pattern).
                        WithLimit(limit).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "query_context":<span class="cov0" title="0">
                errorSignature := getStringArg(args, "error_signature", "")
                if errorSignature == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error_signature parameter is required")
                }</span>
                <span class="cov0" title="0">window := getIntArg(args, "window", 3)

                return NewCommandBuilder("query", "context").
                        WithScope(scope).
                        WithRequiredParam("error-signature", errorSignature).
                        WithExtraFlag("window", window).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "query_tool_sequences":<span class="cov0" title="0">
                minOccurrences := getIntArg(args, "min_occurrences", 3)
                pattern := getStringArg(args, "pattern", "")

                builder := NewCommandBuilder("query", "tool-sequences").
                        WithScope(scope).
                        WithExtraFlag("min-occurrences", minOccurrences).
                        WithOutputFormat(outputFormat)

                if pattern != "" </span><span class="cov0" title="0">{
                        builder.WithExtraFlag("pattern", pattern)
                }</span>

                <span class="cov0" title="0">return builder.Build(), nil</span>

        case "query_file_access":<span class="cov0" title="0">
                file := getStringArg(args, "file", "")
                if file == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("file parameter is required")
                }</span>

                <span class="cov0" title="0">return NewCommandBuilder("query", "file-access").
                        WithScope(scope).
                        WithRequiredParam("file", file).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "query_project_state":<span class="cov0" title="0">
                return NewCommandBuilder("query", "project-state").
                        WithScope(scope).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "query_successful_prompts":<span class="cov0" title="0">
                minQualityScore := getFloatArg(args, "min_quality_score", 0.8)
                limit := getIntArg(args, "limit", DefaultLimitSmall)

                return NewCommandBuilder("query", "successful-prompts").
                        WithScope(scope).
                        WithExtraFlag("min-quality-score", fmt.Sprintf("%.2f", minQualityScore)).
                        WithLimit(limit).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        // Phase 10: Advanced query tools
        case "query_tools_advanced":<span class="cov0" title="0">
                where := getStringArg(args, "where", "")
                if where == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("where parameter is required")
                }</span>
                <span class="cov0" title="0">limit := getIntArg(args, "limit", DefaultLimitMedium)

                return NewCommandBuilder("query", "tools").
                        WithScope(scope).
                        WithFilter("filter", where).
                        WithLimit(limit).
                        WithOutputFormat(outputFormat).
                        Build(), nil</span>

        case "aggregate_stats":<span class="cov0" title="0">
                groupBy := getStringArg(args, "group_by", "tool")
                metrics := getStringArg(args, "metrics", "count,error_rate")
                where := getStringArg(args, "where", "")

                builder := NewCommandBuilder("stats", "aggregate").
                        WithScope(scope).
                        WithExtraFlag("group-by", groupBy).
                        WithExtraFlag("metrics", metrics).
                        WithOutputFormat(outputFormat)

                if where != "" </span><span class="cov0" title="0">{
                        builder.WithFilter("filter", where)
                }</span>

                <span class="cov0" title="0">return builder.Build(), nil</span>

        case "query_time_series":<span class="cov0" title="0">
                metric := getStringArg(args, "metric", "tool-calls")
                interval := getStringArg(args, "interval", "hour")
                where := getStringArg(args, "where", "")

                builder := NewCommandBuilder("stats", "time-series").
                        WithScope(scope).
                        WithExtraFlag("metric", metric).
                        WithExtraFlag("interval", interval).
                        WithOutputFormat(outputFormat)

                if where != "" </span><span class="cov0" title="0">{
                        builder.WithFilter("filter", where)
                }</span>

                <span class="cov0" title="0">return builder.Build(), nil</span>

        case "query_files":<span class="cov0" title="0">
                sortBy := getStringArg(args, "sort_by", "total_ops")
                top := getIntArg(args, "top", DefaultLimitMedium)
                where := getStringArg(args, "where", "")

                builder := NewCommandBuilder("stats", "files").
                        WithScope(scope).
                        WithExtraFlag("sort-by", sortBy).
                        WithExtraFlag("top", top).
                        WithOutputFormat(outputFormat)

                if where != "" </span><span class="cov0" title="0">{
                        builder.WithFilter("filter", where)
                }</span>

                <span class="cov0" title="0">return builder.Build(), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown tool: %s", toolName)</span>
        }
}

// Helper functions to extract typed arguments from map[string]interface{}

func getStringArg(args map[string]interface{}, key, defaultValue string) string <span class="cov8" title="1">{
        if val, ok := args[key].(string); ok </span><span class="cov8" title="1">{
                return val
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

func getIntArg(args map[string]interface{}, key string, defaultValue int) int <span class="cov8" title="1">{
        if val, ok := args[key].(float64); ok </span><span class="cov8" title="1">{
                return int(val)
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getFloatArg(args map[string]interface{}, key string, defaultValue float64) float64 <span class="cov0" title="0">{
        if val, ok := args[key].(float64); ok </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package mcp

import (
        "fmt"
)

// ToolDefinition represents an MCP tool with its metadata
type ToolDefinition struct {
        Name        string
        Description string
        InputSchema interface{}
}

// Session-level tool definitions (query current session only, with _session suffix)

var sessionLevelTools = map[string]*ToolDefinition{
        "query_tools_session": {
                Name:        "query_tools_session",
                Description: "Query tool calls in the current session only. For project-level queries, use query_tools.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Maximum number of tool calls to return (default: 20)",
                                },
                                "tool": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Filter by tool name (e.g., 'Bash', 'Read', 'Edit')",
                                },
                                "status": map[string]interface{}{
                                        "type":        "string",
                                        "enum":        []string{"success", "error"},
                                        "description": "Filter by execution status",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "query_user_messages_session": {
                Name:        "query_user_messages_session",
                Description: "Search user messages in the current session only using regex pattern matching.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "pattern": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Regex pattern to match in message content (required)",
                                },
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "default":     10,
                                        "description": "Maximum number of results (default: 10)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                        "required": []interface{}{"pattern"},
                },
        },
        "analyze_errors_session": {
                Name:        "analyze_errors_session",
                Description: "Analyze error patterns in the current session only.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "query_tool_sequences_session": {
                Name:        "query_tool_sequences_session",
                Description: "Query repeated tool call sequences (workflow patterns) in the current session only.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "pattern": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Specific sequence pattern to match (e.g., 'Read -&gt; Edit -&gt; Bash')",
                                },
                                "min_occurrences": map[string]interface{}{
                                        "type":        "integer",
                                        "default":     3,
                                        "description": "Minimum occurrences to report (default 3)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "query_file_access_session": {
                Name:        "query_file_access_session",
                Description: "Query file access history (read/edit/write operations) in the current session only.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "file": map[string]interface{}{
                                        "type":        "string",
                                        "description": "File path to query (required)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                        "required": []interface{}{"file"},
                },
        },
        "query_successful_prompts_session": {
                Name:        "query_successful_prompts_session",
                Description: "Query successful prompt patterns in the current session only.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "default":     10,
                                        "description": "Maximum number of results (default 10)",
                                },
                                "min_quality_score": map[string]interface{}{
                                        "type":        "number",
                                        "default":     0.8,
                                        "description": "Minimum quality score (0.0-1.0, default 0.8)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "query_context_session": {
                Name:        "query_context_session",
                Description: "Query context around specific errors in the current session only.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "error_signature": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Error pattern ID to query (required)",
                                },
                                "window": map[string]interface{}{
                                        "type":        "integer",
                                        "default":     3,
                                        "description": "Context window size in turns before/after (default 3)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                        "required": []interface{}{"error_signature"},
                },
        },
        "get_session_stats": {
                Name:        "get_session_stats",
                Description: "Get statistics for the current Claude Code session",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
}

// GetToolDefinition returns a tool definition by name
func GetToolDefinition(name string) *ToolDefinition <span class="cov8" title="1">{
        return sessionLevelTools[name]
}</span>

// ListAllTools returns all registered session-level tools
func ListAllTools() []*ToolDefinition <span class="cov8" title="1">{
        tools := make([]*ToolDefinition, 0, len(sessionLevelTools))
        for _, tool := range sessionLevelTools </span><span class="cov8" title="1">{
                tools = append(tools, tool)
        }</span>
        <span class="cov8" title="1">return tools</span>
}

// BuildCommandArgs builds CLI command arguments for a session-level tool
// Session-level tools do NOT include --project flag
func BuildCommandArgs(toolName string, args map[string]interface{}) []string <span class="cov8" title="1">{
        outputFormat := "json"
        if format, ok := args["output_format"].(string); ok </span><span class="cov8" title="1">{
                outputFormat = format
        }</span>

        <span class="cov8" title="1">var cmdArgs []string

        switch toolName </span>{
        case "get_session_stats":<span class="cov0" title="0">
                cmdArgs = []string{"parse", "stats", "--output", outputFormat}</span>

        case "analyze_errors_session":<span class="cov8" title="1">
                cmdArgs = []string{"analyze", "errors", "--output", outputFormat}</span>

        case "query_tools_session":<span class="cov8" title="1">
                cmdArgs = []string{"query", "tools", "--output", outputFormat}

                if tool, ok := args["tool"].(string); ok &amp;&amp; tool != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--tool", tool)
                }</span>
                <span class="cov8" title="1">if status, ok := args["status"].(string); ok &amp;&amp; status != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--status", status)
                }</span>
                <span class="cov8" title="1">if limit, ok := args["limit"].(float64); ok </span><span class="cov8" title="1">{
                        cmdArgs = append(cmdArgs, "--limit", fmt.Sprintf("%.0f", limit))
                }</span> else<span class="cov0" title="0"> {
                        cmdArgs = append(cmdArgs, "--limit", "20")
                }</span>

        case "query_user_messages_session":<span class="cov0" title="0">
                pattern, ok := args["pattern"].(string)
                if !ok || pattern == "" </span><span class="cov0" title="0">{
                        return []string{"error", "pattern parameter is required"}
                }</span>

                <span class="cov0" title="0">cmdArgs = []string{"query", "user-messages", "--match", pattern, "--output", outputFormat}

                if limit, ok := args["limit"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--limit", fmt.Sprintf("%.0f", limit))
                }</span> else<span class="cov0" title="0"> {
                        cmdArgs = append(cmdArgs, "--limit", "10")
                }</span>

        case "query_context_session":<span class="cov0" title="0">
                errorSignature, ok := args["error_signature"].(string)
                if !ok || errorSignature == "" </span><span class="cov0" title="0">{
                        return []string{"error", "error_signature parameter is required"}
                }</span>

                <span class="cov0" title="0">cmdArgs = []string{"query", "context", "--error-signature", errorSignature, "--output", outputFormat}

                if window, ok := args["window"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--window", fmt.Sprintf("%.0f", window))
                }</span> else<span class="cov0" title="0"> {
                        cmdArgs = append(cmdArgs, "--window", "3")
                }</span>

        case "query_tool_sequences_session":<span class="cov0" title="0">
                cmdArgs = []string{"query", "tool-sequences", "--output", outputFormat}

                if minOccurrences, ok := args["min_occurrences"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--min-occurrences", fmt.Sprintf("%.0f", minOccurrences))
                }</span> else<span class="cov0" title="0"> {
                        cmdArgs = append(cmdArgs, "--min-occurrences", "3")
                }</span>
                <span class="cov0" title="0">if pattern, ok := args["pattern"].(string); ok &amp;&amp; pattern != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--pattern", pattern)
                }</span>

        case "query_file_access_session":<span class="cov0" title="0">
                file, ok := args["file"].(string)
                if !ok || file == "" </span><span class="cov0" title="0">{
                        return []string{"error", "file parameter is required"}
                }</span>

                <span class="cov0" title="0">cmdArgs = []string{"query", "file-access", "--file", file, "--output", outputFormat}</span>

        case "query_successful_prompts_session":<span class="cov0" title="0">
                cmdArgs = []string{"query", "successful-prompts", "--output", outputFormat}

                if minQualityScore, ok := args["min_quality_score"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--min-quality-score", fmt.Sprintf("%.2f", minQualityScore))
                }</span>
                <span class="cov0" title="0">if limit, ok := args["limit"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--limit", fmt.Sprintf("%.0f", limit))
                }</span> else<span class="cov0" title="0"> {
                        cmdArgs = append(cmdArgs, "--limit", "10")
                }</span>

        default:<span class="cov0" title="0">
                return []string{"error", "unknown tool: " + toolName}</span>
        }

        <span class="cov8" title="1">return cmdArgs</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package mcp

import (
        "fmt"
)

// Project-level tool definitions (query all sessions in project, NO _session suffix)

var projectLevelTools = map[string]*ToolDefinition{
        "query_tools": {
                Name:        "query_tools",
                Description: "Query tool calls across all sessions in the project. Returns tool execution history, status, duration, and errors.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "description": "Maximum number of tool calls to return (default: 20)",
                                },
                                "tool": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Filter by tool name (e.g., 'Bash', 'Edit', 'Read')",
                                },
                                "status": map[string]interface{}{
                                        "type":        "string",
                                        "enum":        []string{"success", "error"},
                                        "description": "Filter by execution status",
                                },
                                "where": map[string]interface{}{
                                        "type":        "string",
                                        "description": "SQL-like filter expression",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "query_user_messages": {
                Name:        "query_user_messages",
                Description: "Search user messages across all sessions in the project using regex pattern matching.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "pattern": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Regex pattern to match in message content (required)",
                                },
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "default":     10,
                                        "description": "Maximum number of results (default: 10)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                        "required": []interface{}{"pattern"},
                },
        },
        "get_stats": {
                Name:        "get_stats",
                Description: "Get statistics for all sessions in the project. Returns tool usage counts, error rates, and session metrics.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "analyze_errors": {
                Name:        "analyze_errors",
                Description: "Analyze error patterns across all sessions in the project. Detects repeated errors and common failure modes.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "query_tool_sequences": {
                Name:        "query_tool_sequences",
                Description: "Query repeated tool call sequences (workflow patterns) across all sessions in the project.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "pattern": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Specific sequence pattern to match (e.g., 'Read -&gt; Edit -&gt; Bash')",
                                },
                                "min_occurrences": map[string]interface{}{
                                        "type":        "integer",
                                        "default":     3,
                                        "description": "Minimum occurrences to report (default 3)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "query_file_access": {
                Name:        "query_file_access",
                Description: "Query file access history (read/edit/write operations) across all sessions in the project.",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "file": map[string]interface{}{
                                        "type":        "string",
                                        "description": "File path to query (required)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                        "required": []interface{}{"file"},
                },
        },
        "query_successful_prompts": {
                Name:        "query_successful_prompts",
                Description: "Query successful prompt patterns across all sessions in the project (Stage 8.12).",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "limit": map[string]interface{}{
                                        "type":        "integer",
                                        "default":     10,
                                        "description": "Maximum number of results (default 10)",
                                },
                                "min_quality_score": map[string]interface{}{
                                        "type":        "number",
                                        "default":     0.8,
                                        "description": "Minimum quality score (0.0-1.0, default 0.8)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                },
        },
        "query_context": {
                Name:        "query_context",
                Description: "Query context around specific errors across all sessions in the project (Stage 8.10).",
                InputSchema: map[string]interface{}{
                        "type": "object",
                        "properties": map[string]interface{}{
                                "error_signature": map[string]interface{}{
                                        "type":        "string",
                                        "description": "Error pattern ID to query (required)",
                                },
                                "window": map[string]interface{}{
                                        "type":        "integer",
                                        "default":     3,
                                        "description": "Context window size in turns before/after (default 3)",
                                },
                                "output_format": map[string]interface{}{
                                        "type":    "string",
                                        "enum":    []string{"json", "md"},
                                        "default": "json",
                                },
                        },
                        "required": []interface{}{"error_signature"},
                },
        },
}

// GetProjectLevelTool returns a project-level tool definition by name
func GetProjectLevelTool(name string) *ToolDefinition <span class="cov8" title="1">{
        return projectLevelTools[name]
}</span>

// ListProjectLevelTools returns all registered project-level tools
func ListProjectLevelTools() []*ToolDefinition <span class="cov8" title="1">{
        tools := make([]*ToolDefinition, 0, len(projectLevelTools))
        for _, tool := range projectLevelTools </span><span class="cov8" title="1">{
                tools = append(tools, tool)
        }</span>
        <span class="cov8" title="1">return tools</span>
}

// BuildProjectLevelCommandArgs builds CLI command arguments for a project-level tool
// Project-level tools MUST include --project . flag
func BuildProjectLevelCommandArgs(toolName string, args map[string]interface{}) []string <span class="cov8" title="1">{
        outputFormat := "json"
        if format, ok := args["output_format"].(string); ok </span><span class="cov8" title="1">{
                outputFormat = format
        }</span>

        <span class="cov8" title="1">var cmdArgs []string

        switch toolName </span>{
        case "get_stats":<span class="cov8" title="1">
                cmdArgs = []string{"parse", "stats", "--project", ".", "--output", outputFormat}</span>

        case "analyze_errors":<span class="cov8" title="1">
                cmdArgs = []string{"analyze", "errors", "--project", ".", "--output", outputFormat}</span>

        case "query_tools":<span class="cov8" title="1">
                cmdArgs = []string{"query", "tools", "--project", ".", "--output", outputFormat}

                if tool, ok := args["tool"].(string); ok &amp;&amp; tool != "" </span><span class="cov8" title="1">{
                        cmdArgs = append(cmdArgs, "--tool", tool)
                }</span>
                <span class="cov8" title="1">if status, ok := args["status"].(string); ok &amp;&amp; status != "" </span><span class="cov8" title="1">{
                        cmdArgs = append(cmdArgs, "--status", status)
                }</span>
                <span class="cov8" title="1">if where, ok := args["where"].(string); ok &amp;&amp; where != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--where", where)
                }</span>
                <span class="cov8" title="1">if limit, ok := args["limit"].(float64); ok </span><span class="cov8" title="1">{
                        cmdArgs = append(cmdArgs, "--limit", fmt.Sprintf("%.0f", limit))
                }</span> else<span class="cov8" title="1"> {
                        cmdArgs = append(cmdArgs, "--limit", "20")
                }</span>

        case "query_user_messages":<span class="cov8" title="1">
                pattern, ok := args["pattern"].(string)
                if !ok || pattern == "" </span><span class="cov0" title="0">{
                        return []string{"error", "pattern parameter is required"}
                }</span>

                <span class="cov8" title="1">cmdArgs = []string{"query", "user-messages", "--project", ".", "--match", pattern, "--output", outputFormat}

                if limit, ok := args["limit"].(float64); ok </span><span class="cov8" title="1">{
                        cmdArgs = append(cmdArgs, "--limit", fmt.Sprintf("%.0f", limit))
                }</span> else<span class="cov8" title="1"> {
                        cmdArgs = append(cmdArgs, "--limit", "10")
                }</span>

        case "query_context":<span class="cov8" title="1">
                errorSignature, ok := args["error_signature"].(string)
                if !ok || errorSignature == "" </span><span class="cov0" title="0">{
                        return []string{"error", "error_signature parameter is required"}
                }</span>

                <span class="cov8" title="1">cmdArgs = []string{"query", "context", "--project", ".", "--error-signature", errorSignature, "--output", outputFormat}

                if window, ok := args["window"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--window", fmt.Sprintf("%.0f", window))
                }</span> else<span class="cov8" title="1"> {
                        cmdArgs = append(cmdArgs, "--window", "3")
                }</span>

        case "query_tool_sequences":<span class="cov8" title="1">
                cmdArgs = []string{"query", "tool-sequences", "--project", ".", "--output", outputFormat}

                if minOccurrences, ok := args["min_occurrences"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--min-occurrences", fmt.Sprintf("%.0f", minOccurrences))
                }</span> else<span class="cov8" title="1"> {
                        cmdArgs = append(cmdArgs, "--min-occurrences", "3")
                }</span>
                <span class="cov8" title="1">if pattern, ok := args["pattern"].(string); ok &amp;&amp; pattern != "" </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--pattern", pattern)
                }</span>

        case "query_file_access":<span class="cov8" title="1">
                file, ok := args["file"].(string)
                if !ok || file == "" </span><span class="cov0" title="0">{
                        return []string{"error", "file parameter is required"}
                }</span>

                <span class="cov8" title="1">cmdArgs = []string{"query", "file-access", "--project", ".", "--file", file, "--output", outputFormat}</span>

        case "query_successful_prompts":<span class="cov8" title="1">
                cmdArgs = []string{"query", "successful-prompts", "--project", ".", "--output", outputFormat}

                if minQualityScore, ok := args["min_quality_score"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--min-quality-score", fmt.Sprintf("%.2f", minQualityScore))
                }</span>
                <span class="cov8" title="1">if limit, ok := args["limit"].(float64); ok </span><span class="cov0" title="0">{
                        cmdArgs = append(cmdArgs, "--limit", fmt.Sprintf("%.0f", limit))
                }</span> else<span class="cov8" title="1"> {
                        cmdArgs = append(cmdArgs, "--limit", "10")
                }</span>

        default:<span class="cov0" title="0">
                return []string{"error", "unknown tool: " + toolName}</span>
        }

        <span class="cov8" title="1">return cmdArgs</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "os"
)

// ErrorCode represents standard error codes
type ErrorCode string

const (
        ErrInvalidArgument ErrorCode = "INVALID_ARGUMENT"
        ErrSessionNotFound ErrorCode = "SESSION_NOT_FOUND"
        ErrParseError      ErrorCode = "PARSE_ERROR"
        ErrFilterError     ErrorCode = "FILTER_ERROR"
        ErrNoResults       ErrorCode = "NO_RESULTS"
        ErrInternalError   ErrorCode = "INTERNAL_ERROR"
)

// ErrorOutput represents a structured error output
type ErrorOutput struct {
        Error   string    `json:"error"`
        Code    ErrorCode `json:"code"`
        Message string    `json:"message,omitempty"` // Additional context/suggestions
}

// OutputError outputs an error in the appropriate format
// Returns an ExitCodeError for proper exit code handling
func OutputError(err error, code ErrorCode, format string) error <span class="cov8" title="1">{
        errOutput := ErrorOutput{
                Error: err.Error(),
                Code:  code,
        }

        // Add helpful suggestions based on error code
        switch code </span>{
        case ErrSessionNotFound:<span class="cov8" title="1">
                errOutput.Message = "Try specifying --session or --project flags"</span>
        case ErrInvalidArgument:<span class="cov8" title="1">
                errOutput.Message = "Check command syntax with --help"</span>
        case ErrFilterError:<span class="cov0" title="0">
                errOutput.Message = "Verify filter syntax (e.g., tool=Bash status=error)"</span>
        }

        <span class="cov8" title="1">switch format </span>{
        case "jsonl":<span class="cov8" title="1">
                // Output error as JSON object to stdout (valid JSONL)
                data, marshalErr := json.Marshal(errOutput)
                if marshalErr != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: failed to marshal error: %v\n", marshalErr)
                        return NewExitCodeError(ExitError, err.Error())
                }</span>
                <span class="cov8" title="1">fmt.Println(string(data))</span>

        case "tsv":<span class="cov8" title="1">
                // Output error message to stderr for TSV format
                if errOutput.Message != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(os.Stderr, "Error: %s (code: %s)\nSuggestion: %s\n", err.Error(), code, errOutput.Message)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "Error: %s (code: %s)\n", err.Error(), code)
                }</span>

        default:<span class="cov8" title="1">
                // Fallback to stderr
                fmt.Fprintf(os.Stderr, "Error: %s\n", err.Error())</span>
        }

        // Determine exit code based on error type
        <span class="cov8" title="1">exitCode := ExitError
        if code == ErrNoResults </span><span class="cov8" title="1">{
                exitCode = ExitNoResults
        }</span>

        <span class="cov8" title="1">return NewExitCodeError(exitCode, err.Error())</span>
}

// WarnNoResults outputs a warning for no results (exit code 2)
// This is not an error, but informational
func WarnNoResults(format string) error <span class="cov8" title="1">{
        switch format </span>{
        case "jsonl":<span class="cov8" title="1">
                // Output empty array (valid JSONL)
                fmt.Println("[]")</span>

        case "tsv":<span class="cov8" title="1">
                // Output warning to stderr, nothing to stdout
                fmt.Fprintf(os.Stderr, "Warning: No results found\n")</span>

        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Warning: No results found\n")</span>
        }

        // Exit code 2 indicates no results (not an error, but informational)
        <span class="cov8" title="1">return NewExitCodeError(ExitNoResults, "no results found")</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package output

// Standard Unix exit codes
const (
        ExitSuccess   = 0 // Command succeeded with results
        ExitError     = 1 // General error (parsing, I/O, etc.)
        ExitNoResults = 2 // Command succeeded but no results found
)

// ExitCodeError is a special error type that carries an exit code
// This allows commands to return specific exit codes through Cobra's error handling
type ExitCodeError struct {
        Code    int
        Message string
}

// Error implements the error interface
func (e *ExitCodeError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// NewExitCodeError creates a new exit code error
func NewExitCodeError(code int, message string) *ExitCodeError <span class="cov8" title="1">{
        return &amp;ExitCodeError{
                Code:    code,
                Message: message,
        }
}</span>

// DetermineExitCode determines the appropriate exit code based on results and errors
// Priority: error &gt; no results &gt; success
func DetermineExitCode(hasResults bool, err error) int <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                return ExitError
        }</span>
        <span class="cov8" title="1">if !hasResults </span><span class="cov8" title="1">{
                return ExitNoResults
        }</span>
        <span class="cov8" title="1">return ExitSuccess</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package output

import (
        "fmt"

        pkgOutput "github.com/yale/meta-cc/pkg/output"
)

// FormatOutput formats data based on the output format
// Supports all data types via generic TSV formatting
func FormatOutput(data interface{}, format string) (string, error) <span class="cov8" title="1">{
        switch format </span>{
        case "jsonl":<span class="cov8" title="1">
                return pkgOutput.FormatJSONL(data)</span>
        case "tsv":<span class="cov8" title="1">
                return pkgOutput.FormatTSV(data)</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("unsupported output format: %s (supported: jsonl, tsv)", format)</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package output

import (
        "fmt"
        "io"
        "os"
)

// Output destinations
var (
        // DataWriter is the writer for command output data (default: stdout)
        DataWriter io.Writer = os.Stdout

        // LogWriter is the writer for diagnostic messages (default: stderr)
        LogWriter io.Writer = os.Stderr
)

// WriteData writes data to stdout (DataWriter)
// This should be used for all command output data (JSON, CSV, TSV, etc.)
func WriteData(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintf(DataWriter, format, args...)
}</span>

// WriteLog writes log message to stderr (LogWriter)
// This should be used for diagnostic messages, warnings, and progress indicators
func WriteLog(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintf(LogWriter, format, args...)
}</span>

// WriteLogLine writes log message with newline to stderr (LogWriter)
// This is a convenience function for log messages that should be on their own line
func WriteLogLine(format string, args ...interface{}) <span class="cov8" title="1">{
        fmt.Fprintf(LogWriter, format+"\n", args...)
}</span>

// SetWriters sets custom writers for data and log output
// This is primarily useful for testing
func SetWriters(dataWriter, logWriter io.Writer) <span class="cov8" title="1">{
        DataWriter = dataWriter
        LogWriter = logWriter
}</span>

// ResetWriters resets writers to default values (os.Stdout and os.Stderr)
// This should be called after tests that use custom writers
func ResetWriters() <span class="cov8" title="1">{
        DataWriter = os.Stdout
        LogWriter = os.Stderr
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package parser

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "strings"
)

// SessionParser 负责解析 Claude Code 会话文件
type SessionParser struct {
        filePath string
}

// NewSessionParser 创建 SessionParser 实例
func NewSessionParser(filePath string) *SessionParser <span class="cov8" title="1">{
        return &amp;SessionParser{
                filePath: filePath,
        }
}</span>

// ParseEntries 解析 JSONL 文件，返回 SessionEntry 数组
// JSONL 格式：每行一个 JSON 对象
// 处理规则：
//   - 跳过空行和空白行
//   - 非法 JSON 行返回错误
//   - 仅返回消息类型（type == "user" 或 "assistant"）
//   - 过滤掉 file-history-snapshot 等非消息类型
func (p *SessionParser) ParseEntries() ([]SessionEntry, error) <span class="cov8" title="1">{
        file, err := os.Open(p.filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to open session file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var entries []SessionEntry
        scanner := bufio.NewScanner(file)

        // Increase buffer size for large lines (Claude Code sessions can have very long lines)
        const maxCapacity = 1024 * 1024 // 1MB
        buf := make([]byte, maxCapacity)
        scanner.Buffer(buf, maxCapacity)

        lineNum := 0

        for scanner.Scan() </span><span class="cov8" title="1">{
                lineNum++
                line := scanner.Text()

                // 跳过空行和仅包含空白的行
                if strings.TrimSpace(line) == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // 解析 JSON 为 SessionEntry
                <span class="cov8" title="1">var entry SessionEntry
                if err := json.Unmarshal([]byte(line), &amp;entry); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse line %d: %w", lineNum, err)
                }</span>

                // 仅保留消息类型
                <span class="cov8" title="1">if entry.IsMessage() </span><span class="cov8" title="1">{
                        entries = append(entries, entry)
                }</span>
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading session file: %w", err)
        }</span>

        <span class="cov8" title="1">return entries, nil</span>
}

// ParseEntriesFromContent 从字符串内容解析 JSONL（用于测试）
func ParseEntriesFromContent(content string) ([]SessionEntry, error) <span class="cov0" title="0">{
        var entries []SessionEntry
        lines := strings.Split(content, "\n")

        for lineNum, line := range lines </span><span class="cov0" title="0">{
                // 跳过空行
                if strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var entry SessionEntry
                if err := json.Unmarshal([]byte(line), &amp;entry); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse line %d: %w", lineNum+1, err)
                }</span>

                // 仅保留消息类型
                <span class="cov0" title="0">if entry.IsMessage() </span><span class="cov0" title="0">{
                        entries = append(entries, entry)
                }</span>
        }

        <span class="cov0" title="0">return entries, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package parser

// ToolCall represents a complete tool invocation (ToolUse + ToolResult)
type ToolCall struct {
        UUID      string                 // UUID of the SessionEntry containing the tool_use
        ToolName  string                 // Name of the tool
        Input     map[string]interface{} // Tool input parameters
        Output    string                 // Tool output (ToolResult.Content)
        Status    string                 // Execution status (success/error)
        Error     string                 // Error message (if any)
        Timestamp string                 // Timestamp of the tool call (ISO 8601 format)
}

// ExtractToolCalls extracts all tool calls from SessionEntry array
// Process:
//  1. Iterate all SessionEntry, collect ToolUse (indexed by ID)
//  2. Iterate all SessionEntry, find ToolResult, match by tool_use_id
//  3. Generate ToolCall array
func ExtractToolCalls(entries []SessionEntry) []ToolCall <span class="cov8" title="1">{
        // Step 1: Collect all ToolUse (indexed by ID)
        toolUseMap := make(map[string]struct {
                uuid      string
                toolUse   *ToolUse
                timestamp string
        })

        for _, entry := range entries </span><span class="cov8" title="1">{
                // Skip entries without Message
                if entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, block := range entry.Message.Content </span><span class="cov8" title="1">{
                        if block.Type == "tool_use" &amp;&amp; block.ToolUse != nil </span><span class="cov8" title="1">{
                                toolUseMap[block.ToolUse.ID] = struct {
                                        uuid      string
                                        toolUse   *ToolUse
                                        timestamp string
                                }{
                                        uuid:      entry.UUID,
                                        toolUse:   block.ToolUse,
                                        timestamp: entry.Timestamp,
                                }
                        }</span>
                }
        }

        // Step 2: Collect all ToolResult (indexed by tool_use_id)
        <span class="cov8" title="1">toolResultMap := make(map[string]*ToolResult)

        for _, entry := range entries </span><span class="cov8" title="1">{
                // Skip entries without Message
                if entry.Message == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, block := range entry.Message.Content </span><span class="cov8" title="1">{
                        if block.Type == "tool_result" &amp;&amp; block.ToolResult != nil </span><span class="cov8" title="1">{
                                toolResultMap[block.ToolResult.ToolUseID] = block.ToolResult
                        }</span>
                }
        }

        // Step 3: Generate ToolCall array
        <span class="cov8" title="1">var toolCalls []ToolCall

        for toolUseID, tu := range toolUseMap </span><span class="cov8" title="1">{
                toolCall := ToolCall{
                        UUID:      tu.uuid,
                        ToolName:  tu.toolUse.Name,
                        Input:     tu.toolUse.Input,
                        Timestamp: tu.timestamp,
                }

                // Find matching ToolResult
                if result, found := toolResultMap[toolUseID]; found </span><span class="cov8" title="1">{
                        toolCall.Output = result.Content
                        toolCall.Status = result.Status
                        toolCall.Error = result.Error
                }</span>

                <span class="cov8" title="1">toolCalls = append(toolCalls, toolCall)</span>
        }

        <span class="cov8" title="1">return toolCalls</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package parser

import (
        "encoding/json"
        "fmt"
        "strings"
)

// SessionEntry 表示 Claude Code 会话文件中的一个条目
// 可以是 user 消息、assistant 消息或其他类型（如 file-history-snapshot）
type SessionEntry struct {
        Type       string   `json:"type"`       // "user", "assistant", "file-history-snapshot", etc.
        Timestamp  string   `json:"timestamp"`  // ISO 8601 格式: "2025-10-02T06:07:13.673Z"
        UUID       string   `json:"uuid"`       // 条目唯一标识
        ParentUUID string   `json:"parentUuid"` // 父条目 UUID（构建消息链）
        SessionID  string   `json:"sessionId"`  // 会话 ID
        CWD        string   `json:"cwd"`        // 工作目录
        Version    string   `json:"version"`    // Claude Code 版本
        GitBranch  string   `json:"gitBranch"`  // Git 分支
        Message    *Message `json:"message"`    // 消息内容（仅 user/assistant 类型有值）
}

// IsMessage 判断条目是否为消息类型（user 或 assistant）
func (e *SessionEntry) IsMessage() bool <span class="cov8" title="1">{
        return e.Type == "user" || e.Type == "assistant"
}</span>

// Message 表示消息的详细内容
type Message struct {
        ID         string                 `json:"id"`          // 消息 ID（assistant 消息有值）
        Role       string                 `json:"role"`        // "user" 或 "assistant"
        Model      string                 `json:"model"`       // 模型名称（assistant 消息有值）
        Content    []ContentBlock         `json:"-"`           // 内容块数组（手动处理）
        StopReason string                 `json:"stop_reason"` // 停止原因
        Usage      map[string]interface{} `json:"usage"`       // Token 使用统计
}

// UnmarshalJSON 自定义 JSON 反序列化
// content 字段可以是 string 或 []ContentBlock
func (m *Message) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // 首先尝试解析到临时结构
        type Alias Message
        aux := &amp;struct {
                ContentRaw json.RawMessage `json:"content"`
                *Alias
        }{
                Alias: (*Alias)(m),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 处理 content 字段
        <span class="cov8" title="1">if len(aux.ContentRaw) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 尝试作为字符串解析
        <span class="cov8" title="1">var contentStr string
        if err := json.Unmarshal(aux.ContentRaw, &amp;contentStr); err == nil </span><span class="cov0" title="0">{
                // content 是字符串，转换为单个 text ContentBlock
                m.Content = []ContentBlock{
                        {
                                Type: "text",
                                Text: contentStr,
                        },
                }
                return nil
        }</span>

        // 否则作为数组解析
        <span class="cov8" title="1">return json.Unmarshal(aux.ContentRaw, &amp;m.Content)</span>
}

// ContentBlock 表示消息中的一个内容块
// 可以是文本、工具调用或工具结果
type ContentBlock struct {
        Type       string      `json:"type"`
        Text       string      `json:"text,omitempty"`
        ToolUse    *ToolUse    `json:"-"` // 手动处理序列化
        ToolResult *ToolResult `json:"-"` // 手动处理序列化
}

// ToolUse 表示一个工具调用
type ToolUse struct {
        ID    string                 `json:"id"`
        Name  string                 `json:"name"`
        Input map[string]interface{} `json:"input"`
}

// ToolResult 表示工具调用的结果
type ToolResult struct {
        ToolUseID string `json:"tool_use_id"`
        Content   string `json:"-"`        // 手动处理（可以是 string 或 array）
        IsError   bool   `json:"is_error"` // 标识是否为错误
        Status    string `json:"status,omitempty"`
        Error     string `json:"error,omitempty"`
}

// UnmarshalJSON 自定义 ToolResult 的反序列化逻辑
// content 字段可以是 string 或 array
func (tr *ToolResult) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type Alias ToolResult
        aux := &amp;struct {
                ContentRaw json.RawMessage `json:"content"`
                *Alias
        }{
                Alias: (*Alias)(tr),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 处理 content 字段
        <span class="cov8" title="1">if len(aux.ContentRaw) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 尝试作为字符串解析
        <span class="cov8" title="1">var contentStr string
        if err := json.Unmarshal(aux.ContentRaw, &amp;contentStr); err == nil </span><span class="cov8" title="1">{
                tr.Content = contentStr
                // 当 is_error=true 时，将 content 也复制到 Error 字段
                if tr.IsError &amp;&amp; tr.Error == "" </span><span class="cov0" title="0">{
                        tr.Error = contentStr
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // 否则作为数组解析（提取文本）
        <span class="cov0" title="0">var contentBlocks []struct {
                Type string `json:"type"`
                Text string `json:"text"`
        }
        if err := json.Unmarshal(aux.ContentRaw, &amp;contentBlocks); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal tool_result content: %w", err)
        }</span>

        // 将所有文本块合并
        <span class="cov0" title="0">var texts []string
        for _, block := range contentBlocks </span><span class="cov0" title="0">{
                if block.Text != "" </span><span class="cov0" title="0">{
                        texts = append(texts, block.Text)
                }</span>
        }
        <span class="cov0" title="0">tr.Content = strings.Join(texts, "\n")

        // 当 is_error=true 时，将合并后的 content 也复制到 Error 字段
        if tr.IsError &amp;&amp; tr.Error == "" </span><span class="cov0" title="0">{
                tr.Error = tr.Content
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UnmarshalJSON 自定义 ContentBlock 的反序列化逻辑
// 根据 type 字段，解析不同的内容到相应的字段
func (cb *ContentBlock) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // 先解析通用字段
        type Alias ContentBlock
        aux := &amp;struct {
                *Alias
                RawToolUse    json.RawMessage `json:"tool_use,omitempty"`
                RawToolResult json.RawMessage `json:"tool_result,omitempty"`
        }{
                Alias: (*Alias)(cb),
        }

        if err := json.Unmarshal(data, aux); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal ContentBlock: %w", err)
        }</span>

        // 根据 type 解析特定字段
        <span class="cov8" title="1">switch cb.Type </span>{
        case "text":<span class="cov8" title="1"></span>
                // text 类型已经由默认反序列化处理

        case "tool_use":<span class="cov8" title="1">
                // 解析 tool_use 字段
                var toolUse ToolUse
                // tool_use 数据直接嵌入在 ContentBlock 中（除了 type）
                // 需要重新解析整个 data
                type ToolUseBlock struct {
                        Type  string                 `json:"type"`
                        ID    string                 `json:"id"`
                        Name  string                 `json:"name"`
                        Input map[string]interface{} `json:"input"`
                }
                var tub ToolUseBlock
                if err := json.Unmarshal(data, &amp;tub); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal tool_use: %w", err)
                }</span>
                <span class="cov8" title="1">toolUse.ID = tub.ID
                toolUse.Name = tub.Name
                toolUse.Input = tub.Input
                cb.ToolUse = &amp;toolUse</span>

        case "tool_result":<span class="cov8" title="1">
                // 解析 tool_result 字段
                // 使用 ToolResult 的自定义 UnmarshalJSON 方法
                var toolResult ToolResult
                if err := json.Unmarshal(data, &amp;toolResult); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to unmarshal tool_result: %w", err)
                }</span>
                <span class="cov8" title="1">cb.ToolResult = &amp;toolResult</span>

        default:<span class="cov0" title="0"></span>
                // 未知类型，保留原始数据但不报错
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package query

import (
        "fmt"
        "strings"
        "time"

        "github.com/yale/meta-cc/internal/analyzer"
        "github.com/yale/meta-cc/internal/parser"
)

// BuildContextQuery builds a context query for a specific error signature
func BuildContextQuery(entries []parser.SessionEntry, errorSignature string, window int) (*ContextQuery, error) <span class="cov8" title="1">{
        if window &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("window size must be non-negative")
        }</span>

        // Build turn index map
        <span class="cov8" title="1">turnIndex := buildTurnIndex(entries)

        // Find all error occurrences
        occurrences := findErrorOccurrences(entries, errorSignature, window, turnIndex)

        return &amp;ContextQuery{
                ErrorSignature: errorSignature,
                Occurrences:    occurrences,
        }, nil</span>
}

// buildTurnIndex creates a map of UUID to turn number
func buildTurnIndex(entries []parser.SessionEntry) map[string]int <span class="cov8" title="1">{
        index := make(map[string]int)
        turn := 0
        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsMessage() </span><span class="cov8" title="1">{
                        index[entry.UUID] = turn
                        turn++
                }</span>
        }
        <span class="cov8" title="1">return index</span>
}

// findErrorOccurrences finds all occurrences of the error signature
func findErrorOccurrences(entries []parser.SessionEntry, errorSig string, window int, turnIndex map[string]int) []ContextOccurrence <span class="cov8" title="1">{
        var occurrences []ContextOccurrence

        toolCalls := parser.ExtractToolCalls(entries)

        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                // Check if this tool call has an error
                if tc.Status != "error" || tc.Error == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate error signature
                <span class="cov8" title="1">sig := analyzer.CalculateErrorSignature(tc.ToolName, tc.Error)
                if sig != errorSig </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Find the turn number for this tool call
                <span class="cov8" title="1">turn, ok := turnIndex[tc.UUID]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Build context
                <span class="cov8" title="1">occurrence := ContextOccurrence{
                        Turn:          turn,
                        ContextBefore: buildContextBefore(entries, turn, window, turnIndex),
                        ErrorTurn:     buildErrorDetail(tc, turn, entries),
                        ContextAfter:  buildContextAfter(entries, turn, window, turnIndex),
                }

                occurrences = append(occurrences, occurrence)</span>
        }

        <span class="cov8" title="1">return occurrences</span>
}

// buildContextBefore builds context before the error turn
func buildContextBefore(entries []parser.SessionEntry, errorTurn, window int, turnIndex map[string]int) []TurnPreview <span class="cov8" title="1">{
        var previews []TurnPreview

        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsMessage() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">turn := turnIndex[entry.UUID]
                if turn &gt;= errorTurn || turn &lt; errorTurn-window </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">previews = append(previews, buildTurnPreview(entry, turn))</span>
        }

        <span class="cov8" title="1">return previews</span>
}

// buildContextAfter builds context after the error turn
func buildContextAfter(entries []parser.SessionEntry, errorTurn, window int, turnIndex map[string]int) []TurnPreview <span class="cov8" title="1">{
        var previews []TurnPreview

        for _, entry := range entries </span><span class="cov8" title="1">{
                if !entry.IsMessage() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">turn := turnIndex[entry.UUID]
                if turn &lt;= errorTurn || turn &gt; errorTurn+window </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">previews = append(previews, buildTurnPreview(entry, turn))</span>
        }

        <span class="cov8" title="1">return previews</span>
}

// buildTurnPreview builds a preview of a turn
func buildTurnPreview(entry parser.SessionEntry, turn int) TurnPreview <span class="cov8" title="1">{
        preview := TurnPreview{
                Turn:      turn,
                Role:      "",
                Preview:   "",
                Tools:     []string{},
                Timestamp: parseTimestamp(entry.Timestamp),
        }

        if entry.Message == nil </span><span class="cov0" title="0">{
                return preview
        }</span>

        <span class="cov8" title="1">preview.Role = entry.Message.Role

        // Extract preview text and tools
        for _, block := range entry.Message.Content </span><span class="cov8" title="1">{
                switch block.Type </span>{
                case "text":<span class="cov8" title="1">
                        if preview.Preview == "" &amp;&amp; block.Text != "" </span><span class="cov8" title="1">{
                                // Use first 100 chars as preview
                                preview.Preview = truncateText(block.Text, 100)
                        }</span>
                case "tool_use":<span class="cov0" title="0">
                        if block.ToolUse != nil </span><span class="cov0" title="0">{
                                preview.Tools = append(preview.Tools, block.ToolUse.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">return preview</span>
}

// buildErrorDetail builds error detail from a tool call
func buildErrorDetail(tc parser.ToolCall, turn int, entries []parser.SessionEntry) ErrorDetail <span class="cov8" title="1">{
        detail := ErrorDetail{
                Turn:      turn,
                Tool:      tc.ToolName,
                Error:     tc.Error,
                Timestamp: 0,
        }

        // Extract command from tool input
        if cmd, ok := tc.Input["command"].(string); ok </span><span class="cov8" title="1">{
                detail.Command = cmd
        }</span>

        // Extract file path
        <span class="cov8" title="1">if filePath, ok := tc.Input["file_path"].(string); ok </span><span class="cov0" title="0">{
                detail.File = filePath
        }</span>

        // Find timestamp
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.UUID == tc.UUID </span><span class="cov8" title="1">{
                        detail.Timestamp = parseTimestamp(entry.Timestamp)
                        break</span>
                }
        }

        <span class="cov8" title="1">return detail</span>
}

// parseTimestamp parses RFC3339Nano timestamp to Unix timestamp
func parseTimestamp(ts string) int64 <span class="cov8" title="1">{
        t, err := time.Parse(time.RFC3339Nano, ts)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return t.Unix()</span>
}

// truncateText truncates text to maxLen characters
func truncateText(text string, maxLen int) string <span class="cov8" title="1">{
        text = strings.TrimSpace(text)
        if len(text) &lt;= maxLen </span><span class="cov8" title="1">{
                return text
        }</span>
        <span class="cov8" title="1">return text[:maxLen] + "..."</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package query

import (
        "fmt"
        "sort"
        "strings"

        "github.com/yale/meta-cc/internal/parser"
)

// BuildFileAccessQuery builds a file access history query
func BuildFileAccessQuery(entries []parser.SessionEntry, filePath string) (*FileAccessQuery, error) <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("file path is required")
        }</span>

        // Build turn index
        <span class="cov8" title="1">turnIndex := buildTurnIndex(entries)

        // Extract all tool calls
        toolCalls := parser.ExtractToolCalls(entries)

        // Collect file access events
        var timeline []FileAccessEvent
        operations := make(map[string]int)

        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                // Check if this tool call accesses the file
                accessedFile := extractFileFromToolCall(tc)
                if accessedFile == "" || !matchesFile(accessedFile, filePath) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Determine action type
                <span class="cov8" title="1">action := getActionType(tc.ToolName)
                if action == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get turn number
                <span class="cov8" title="1">turn, ok := turnIndex[tc.UUID]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get timestamp
                <span class="cov8" title="1">timestamp := getToolCallTimestamp(entries, tc.UUID)

                // Record event
                event := FileAccessEvent{
                        Turn:      turn,
                        Action:    action,
                        Timestamp: timestamp,
                }
                timeline = append(timeline, event)
                operations[action]++</span>
        }

        // Sort timeline by turn
        <span class="cov8" title="1">sort.Slice(timeline, func(i, j int) bool </span><span class="cov8" title="1">{
                return timeline[i].Turn &lt; timeline[j].Turn
        }</span>)

        // Calculate time span
        <span class="cov8" title="1">timeSpan := calculateTimeSpan(timeline)

        return &amp;FileAccessQuery{
                File:          filePath,
                TotalAccesses: len(timeline),
                Operations:    operations,
                Timeline:      timeline,
                TimeSpanMin:   timeSpan,
        }, nil</span>
}

// extractFileFromToolCall extracts file path from tool call input
func extractFileFromToolCall(tc parser.ToolCall) string <span class="cov8" title="1">{
        // Check common file parameter names
        fileParams := []string{"file_path", "notebook_path", "path"}

        for _, param := range fileParams </span><span class="cov8" title="1">{
                if val, ok := tc.Input[param]; ok </span><span class="cov8" title="1">{
                        if filePath, ok := val.(string); ok &amp;&amp; filePath != "" </span><span class="cov8" title="1">{
                                return filePath
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// matchesFile checks if a file path matches the query
func matchesFile(accessedFile, queryFile string) bool <span class="cov8" title="1">{
        // Exact match
        if accessedFile == queryFile </span><span class="cov8" title="1">{
                return true
        }</span>

        // If query is just a basename (no slashes), match against accessed basename
        <span class="cov8" title="1">if !strings.Contains(queryFile, "/") </span><span class="cov8" title="1">{
                accessedBase := strings.TrimPrefix(accessedFile, lastSlash(accessedFile))
                return accessedBase == queryFile
        }</span>

        // Both have paths but differ - no match
        <span class="cov8" title="1">return false</span>
}

// lastSlash returns everything up to and including the last slash
func lastSlash(path string) string <span class="cov8" title="1">{
        idx := strings.LastIndex(path, "/")
        if idx &lt; 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return path[:idx+1]</span>
}

// getActionType maps tool name to action type
func getActionType(toolName string) string <span class="cov8" title="1">{
        switch toolName </span>{
        case "Read":<span class="cov8" title="1">
                return "Read"</span>
        case "Edit":<span class="cov8" title="1">
                return "Edit"</span>
        case "Write":<span class="cov8" title="1">
                return "Write"</span>
        case "NotebookEdit":<span class="cov8" title="1">
                return "Edit"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// getToolCallTimestamp finds the timestamp for a tool call UUID
func getToolCallTimestamp(entries []parser.SessionEntry, uuid string) int64 <span class="cov8" title="1">{
        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.UUID == uuid </span><span class="cov8" title="1">{
                        return parseTimestamp(entry.Timestamp)
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// calculateTimeSpan calculates time span in minutes
func calculateTimeSpan(timeline []FileAccessEvent) int <span class="cov8" title="1">{
        if len(timeline) &lt; 2 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">first := timeline[0].Timestamp
        last := timeline[len(timeline)-1].Timestamp

        return int((last - first) / 60)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package query

import (
        "fmt"
        "sort"
        "strings"

        "github.com/yale/meta-cc/internal/parser"
)

// BuildToolSequenceQuery builds a tool sequence pattern query
func BuildToolSequenceQuery(entries []parser.SessionEntry, minOccurrences int, pattern string) (*ToolSequenceQuery, error) <span class="cov8" title="1">{
        if minOccurrences &lt; 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("minOccurrences must be at least 1")
        }</span>

        // Build turn index
        <span class="cov8" title="1">turnIndex := buildTurnIndex(entries)

        // Extract tool calls with turn numbers
        toolCalls := extractToolCallsWithTurns(entries, turnIndex)

        // Sort by turn
        sort.Slice(toolCalls, func(i, j int) bool </span><span class="cov8" title="1">{
                return toolCalls[i].turn &lt; toolCalls[j].turn
        }</span>)

        // Find sequences
        <span class="cov8" title="1">var sequences []SequencePattern
        if pattern != "" </span><span class="cov8" title="1">{
                // Find specific pattern
                seq := findSpecificPattern(toolCalls, pattern, entries)
                if seq.Count &gt;= minOccurrences </span><span class="cov8" title="1">{
                        sequences = append(sequences, seq)
                }</span>
        } else<span class="cov8" title="1"> {
                // Find all repeated sequences
                sequences = findAllSequences(toolCalls, minOccurrences, entries)
        }</span>

        <span class="cov8" title="1">return &amp;ToolSequenceQuery{
                Sequences: sequences,
        }, nil</span>
}

// toolCallWithTurn represents a tool call with its turn number
type toolCallWithTurn struct {
        toolName string
        turn     int
        uuid     string
}

// extractToolCallsWithTurns extracts tool calls with turn numbers
func extractToolCallsWithTurns(entries []parser.SessionEntry, turnIndex map[string]int) []toolCallWithTurn <span class="cov8" title="1">{
        var result []toolCallWithTurn

        toolCalls := parser.ExtractToolCalls(entries)
        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                if turn, ok := turnIndex[tc.UUID]; ok </span><span class="cov8" title="1">{
                        result = append(result, toolCallWithTurn{
                                toolName: tc.ToolName,
                                turn:     turn,
                                uuid:     tc.UUID,
                        })
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// findSpecificPattern finds occurrences of a specific pattern
func findSpecificPattern(toolCalls []toolCallWithTurn, pattern string, entries []parser.SessionEntry) SequencePattern <span class="cov8" title="1">{
        // Parse pattern (format: "Tool1 → Tool2 → Tool3")
        tools := parsePattern(pattern)
        if len(tools) == 0 </span><span class="cov0" title="0">{
                return SequencePattern{Pattern: pattern, Count: 0}
        }</span>

        // Find all occurrences
        <span class="cov8" title="1">var occurrences []SequenceOccurrence

        for i := 0; i &lt;= len(toolCalls)-len(tools); i++ </span><span class="cov8" title="1">{
                // Check if sequence matches starting at position i
                if matchesSequence(toolCalls, i, tools) </span><span class="cov8" title="1">{
                        startTurn := toolCalls[i].turn
                        endTurn := toolCalls[i+len(tools)-1].turn
                        occurrences = append(occurrences, SequenceOccurrence{
                                StartTurn: startTurn,
                                EndTurn:   endTurn,
                        })
                }</span>
        }

        // Calculate time span
        <span class="cov8" title="1">timeSpan := calculateSequenceTimeSpan(occurrences, entries, toolCalls)

        return SequencePattern{
                Pattern:     pattern,
                Count:       len(occurrences),
                Occurrences: occurrences,
                TimeSpanMin: timeSpan,
        }</span>
}

// findAllSequences finds all repeated sequences of length 2-5
func findAllSequences(toolCalls []toolCallWithTurn, minOccurrences int, entries []parser.SessionEntry) []SequencePattern <span class="cov8" title="1">{
        sequenceMap := make(map[string][]SequenceOccurrence)

        // Try sequences of different lengths (2-5 tools)
        for seqLen := 2; seqLen &lt;= 5 &amp;&amp; seqLen &lt;= len(toolCalls); seqLen++ </span><span class="cov8" title="1">{
                for i := 0; i &lt;= len(toolCalls)-seqLen; i++ </span><span class="cov8" title="1">{
                        // Extract sequence
                        tools := make([]string, seqLen)
                        for j := 0; j &lt; seqLen; j++ </span><span class="cov8" title="1">{
                                tools[j] = toolCalls[i+j].toolName
                        }</span>

                        // Create pattern string
                        <span class="cov8" title="1">pattern := strings.Join(tools, " → ")

                        // Record occurrence
                        occurrence := SequenceOccurrence{
                                StartTurn: toolCalls[i].turn,
                                EndTurn:   toolCalls[i+seqLen-1].turn,
                        }

                        sequenceMap[pattern] = append(sequenceMap[pattern], occurrence)</span>
                }
        }

        // Filter by minimum occurrences and build result
        <span class="cov8" title="1">var result []SequencePattern
        for pattern, occurrences := range sequenceMap </span><span class="cov8" title="1">{
                if len(occurrences) &gt;= minOccurrences </span><span class="cov8" title="1">{
                        timeSpan := calculateSequenceTimeSpan(occurrences, entries, toolCalls)
                        result = append(result, SequencePattern{
                                Pattern:     pattern,
                                Count:       len(occurrences),
                                Occurrences: occurrences,
                                TimeSpanMin: timeSpan,
                        })
                }</span>
        }

        // Sort by count (descending)
        <span class="cov8" title="1">sort.Slice(result, func(i, j int) bool </span><span class="cov8" title="1">{
                return result[i].Count &gt; result[j].Count
        }</span>)

        <span class="cov8" title="1">return result</span>
}

// parsePattern parses a pattern string into tool names
func parsePattern(pattern string) []string <span class="cov8" title="1">{
        // Split by " → " or "-&gt;"
        pattern = strings.ReplaceAll(pattern, "→", "-&gt;")
        parts := strings.Split(pattern, "-&gt;")

        var tools []string
        for _, part := range parts </span><span class="cov8" title="1">{
                tool := strings.TrimSpace(part)
                if tool != "" </span><span class="cov8" title="1">{
                        tools = append(tools, tool)
                }</span>
        }

        <span class="cov8" title="1">return tools</span>
}

// matchesSequence checks if a sequence matches at a given position
func matchesSequence(toolCalls []toolCallWithTurn, start int, tools []string) bool <span class="cov8" title="1">{
        if start+len(tools) &gt; len(toolCalls) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i, tool := range tools </span><span class="cov8" title="1">{
                if toolCalls[start+i].toolName != tool </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// calculateSequenceTimeSpan calculates time span for sequence occurrences
func calculateSequenceTimeSpan(occurrences []SequenceOccurrence, entries []parser.SessionEntry, toolCalls []toolCallWithTurn) int <span class="cov8" title="1">{
        if len(occurrences) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Find first and last timestamp
        <span class="cov8" title="1">var minTs, maxTs int64

        for _, occ := range occurrences </span><span class="cov8" title="1">{
                // Find timestamps for start and end turns
                for _, tc := range toolCalls </span><span class="cov8" title="1">{
                        if tc.turn == occ.StartTurn || tc.turn == occ.EndTurn </span><span class="cov8" title="1">{
                                ts := getToolCallTimestamp(entries, tc.uuid)
                                if minTs == 0 || ts &lt; minTs </span><span class="cov8" title="1">{
                                        minTs = ts
                                }</span>
                                <span class="cov8" title="1">if ts &gt; maxTs </span><span class="cov8" title="1">{
                                        maxTs = ts
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if minTs == 0 || maxTs == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return int((maxTs - minTs) / 60)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package stats

import (
        "fmt"
        "sort"

        "github.com/yale/meta-cc/internal/parser"
)

// AggregateConfig defines aggregation parameters
type AggregateConfig struct {
        GroupBy string   // Field to group by (e.g., "tool", "status")
        Metrics []string // Metrics to calculate (e.g., "count", "error_rate")
}

// AggregateResult represents aggregated data for a group
type AggregateResult struct {
        GroupValue string                 `json:"group_value"`
        Metrics    map[string]interface{} `json:"metrics"`
}

// Aggregate performs aggregation on tool calls
func Aggregate(tools []parser.ToolCall, config AggregateConfig) ([]AggregateResult, error) <span class="cov8" title="1">{
        // Validate group-by field
        if !isValidGroupByField(config.GroupBy) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid group-by field: %s", config.GroupBy)
        }</span>

        // Step 1: Group by field
        <span class="cov8" title="1">groups := make(map[string][]parser.ToolCall)
        for _, tool := range tools </span><span class="cov8" title="1">{
                groupValue := getFieldValue(tool, config.GroupBy)
                groups[groupValue] = append(groups[groupValue], tool)
        }</span>

        // Step 2: Calculate metrics for each group
        <span class="cov8" title="1">var results []AggregateResult
        for groupValue, groupTools := range groups </span><span class="cov8" title="1">{
                metrics := make(map[string]interface{})

                for _, metric := range config.Metrics </span><span class="cov8" title="1">{
                        value, err := calculateMetric(groupTools, metric)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">metrics[metric] = value</span>
                }

                <span class="cov8" title="1">results = append(results, AggregateResult{
                        GroupValue: groupValue,
                        Metrics:    metrics,
                })</span>
        }

        // Step 3: Sort by count (descending)
        <span class="cov8" title="1">sort.Slice(results, func(i, j int) bool </span><span class="cov8" title="1">{
                ci, _ := results[i].Metrics["count"].(int)
                cj, _ := results[j].Metrics["count"].(int)
                return ci &gt; cj
        }</span>)

        <span class="cov8" title="1">return results, nil</span>
}

// isValidGroupByField checks if field is valid for grouping
func isValidGroupByField(field string) bool <span class="cov8" title="1">{
        validFields := []string{"tool", "status", "uuid"}
        for _, f := range validFields </span><span class="cov8" title="1">{
                if f == field </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package stats

import (
        "sort"

        "github.com/yale/meta-cc/internal/parser"
)

// FileStats represents file-level operation statistics
type FileStats struct {
        FilePath   string  `json:"file_path"`
        ReadCount  int     `json:"read_count"`
        EditCount  int     `json:"edit_count"`
        WriteCount int     `json:"write_count"`
        ErrorCount int     `json:"error_count"`
        TotalOps   int     `json:"total_ops"`
        ErrorRate  float64 `json:"error_rate"`
}

// AnalyzeFileStats analyzes file-level statistics from tool calls
func AnalyzeFileStats(toolCalls []parser.ToolCall) []FileStats <span class="cov8" title="1">{
        fileMap := make(map[string]*FileStats)

        for _, tc := range toolCalls </span><span class="cov8" title="1">{
                // Extract file path from tool input
                filePath := extractFilePath(tc)
                if filePath == "" </span><span class="cov8" title="1">{
                        continue</span> // Skip non-file operations
                }

                // Initialize file stats if not exists
                <span class="cov8" title="1">if _, exists := fileMap[filePath]; !exists </span><span class="cov8" title="1">{
                        fileMap[filePath] = &amp;FileStats{
                                FilePath: filePath,
                        }
                }</span>

                <span class="cov8" title="1">stats := fileMap[filePath]

                // Count operation type
                switch tc.ToolName </span>{
                case "Read":<span class="cov8" title="1">
                        stats.ReadCount++</span>
                case "Edit":<span class="cov8" title="1">
                        stats.EditCount++</span>
                case "Write":<span class="cov8" title="1">
                        stats.WriteCount++</span>
                case "NotebookEdit":<span class="cov8" title="1">
                        stats.EditCount++</span> // Treat notebook edits as edits
                }

                // Count errors
                <span class="cov8" title="1">if tc.Status == "error" </span><span class="cov8" title="1">{
                        stats.ErrorCount++
                }</span>

                <span class="cov8" title="1">stats.TotalOps++</span>
        }

        // Calculate error rates and convert to slice
        <span class="cov8" title="1">var results []FileStats
        for _, stats := range fileMap </span><span class="cov8" title="1">{
                if stats.TotalOps &gt; 0 </span><span class="cov8" title="1">{
                        stats.ErrorRate = float64(stats.ErrorCount) / float64(stats.TotalOps)
                }</span>
                <span class="cov8" title="1">results = append(results, *stats)</span>
        }

        // Default sort: by total ops descending
        <span class="cov8" title="1">sort.Slice(results, func(i, j int) bool </span><span class="cov8" title="1">{
                return results[i].TotalOps &gt; results[j].TotalOps
        }</span>)

        <span class="cov8" title="1">return results</span>
}

// extractFilePath extracts file path from ToolCall input
func extractFilePath(tc parser.ToolCall) string <span class="cov8" title="1">{
        // Try common field names
        if filePath, ok := tc.Input["file_path"].(string); ok </span><span class="cov8" title="1">{
                return filePath
        }</span>

        <span class="cov8" title="1">if filePath, ok := tc.Input["path"].(string); ok </span><span class="cov8" title="1">{
                return filePath
        }</span>

        <span class="cov8" title="1">if filePath, ok := tc.Input["notebook_path"].(string); ok </span><span class="cov8" title="1">{
                return filePath
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// SortFileStats sorts file statistics by specified field
func SortFileStats(stats []FileStats, sortBy string) <span class="cov8" title="1">{
        sort.Slice(stats, func(i, j int) bool </span><span class="cov8" title="1">{
                switch sortBy </span>{
                case "read_count":<span class="cov0" title="0">
                        return stats[i].ReadCount &gt; stats[j].ReadCount</span>
                case "edit_count":<span class="cov8" title="1">
                        return stats[i].EditCount &gt; stats[j].EditCount</span>
                case "write_count":<span class="cov0" title="0">
                        return stats[i].WriteCount &gt; stats[j].WriteCount</span>
                case "error_count":<span class="cov8" title="1">
                        return stats[i].ErrorCount &gt; stats[j].ErrorCount</span>
                case "error_rate":<span class="cov8" title="1">
                        return stats[i].ErrorRate &gt; stats[j].ErrorRate</span>
                default:<span class="cov8" title="1"> // "total_ops"
                        return stats[i].TotalOps &gt; stats[j].TotalOps</span>
                }
        })
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package stats

import (
        "fmt"

        "github.com/yale/meta-cc/internal/parser"
)

// calculateMetric calculates a specific metric for a group of tools
func calculateMetric(tools []parser.ToolCall, metric string) (interface{}, error) <span class="cov8" title="1">{
        switch metric </span>{
        case "count":<span class="cov8" title="1">
                return len(tools), nil</span>

        case "error_rate":<span class="cov8" title="1">
                if len(tools) == 0 </span><span class="cov0" title="0">{
                        return 0.0, nil
                }</span>
                <span class="cov8" title="1">errorCount := 0
                for _, tool := range tools </span><span class="cov8" title="1">{
                        if tool.Status == "error" </span><span class="cov8" title="1">{
                                errorCount++
                        }</span>
                }
                <span class="cov8" title="1">return float64(errorCount) / float64(len(tools)), nil</span>

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported metric: %s", metric)</span>
        }
}

// getFieldValue extracts field value from ToolCall
func getFieldValue(tool parser.ToolCall, field string) string <span class="cov8" title="1">{
        switch field </span>{
        case "tool":<span class="cov8" title="1">
                return tool.ToolName</span>
        case "status":<span class="cov8" title="1">
                return tool.Status</span>
        case "uuid":<span class="cov8" title="1">
                return tool.UUID</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package stats

import (
        "fmt"
        "time"

        "github.com/yale/meta-cc/internal/parser"
)

// TimeSeriesConfig defines time series analysis parameters
type TimeSeriesConfig struct {
        Metric   string // Metric: "tool-calls", "error-rate", "avg-duration"
        Interval string // Interval: "hour", "day", "week"
}

// TimeSeriesPoint represents a single data point in time series
type TimeSeriesPoint struct {
        Timestamp time.Time `json:"timestamp"`
        Value     float64   `json:"value"`
}

// AnalyzeTimeSeries generates time series data from tool calls
func AnalyzeTimeSeries(tools []parser.ToolCall, config TimeSeriesConfig) ([]TimeSeriesPoint, error) <span class="cov8" title="1">{
        if len(tools) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Parse timestamps
        <span class="cov8" title="1">var times []time.Time
        for _, tool := range tools </span><span class="cov8" title="1">{
                t, err := time.Parse(time.RFC3339, tool.Timestamp)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid timestamp %s: %w", tool.Timestamp, err)
                }</span>
                <span class="cov8" title="1">times = append(times, t)</span>
        }

        // Find time range
        <span class="cov8" title="1">minTime := times[0]
        maxTime := times[0]
        for _, t := range times </span><span class="cov8" title="1">{
                if t.Before(minTime) </span><span class="cov0" title="0">{
                        minTime = t
                }</span>
                <span class="cov8" title="1">if t.After(maxTime) </span><span class="cov8" title="1">{
                        maxTime = t
                }</span>
        }

        // Create time buckets
        <span class="cov8" title="1">buckets := createTimeBuckets(minTime, maxTime, config.Interval)

        // Group tools into buckets
        bucketData := make(map[time.Time][]parser.ToolCall)
        for i, tool := range tools </span><span class="cov8" title="1">{
                bucket := findBucket(times[i], buckets, config.Interval)
                bucketData[bucket] = append(bucketData[bucket], tool)
        }</span>

        // Calculate metrics for each bucket
        <span class="cov8" title="1">var points []TimeSeriesPoint
        for _, bucket := range buckets </span><span class="cov8" title="1">{
                data := bucketData[bucket]
                value := calculateTimeSeriesMetric(data, config.Metric)

                points = append(points, TimeSeriesPoint{
                        Timestamp: bucket,
                        Value:     value,
                })
        }</span>

        <span class="cov8" title="1">return points, nil</span>
}

// createTimeBuckets creates a list of time buckets from start to end
func createTimeBuckets(start, end time.Time, interval string) []time.Time <span class="cov8" title="1">{
        var buckets []time.Time

        current := truncateTime(start, interval)
        endTruncated := truncateTime(end, interval)

        for !current.After(endTruncated) </span><span class="cov8" title="1">{
                buckets = append(buckets, current)
                current = advanceTime(current, interval)
        }</span>

        <span class="cov8" title="1">return buckets</span>
}

// truncateTime truncates time to the start of the interval
func truncateTime(t time.Time, interval string) time.Time <span class="cov8" title="1">{
        switch interval </span>{
        case "hour":<span class="cov8" title="1">
                return time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), 0, 0, 0, t.Location())</span>
        case "day":<span class="cov8" title="1">
                return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())</span>
        case "week":<span class="cov8" title="1">
                // ISO week starts on Monday
                weekday := int(t.Weekday())
                if weekday == 0 </span><span class="cov8" title="1">{
                        weekday = 7 // Sunday
                }</span>
                <span class="cov8" title="1">daysToSubtract := weekday - 1
                return time.Date(t.Year(), t.Month(), t.Day()-daysToSubtract, 0, 0, 0, 0, t.Location())</span>
        default:<span class="cov0" title="0">
                return t</span>
        }
}

// advanceTime advances time by one interval
func advanceTime(t time.Time, interval string) time.Time <span class="cov8" title="1">{
        switch interval </span>{
        case "hour":<span class="cov8" title="1">
                return t.Add(time.Hour)</span>
        case "day":<span class="cov8" title="1">
                return t.AddDate(0, 0, 1)</span>
        case "week":<span class="cov8" title="1">
                return t.AddDate(0, 0, 7)</span>
        default:<span class="cov0" title="0">
                return t</span>
        }
}

// findBucket finds the appropriate bucket for a given time
func findBucket(t time.Time, buckets []time.Time, interval string) time.Time <span class="cov8" title="1">{
        truncated := truncateTime(t, interval)
        for _, bucket := range buckets </span><span class="cov8" title="1">{
                if bucket.Equal(truncated) </span><span class="cov8" title="1">{
                        return bucket
                }</span>
        }
        // If not found, return the closest bucket
        <span class="cov0" title="0">return buckets[len(buckets)-1]</span>
}

// calculateTimeSeriesMetric calculates the metric value for a bucket
func calculateTimeSeriesMetric(tools []parser.ToolCall, metric string) float64 <span class="cov8" title="1">{
        if len(tools) == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">switch metric </span>{
        case "tool-calls":<span class="cov8" title="1">
                return float64(len(tools))</span>

        case "error-rate":<span class="cov8" title="1">
                errorCount := 0
                for _, tool := range tools </span><span class="cov8" title="1">{
                        if tool.Status == "error" </span><span class="cov8" title="1">{
                                errorCount++
                        }</span>
                }
                <span class="cov8" title="1">return float64(errorCount) / float64(len(tools))</span>

        default:<span class="cov0" title="0">
                return 0.0</span>
        }
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package testutil

import (
        "os"
        "path/filepath"
        "testing"
)

// FixtureDir returns the fixtures directory path
func FixtureDir() string <span class="cov8" title="1">{
        // Try to find the fixtures directory by checking multiple potential locations
        candidates := []string{
                "../../tests/fixtures", // From internal/ packages
                "../tests/fixtures",    // From cmd/ package
                "tests/fixtures",       // From root
        }

        for _, candidate := range candidates </span><span class="cov8" title="1">{
                if _, err := os.Stat(candidate); err == nil </span><span class="cov8" title="1">{
                        return candidate
                }</span>
        }

        // Default to relative path from internal/
        <span class="cov0" title="0">return "../../tests/fixtures"</span>
}

// LoadFixture loads test fixture file content
func LoadFixture(t *testing.T, filename string) []byte <span class="cov8" title="1">{
        t.Helper()

        path := filepath.Join(FixtureDir(), filename)
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to load fixture %s: %v", filename, err)
        }</span>

        <span class="cov8" title="1">return data</span>
}

// TempSessionFile creates a temporary session file for testing
func TempSessionFile(t *testing.T, content string) string <span class="cov8" title="1">{
        t.Helper()

        tmpFile, err := os.CreateTemp("", "session-*.jsonl")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to create temp file: %v", err)
        }</span>

        <span class="cov8" title="1">if _, err := tmpFile.WriteString(content); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write temp file: %v", err)
        }</span>

        <span class="cov8" title="1">tmpFile.Close()
        t.Cleanup(func() </span><span class="cov8" title="1">{ os.Remove(tmpFile.Name()) }</span>)

        <span class="cov8" title="1">return tmpFile.Name()</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package testutil

import (
        "time"
)

// TimeFromUnix 从 Unix 时间戳创建 time.Time
func TimeFromUnix(sec int64) time.Time <span class="cov0" title="0">{
        return time.Unix(sec, 0)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package main

import (
        "github.com/yale/meta-cc/cmd"
        "os"
)

func main() <span class="cov0" title="0">{
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/yale/meta-cc/internal/parser"
)

// ChunkMetadata contains metadata for a single chunk
type ChunkMetadata struct {
        Index       int    `json:"index"`
        File        string `json:"file"`
        Records     int    `json:"records"`
        SizeBytes   int64  `json:"size_bytes"`
        TotalChunks int    `json:"total_chunks"`
}

// ChunkManifest contains metadata for all chunks
type ChunkManifest struct {
        TotalRecords int             `json:"total_records"`
        ChunkSize    int             `json:"chunk_size"`
        NumChunks    int             `json:"num_chunks"`
        Chunks       []ChunkMetadata `json:"chunks"`
}

// SplitIntoChunks splits a slice of ToolCalls into chunks of specified size
func SplitIntoChunks(tools []parser.ToolCall, chunkSize int) [][]parser.ToolCall <span class="cov8" title="1">{
        if chunkSize &lt;= 0 </span><span class="cov0" title="0">{
                return [][]parser.ToolCall{tools}
        }</span>

        <span class="cov8" title="1">var chunks [][]parser.ToolCall
        for i := 0; i &lt; len(tools); i += chunkSize </span><span class="cov8" title="1">{
                end := i + chunkSize
                if end &gt; len(tools) </span><span class="cov8" title="1">{
                        end = len(tools)
                }</span>
                <span class="cov8" title="1">chunks = append(chunks, tools[i:end])</span>
        }

        <span class="cov8" title="1">return chunks</span>
}

// WriteChunk writes a chunk to a file in the specified format
func WriteChunk(chunk []parser.ToolCall, format, outputPath string) error <span class="cov8" title="1">{
        var data []byte
        var err error

        switch format </span>{
        case "jsonl":<span class="cov8" title="1">
                data, err = json.Marshal(chunk) // Compact JSON (JSONL)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal JSONL: %w", err)
                }</span>

        case "tsv":<span class="cov8" title="1">
                content, err := FormatTSV(chunk)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to format TSV: %w", err)
                }</span>
                <span class="cov8" title="1">data = []byte(content)</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported format: %s (supported: jsonl, tsv)", format)</span>
        }

        // Ensure output directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        // Write file
        <span class="cov8" title="1">if err := os.WriteFile(outputPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write chunk file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GenerateManifest generates a manifest file with chunk metadata
func GenerateManifest(metadata []ChunkMetadata, manifestPath string) error <span class="cov8" title="1">{
        if len(metadata) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no chunk metadata provided")
        }</span>

        // Calculate totals
        <span class="cov8" title="1">totalRecords := 0
        for _, meta := range metadata </span><span class="cov8" title="1">{
                totalRecords += meta.Records
        }</span>

        // Infer chunk size from first chunk (or use Records if only one chunk)
        <span class="cov8" title="1">chunkSize := metadata[0].Records
        if len(metadata) &gt; 1 &amp;&amp; metadata[1].Records &gt; chunkSize </span><span class="cov0" title="0">{
                chunkSize = metadata[1].Records
        }</span>

        <span class="cov8" title="1">manifest := ChunkManifest{
                TotalRecords: totalRecords,
                ChunkSize:    chunkSize,
                NumChunks:    len(metadata),
                Chunks:       metadata,
        }

        data, err := json.MarshalIndent(manifest, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal manifest: %w", err)
        }</span>

        // Ensure output directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(manifestPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create manifest directory: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(manifestPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write manifest file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ChunkToolCalls splits ToolCalls into chunks and writes them to files
// Returns metadata for all chunks created
func ChunkToolCalls(tools []parser.ToolCall, chunkSize int, outputDir, format string) ([]ChunkMetadata, error) <span class="cov8" title="1">{
        if chunkSize &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chunk size must be &gt; 0")
        }</span>

        <span class="cov8" title="1">chunks := SplitIntoChunks(tools, chunkSize)
        totalChunks := len(chunks)
        metadata := make([]ChunkMetadata, 0, totalChunks)

        // Get file extension based on format
        ext := getExtension(format)

        for i, chunk := range chunks </span><span class="cov8" title="1">{
                // Generate filename with 4-digit padding: chunk_0001.json
                filename := fmt.Sprintf("chunk_%04d.%s", i+1, ext)
                outputPath := filepath.Join(outputDir, filename)

                // Write chunk file
                if err := WriteChunk(chunk, format, outputPath); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write chunk %d: %w", i, err)
                }</span>

                // Get file size
                <span class="cov8" title="1">fileInfo, err := os.Stat(outputPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to stat chunk file %d: %w", i, err)
                }</span>

                <span class="cov8" title="1">metadata = append(metadata, ChunkMetadata{
                        Index:       i,
                        File:        outputPath,
                        Records:     len(chunk),
                        SizeBytes:   fileInfo.Size(),
                        TotalChunks: totalChunks,
                })</span>
        }

        // Generate manifest file
        <span class="cov8" title="1">manifestPath := filepath.Join(outputDir, "manifest.jsonl")
        if err := GenerateManifest(metadata, manifestPath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate manifest: %w", err)
        }</span>

        <span class="cov8" title="1">return metadata, nil</span>
}

// getExtension returns the file extension for a given format
func getExtension(format string) string <span class="cov8" title="1">{
        switch format </span>{
        case "jsonl":<span class="cov8" title="1">
                return "jsonl"</span>
        case "tsv":<span class="cov8" title="1">
                return "tsv"</span>
        default:<span class="cov0" title="0">
                return "txt"</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package output

import (
        "encoding/json"

        "github.com/yale/meta-cc/internal/parser"
)

// SizeEstimate represents estimated output size
type SizeEstimate struct {
        EstimatedBytes int     `json:"estimated_bytes"`
        EstimatedKB    float64 `json:"estimated_kb"`
        Format         string  `json:"format"`
        RecordCount    int     `json:"record_count"`
}

// EstimateToolCallsSize estimates the output size for ToolCall slice
// Achieves ≥95% accuracy by sampling actual JSON serialization
func EstimateToolCallsSize(tools []parser.ToolCall, format string) (SizeEstimate, error) <span class="cov8" title="1">{
        var sizeBytes int

        switch format </span>{
        case "json":<span class="cov8" title="1">
                // For JSON, sample first record and multiply
                if len(tools) == 0 </span><span class="cov8" title="1">{
                        sizeBytes = 2 // "[]"
                }</span> else<span class="cov8" title="1"> {
                        // Serialize first record to get accurate size
                        sample, err := json.Marshal(tools[0])
                        if err != nil </span><span class="cov0" title="0">{
                                return SizeEstimate{}, err
                        }</span>
                        // Each record + comma + newline (~2 bytes overhead)
                        // Use actual size without buffer for better accuracy
                        <span class="cov8" title="1">recordSize := len(sample) + 2
                        sizeBytes = recordSize*len(tools) + 10</span> // +10 for array brackets
                }

        case "md", "markdown":<span class="cov8" title="1">
                // Markdown: table format with headers
                // Estimate: ~300 bytes per record (row with multiple columns)
                sizeBytes = len(tools)*300 + 500</span> // +500 for headers and separators

        case "csv":<span class="cov8" title="1">
                // CSV: comma-separated values
                // Estimate: ~200 bytes per record
                sizeBytes = len(tools)*200 + 100</span> // +100 for header row

        default:<span class="cov8" title="1">
                // Unknown format: conservative estimate
                sizeBytes = len(tools) * 300</span>
        }

        <span class="cov8" title="1">return SizeEstimate{
                EstimatedBytes: sizeBytes,
                EstimatedKB:    float64(sizeBytes) / 1024.0,
                Format:         format,
                RecordCount:    len(tools),
        }, nil</span>
}

// EstimateStatsSize estimates the output size for stats report
// Stats are fixed size regardless of session size
func EstimateStatsSize(format string) SizeEstimate <span class="cov8" title="1">{
        sizeMap := map[string]int{
                "json": 800,
                "md":   1200,
                "csv":  600,
        }

        size := sizeMap[format]
        if size == 0 </span><span class="cov0" title="0">{
                size = 1000
        }</span>

        <span class="cov8" title="1">return SizeEstimate{
                EstimatedBytes: size,
                EstimatedKB:    float64(size) / 1024.0,
                Format:         format,
                RecordCount:    1, // Stats report is a single record
        }</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "strings"
)

// FormatErrorJSON formats error objects as JSON for stderr output
func FormatErrorJSON(err error, code string) (string, error) <span class="cov8" title="1">{
        errObj := map[string]interface{}{
                "error": err.Error(),
                "code":  code,
        }
        output, marshalErr := json.Marshal(errObj)
        if marshalErr != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal error JSON: %w", marshalErr)
        }</span>
        <span class="cov8" title="1">return string(output), nil</span>
}

// FormatJSONL formats data as JSON Lines (one JSON object per line)
func FormatJSONL(data interface{}) (string, error) <span class="cov8" title="1">{
        // Reflect to check if data is a slice/array
        // If it's a slice, marshal each item on a separate line
        // If it's a single object, just marshal it

        // Use type switch to handle slices
        switch v := data.(type) </span>{
        case []interface{}:<span class="cov0" title="0">
                return formatSliceJSONL(v)</span>
        default:<span class="cov8" title="1">
                // Try to handle as a slice via reflection
                // This handles typed slices like []ToolCall, []ErrorEntry, etc.
                return formatGenericJSONL(data)</span>
        }
}

// formatSliceJSONL formats []interface{} as JSONL
func formatSliceJSONL(items []interface{}) (string, error) <span class="cov0" title="0">{
        if len(items) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">var lines []string
        for _, item := range items </span><span class="cov0" title="0">{
                jsonBytes, err := json.Marshal(item)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to marshal JSONL item: %w", err)
                }</span>
                <span class="cov0" title="0">lines = append(lines, string(jsonBytes))</span>
        }

        <span class="cov0" title="0">return strings.Join(lines, "\n") + "\n", nil</span>
}

// formatGenericJSONL uses reflection to handle any slice type
func formatGenericJSONL(data interface{}) (string, error) <span class="cov8" title="1">{
        // First try to marshal as-is (handles non-slice types and empty slices)
        // Check if it's a slice using type assertion patterns

        // Convert to []interface{} if it's a slice
        // Use json.Marshal + unmarshal trick to convert typed slice to []interface{}
        tempJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal data: %w", err)
        }</span>

        // Check if it's a JSON array (starts with '[')
        <span class="cov8" title="1">if len(tempJSON) &gt; 0 &amp;&amp; tempJSON[0] == '[' </span><span class="cov8" title="1">{
                // It's an array, unmarshal to []interface{} and format as JSONL
                var items []interface{}
                if err := json.Unmarshal(tempJSON, &amp;items); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to unmarshal array: %w", err)
                }</span>

                <span class="cov8" title="1">if len(items) == 0 </span><span class="cov8" title="1">{
                        return "", nil
                }</span>

                <span class="cov8" title="1">var lines []string
                for _, item := range items </span><span class="cov8" title="1">{
                        jsonBytes, err := json.Marshal(item)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to marshal JSONL item: %w", err)
                        }</span>
                        <span class="cov8" title="1">lines = append(lines, string(jsonBytes))</span>
                }

                <span class="cov8" title="1">return strings.Join(lines, "\n") + "\n", nil</span>
        }

        // It's a single object, just return it
        <span class="cov8" title="1">return string(tempJSON), nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "sort"
        "strings"

        "github.com/yale/meta-cc/internal/parser"
)

// ProjectionConfig defines which fields to include in output
type ProjectionConfig struct {
        Fields         []string // Base fields to include
        IfErrorInclude []string // Additional fields to include for error records
}

// ProjectedToolCall represents a ToolCall with only selected fields
type ProjectedToolCall map[string]interface{}

// ProjectToolCalls applies field projection to ToolCall slice
// Returns a slice of maps containing only the specified fields
func ProjectToolCalls(tools []parser.ToolCall, config ProjectionConfig) ([]ProjectedToolCall, error) <span class="cov8" title="1">{
        if len(config.Fields) == 0 </span><span class="cov8" title="1">{
                // No projection - return full objects as maps
                return convertToMaps(tools), nil
        }</span>

        <span class="cov8" title="1">projected := make([]ProjectedToolCall, 0, len(tools))

        for _, tool := range tools </span><span class="cov8" title="1">{
                // Convert ToolCall to map for field access
                toolMap := toolCallToMap(tool)

                // Build projected object with base fields
                projectedTool := make(ProjectedToolCall)

                // Include specified base fields
                for _, field := range config.Fields </span><span class="cov8" title="1">{
                        if value, ok := toolMap[field]; ok </span><span class="cov8" title="1">{
                                projectedTool[field] = value
                        }</span>
                }

                // If this is an error record, include additional error fields
                <span class="cov8" title="1">if tool.Status == "error" &amp;&amp; len(config.IfErrorInclude) &gt; 0 </span><span class="cov8" title="1">{
                        for _, field := range config.IfErrorInclude </span><span class="cov8" title="1">{
                                if value, ok := toolMap[field]; ok </span><span class="cov8" title="1">{
                                        projectedTool[field] = value
                                }</span>
                        }
                }

                <span class="cov8" title="1">projected = append(projected, projectedTool)</span>
        }

        <span class="cov8" title="1">return projected, nil</span>
}

// ParseProjectionConfig parses field specification strings
// Format: "field1,field2,field3" (comma-separated)
func ParseProjectionConfig(fieldsStr, ifErrorIncludeStr string) ProjectionConfig <span class="cov8" title="1">{
        config := ProjectionConfig{}

        if fieldsStr != "" </span><span class="cov8" title="1">{
                fields := strings.Split(fieldsStr, ",")
                config.Fields = make([]string, 0, len(fields))
                for _, f := range fields </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(f)
                        if trimmed != "" </span><span class="cov8" title="1">{
                                config.Fields = append(config.Fields, trimmed)
                        }</span>
                }
        }

        <span class="cov8" title="1">if ifErrorIncludeStr != "" </span><span class="cov8" title="1">{
                errorFields := strings.Split(ifErrorIncludeStr, ",")
                config.IfErrorInclude = make([]string, 0, len(errorFields))
                for _, f := range errorFields </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(f)
                        if trimmed != "" </span><span class="cov8" title="1">{
                                config.IfErrorInclude = append(config.IfErrorInclude, trimmed)
                        }</span>
                }
        }

        <span class="cov8" title="1">return config</span>
}

// toolCallToMap converts a ToolCall struct to a map for field access
// Uses JSON marshaling/unmarshaling to handle struct-to-map conversion
func toolCallToMap(tool parser.ToolCall) map[string]interface{} <span class="cov8" title="1">{
        // Use JSON round-trip for accurate conversion
        data, _ := json.Marshal(tool)
        var m map[string]interface{}
        json.Unmarshal(data, &amp;m)
        return m
}</span>

// convertToMaps converts ToolCall slice to ProjectedToolCall slice (no projection)
func convertToMaps(tools []parser.ToolCall) []ProjectedToolCall <span class="cov8" title="1">{
        result := make([]ProjectedToolCall, len(tools))
        for i, tool := range tools </span><span class="cov8" title="1">{
                result[i] = toolCallToMap(tool)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// FormatProjectedOutput formats projected output in the specified format
func FormatProjectedOutput(projected []ProjectedToolCall, format string) (string, error) <span class="cov8" title="1">{
        switch format </span>{
        case "json":<span class="cov8" title="1">
                data, err := json.MarshalIndent(projected, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return string(data), nil</span>

        case "md", "markdown":<span class="cov8" title="1">
                return formatProjectedMarkdown(projected), nil</span>

        case "csv":<span class="cov8" title="1">
                return formatProjectedCSV(projected), nil</span>

        case "tsv":<span class="cov0" title="0">
                return FormatProjectedTSV(projected), nil</span>

        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported format for projection: %s", format)</span>
        }
}

// formatProjectedMarkdown formats projected data as Markdown table
func formatProjectedMarkdown(projected []ProjectedToolCall) string <span class="cov8" title="1">{
        if len(projected) == 0 </span><span class="cov8" title="1">{
                return "No data"
        }</span>

        // Extract field names from first record (sorted for consistency)
        <span class="cov8" title="1">var fields []string
        for field := range projected[0] </span><span class="cov8" title="1">{
                fields = append(fields, field)
        }</span>
        <span class="cov8" title="1">sort.Strings(fields)

        var sb strings.Builder

        // Header row
        sb.WriteString("| ")
        for _, field := range fields </span><span class="cov8" title="1">{
                sb.WriteString(field)
                sb.WriteString(" | ")
        }</span>
        <span class="cov8" title="1">sb.WriteString("\n")

        // Separator row
        sb.WriteString("| ")
        for range fields </span><span class="cov8" title="1">{
                sb.WriteString("--- | ")
        }</span>
        <span class="cov8" title="1">sb.WriteString("\n")

        // Data rows
        for _, record := range projected </span><span class="cov8" title="1">{
                sb.WriteString("| ")
                for _, field := range fields </span><span class="cov8" title="1">{
                        value := fmt.Sprintf("%v", record[field])
                        // Escape pipe characters to prevent breaking table
                        value = strings.ReplaceAll(value, "|", "\\|")
                        sb.WriteString(value)
                        sb.WriteString(" | ")
                }</span>
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// formatProjectedCSV formats projected data as CSV
func formatProjectedCSV(projected []ProjectedToolCall) string <span class="cov8" title="1">{
        if len(projected) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Extract field names from first record (sorted for consistency)
        <span class="cov8" title="1">var fields []string
        for field := range projected[0] </span><span class="cov8" title="1">{
                fields = append(fields, field)
        }</span>
        <span class="cov8" title="1">sort.Strings(fields)

        var sb strings.Builder

        // Header row
        for i, field := range fields </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString(",")
                }</span>
                <span class="cov8" title="1">sb.WriteString(escapeCSV(field))</span>
        }
        <span class="cov8" title="1">sb.WriteString("\n")

        // Data rows
        for _, record := range projected </span><span class="cov8" title="1">{
                for i, field := range fields </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString(",")
                        }</span>
                        <span class="cov8" title="1">value := fmt.Sprintf("%v", record[field])
                        sb.WriteString(escapeCSV(value))</span>
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// escapeCSV escapes a CSV field value
func escapeCSV(s string) string <span class="cov8" title="1">{
        // If the string contains comma, quotes, or newlines, wrap in quotes and escape quotes
        if strings.ContainsAny(s, ",\"\n") </span><span class="cov8" title="1">{
                s = strings.ReplaceAll(s, "\"", "\"\"")
                return "\"" + s + "\""
        }</span>
        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package output

import (
        "sort"

        "github.com/yale/meta-cc/internal/parser"
)

// ErrorEntry represents a tool error with timestamp
// Note: This type must match the ErrorEntry in cmd/query_errors.go
// In future phases, this will be moved to a common package
type ErrorEntry struct {
        UUID      string `json:"uuid"`
        Timestamp string `json:"timestamp"`
        ToolName  string `json:"tool_name"`
        Error     string `json:"error"`
        Signature string `json:"signature"`
}

// SortByTimestamp sorts data by timestamp field (ascending order).
// Uses stable sort to preserve relative order for equal timestamps.
// Supports: []parser.ToolCall, []ErrorEntry, and command-specific types.
func SortByTimestamp(data interface{}) <span class="cov8" title="1">{
        switch v := data.(type) </span>{
        case []parser.ToolCall:<span class="cov8" title="1">
                sort.SliceStable(v, func(i, j int) bool </span><span class="cov8" title="1">{
                        return v[i].Timestamp &lt; v[j].Timestamp
                }</span>)
        case []ErrorEntry:<span class="cov8" title="1">
                sort.SliceStable(v, func(i, j int) bool </span><span class="cov8" title="1">{
                        return v[i].Timestamp &lt; v[j].Timestamp
                }</span>)
                // Additional types can be added as needed
        }
}

// SortByTurnSequence sorts data by turn sequence number (ascending order).
// Uses stable sort to preserve relative order for equal sequence numbers.
// Primarily used for user messages and other turn-based data.
//
// Note: This uses a type switch to support different message types.
// When command types are refactored (future phases), this will use standardized types.
func SortByTurnSequence(data interface{}) <span class="cov0" title="0">{
        // Type assertion interface for any type with TurnSequence field
        type TurnSequenced interface {
                GetTurnSequence() int
        }

        // For now, we don't have a common interface. Commands handle their own sorting.
        // This function serves as a documentation anchor for turn sequence sorting.
        // Future refactoring will standardize this when message types are unified.
}</span>

// SortByUUID sorts data by UUID lexicographically (ascending order).
// Uses stable sort to preserve relative order for equal UUIDs.
// Useful for debug/fallback sorting when timestamp is unavailable.
func SortByUUID(data interface{}) <span class="cov8" title="1">{
        switch v := data.(type) </span>{
        case []parser.ToolCall:<span class="cov8" title="1">
                sort.SliceStable(v, func(i, j int) bool </span><span class="cov8" title="1">{
                        return v[i].UUID &lt; v[j].UUID
                }</span>)
        }
}

// DefaultSort applies the default sorting for a data type.
// Default behavior: sort by timestamp for most types.
func DefaultSort(data interface{}) <span class="cov8" title="1">{
        SortByTimestamp(data)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package output

import (
        "encoding/json"
        "io"
)

// StreamWriter writes data as JSON Lines (JSONL) format.
// Each record is written as a single line of compact JSON.
type StreamWriter struct {
        writer io.Writer
}

// NewStreamWriter creates a new JSONL stream writer.
func NewStreamWriter(w io.Writer) *StreamWriter <span class="cov8" title="1">{
        return &amp;StreamWriter{writer: w}
}</span>

// WriteRecord writes a single record as a JSON line.
// The record is marshaled to compact JSON and written with a trailing newline.
func (sw *StreamWriter) WriteRecord(record interface{}) error <span class="cov8" title="1">{
        // Marshal to compact JSON
        data, err := json.Marshal(record)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write JSON line
        <span class="cov8" title="1">_, err = sw.writer.Write(data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Write newline
        <span class="cov8" title="1">_, err = sw.writer.Write([]byte("\n"))
        return err</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "sort"
        "strings"

        "github.com/yale/meta-cc/internal/parser"
)

// SummaryOutput contains summary and detailed records
type SummaryOutput struct {
        Summary string // Summary statistics
        Details string // Detailed records (in specified format)
}

// GenerateSummary generates a compact summary of tool calls
func GenerateSummary(tools []parser.ToolCall) string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString("=== Session Summary ===\n")
        sb.WriteString(fmt.Sprintf("Total Tools: %d\n", len(tools)))

        // Count errors
        errorCount := 0
        for _, tool := range tools </span><span class="cov8" title="1">{
                if tool.Status == "error" || tool.Error != "" </span><span class="cov8" title="1">{
                        errorCount++
                }</span>
        }

        <span class="cov8" title="1">errorRate := 0.0
        if len(tools) &gt; 0 </span><span class="cov8" title="1">{
                errorRate = float64(errorCount) / float64(len(tools)) * 100
        }</span>

        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("Errors: %d (%.1f%%)\n", errorCount, errorRate))

        // Calculate tool frequency
        toolFreq := make(map[string]int)
        for _, tool := range tools </span><span class="cov8" title="1">{
                toolFreq[tool.ToolName]++
        }</span>

        // Sort by frequency
        <span class="cov8" title="1">type toolCount struct {
                name  string
                count int
        }
        var counts []toolCount
        for name, count := range toolFreq </span><span class="cov8" title="1">{
                counts = append(counts, toolCount{name, count})
        }</span>
        <span class="cov8" title="1">sort.Slice(counts, func(i, j int) bool </span><span class="cov8" title="1">{
                if counts[i].count == counts[j].count </span><span class="cov8" title="1">{
                        return counts[i].name &lt; counts[j].name
                }</span>
                <span class="cov8" title="1">return counts[i].count &gt; counts[j].count</span>
        })

        // Show top 5 tools
        <span class="cov8" title="1">sb.WriteString("\nTop Tools:\n")
        for i, tc := range counts </span><span class="cov8" title="1">{
                if i &gt;= 5 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("  %d. %s (%d)\n", i+1, tc.name, tc.count))</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// FormatSummaryFirst outputs summary first, then top N detailed records
func FormatSummaryFirst(tools []parser.ToolCall, topN int, detailFormat string) (SummaryOutput, error) <span class="cov8" title="1">{
        // Generate summary
        summary := GenerateSummary(tools)

        // Select top N records (or all if topN &lt;= 0 or topN &gt;= len(tools))
        detailTools := tools
        if topN &gt; 0 &amp;&amp; topN &lt; len(tools) </span><span class="cov8" title="1">{
                detailTools = tools[:topN]
        }</span>

        // Format details
        <span class="cov8" title="1">var details string
        var err error

        switch detailFormat </span>{
        case "jsonl":<span class="cov8" title="1">
                var data []byte
                data, err = json.Marshal(detailTools) // Compact JSON (JSONL)
                if err != nil </span><span class="cov0" title="0">{
                        return SummaryOutput{}, err
                }</span>
                <span class="cov8" title="1">details = string(data)</span>

        case "tsv":<span class="cov8" title="1">
                var err error
                details, err = FormatTSV(detailTools)
                if err != nil </span><span class="cov0" title="0">{
                        return SummaryOutput{}, fmt.Errorf("failed to format TSV: %w", err)
                }</span>

        default:<span class="cov8" title="1">
                return SummaryOutput{}, fmt.Errorf("unsupported format: %s (supported: jsonl, tsv)", detailFormat)</span>
        }

        <span class="cov8" title="1">return SummaryOutput{
                Summary: summary,
                Details: details,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package output

import (
        "encoding/json"
        "fmt"
        "reflect"
        "sort"
        "strings"

        "github.com/yale/meta-cc/internal/parser"
)

// FormatTSV formats data as TSV (Tab-Separated Values)
// Supports any data type via reflection (generic formatting)
// TSV is ~50% smaller than JSON due to:
// - No quotes around values
// - No field names per record
// - No JSON structure overhead
//
// Supported types:
// - []parser.ToolCall (optimized)
// - Any struct (vertical format: key\tvalue)
// - Any []struct (table format with headers)
func FormatTSV(data interface{}) (string, error) <span class="cov8" title="1">{
        // Type switch for optimized formatting
        switch v := data.(type) </span>{
        case []parser.ToolCall:<span class="cov8" title="1">
                // Optimized path for ToolCall (most common case)
                return formatToolCallsTSV(v), nil</span>
        default:<span class="cov0" title="0">
                // Generic path using reflection
                return FormatGenericTSV(data)</span>
        }
}

// formatToolCallsTSV formats ToolCall slice as TSV (optimized)
func formatToolCallsTSV(tools []parser.ToolCall) string <span class="cov8" title="1">{
        if len(tools) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var sb strings.Builder

        // Header row
        sb.WriteString("UUID\tToolName\tStatus\tError\n")

        // Data rows
        for _, tool := range tools </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("%s\t%s\t%s\t%s\n",
                        tool.UUID,
                        tool.ToolName,
                        tool.Status,
                        escapeTSV(tool.Error),
                ))
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// FormatProjectedTSV formats projected data as TSV
func FormatProjectedTSV(projected []ProjectedToolCall) string <span class="cov8" title="1">{
        if len(projected) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Extract field names from first record (sorted for consistency)
        <span class="cov8" title="1">var fields []string
        for field := range projected[0] </span><span class="cov8" title="1">{
                fields = append(fields, field)
        }</span>
        <span class="cov8" title="1">sort.Strings(fields)

        var sb strings.Builder

        // Header row
        for i, field := range fields </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString("\t")
                }</span>
                <span class="cov8" title="1">sb.WriteString(field)</span>
        }
        <span class="cov8" title="1">sb.WriteString("\n")

        // Data rows
        for _, record := range projected </span><span class="cov8" title="1">{
                for i, field := range fields </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString("\t")
                        }</span>
                        <span class="cov8" title="1">value := fmt.Sprintf("%v", record[field])
                        sb.WriteString(escapeTSV(value))</span>
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

// escapeTSV escapes tab and newline characters to prevent breaking TSV format
func escapeTSV(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "\t", "\\t")
        s = strings.ReplaceAll(s, "\n", "\\n")
        return s
}</span>

// FormatGenericTSV formats any data type as TSV using reflection
// Supports: single structs (vertical format), slice of structs (table format)
func FormatGenericTSV(data interface{}) (string, error) <span class="cov8" title="1">{
        v := reflect.ValueOf(data)

        // Handle nil
        if !v.IsValid() </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // Handle pointer
        <span class="cov8" title="1">if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">v = v.Elem()</span>
        }

        // Handle slice
        <span class="cov8" title="1">if v.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                if v.Len() == 0 </span><span class="cov8" title="1">{
                        return "", nil
                }</span>

                // Get headers from first element
                <span class="cov8" title="1">elem := v.Index(0)
                headers := getStructFields(elem)

                var sb strings.Builder
                sb.WriteString(strings.Join(headers, "\t"))
                sb.WriteString("\n")

                // Get rows
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        row := getStructValues(v.Index(i))
                        sb.WriteString(strings.Join(row, "\t"))
                        sb.WriteString("\n")
                }</span>

                <span class="cov8" title="1">return sb.String(), nil</span>
        }

        // Handle single struct (vertical format: key\tvalue)
        <span class="cov8" title="1">if v.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                headers := getStructFields(v)
                values := getStructValues(v)

                var sb strings.Builder
                for i, header := range headers </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("%s\t%s\n", header, values[i]))
                }</span>

                <span class="cov8" title="1">return sb.String(), nil</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("unsupported data type for TSV formatting: %T", data)</span>
}

// getStructFields extracts field names from a struct using reflection
func getStructFields(v reflect.Value) []string <span class="cov8" title="1">{
        var fields []string

        // Handle pointer
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return fields
                }</span>
                <span class="cov0" title="0">v = v.Elem()</span>
        }

        <span class="cov8" title="1">if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return fields
        }</span>

        <span class="cov8" title="1">t := v.Type()
        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                field := t.Field(i)

                // Skip unexported fields
                if field.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Use JSON tag if available, otherwise use field name
                <span class="cov8" title="1">fieldName := field.Name
                if jsonTag := field.Tag.Get("json"); jsonTag != "" </span><span class="cov0" title="0">{
                        // Parse JSON tag (format: "field_name,omitempty")
                        parts := strings.Split(jsonTag, ",")
                        if parts[0] != "" &amp;&amp; parts[0] != "-" </span><span class="cov0" title="0">{
                                fieldName = parts[0]
                        }</span>
                }

                <span class="cov8" title="1">fields = append(fields, fieldName)</span>
        }

        <span class="cov8" title="1">return fields</span>
}

// getStructValues extracts field values from a struct using reflection
func getStructValues(v reflect.Value) []string <span class="cov8" title="1">{
        var values []string

        // Handle pointer
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return values
                }</span>
                <span class="cov0" title="0">v = v.Elem()</span>
        }

        <span class="cov8" title="1">if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return values
        }</span>

        <span class="cov8" title="1">t := v.Type()
        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                field := t.Field(i)

                // Skip unexported fields
                if field.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">value := v.Field(i)
                values = append(values, formatTSVValue(value))</span>
        }

        <span class="cov8" title="1">return values</span>
}

// formatTSVValue formats a reflect.Value as string for TSV
func formatTSVValue(v reflect.Value) string <span class="cov8" title="1">{
        // Handle pointer
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">v = v.Elem()</span>
        }

        <span class="cov8" title="1">switch v.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                // Escape tabs and newlines
                s := v.String()
                return escapeTSV(s)</span>

        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", v.Int())</span>

        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v.Uint())</span>

        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return fmt.Sprintf("%.2f", v.Float())</span>

        case reflect.Bool:<span class="cov0" title="0">
                return fmt.Sprintf("%t", v.Bool())</span>

        case reflect.Map, reflect.Slice, reflect.Struct:<span class="cov8" title="1">
                // Serialize complex types as JSON (compact)
                data, err := json.Marshal(v.Interface())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%v", v.Interface())
                }</span>
                <span class="cov8" title="1">s := string(data)
                return escapeTSV(s)</span>

        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", v.Interface())</span>
        }
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package pipeline

import (
        "fmt"

        "github.com/yale/meta-cc/internal/locator"
        "github.com/yale/meta-cc/internal/parser"
)

// SessionPipeline encapsulates session data processing
// Provides a unified interface for locating, loading, and extracting session data
type SessionPipeline struct {
        opts      GlobalOptions         // Global configuration options
        session   string                // Path to loaded session file
        entries   []parser.SessionEntry // Parsed session entries
        turnIndex map[string]int        // UUID → turn sequence mapping (cached)
}

// NewSessionPipeline creates a new pipeline instance
func NewSessionPipeline(opts GlobalOptions) *SessionPipeline <span class="cov8" title="1">{
        return &amp;SessionPipeline{
                opts:      opts,
                turnIndex: make(map[string]int),
        }
}</span>

// Load locates and loads the session JSONL file
// Supports three location methods (in priority order):
//  1. Explicit --session UUID
//  2. Explicit --project path
//  3. Auto-detect from current directory (when AutoDetect is true)
func (p *SessionPipeline) Load(loadOpts LoadOptions) error <span class="cov8" title="1">{
        // Step 1: Locate session file
        loc := locator.NewSessionLocator()

        sessionPath, err := loc.Locate(locator.LocateOptions{
                SessionID:   p.opts.SessionID,
                ProjectPath: p.opts.ProjectPath,
                SessionOnly: p.opts.SessionOnly,
        })

        if err != nil </span><span class="cov8" title="1">{
                // If auto-detect is enabled and location failed, try auto-detect
                if loadOpts.AutoDetect &amp;&amp; p.opts.SessionID == "" &amp;&amp; p.opts.ProjectPath == "" </span><span class="cov0" title="0">{
                        // Auto-detect is already the default behavior in locator.Locate
                        // when no explicit options are provided
                        return fmt.Errorf("session location failed: %w", err)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("session location failed: %w", err)</span>
        }

        <span class="cov8" title="1">p.session = sessionPath

        // Step 2: Parse JSONL
        sessionParser := parser.NewSessionParser(sessionPath)
        p.entries, err = sessionParser.ParseEntries()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("JSONL parsing failed: %w", err)
        }</span>

        // Step 3: Validate if requested
        <span class="cov8" title="1">if loadOpts.Validate </span><span class="cov8" title="1">{
                if len(p.entries) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("session file is empty or contains no valid entries")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ExtractToolCalls extracts all tool calls from loaded entries
// Returns an empty slice if no entries are loaded
func (p *SessionPipeline) ExtractToolCalls() ([]parser.ToolCall, error) <span class="cov8" title="1">{
        if len(p.entries) == 0 </span><span class="cov8" title="1">{
                return []parser.ToolCall{}, nil
        }</span>

        <span class="cov8" title="1">toolCalls := parser.ExtractToolCalls(p.entries)
        return toolCalls, nil</span>
}

// BuildTurnIndex creates UUID → turn_sequence mapping
// Results are cached for subsequent calls (idempotent)
func (p *SessionPipeline) BuildTurnIndex() map[string]int <span class="cov8" title="1">{
        // Return cached index if already built
        if len(p.turnIndex) &gt; 0 </span><span class="cov8" title="1">{
                return p.turnIndex
        }</span>

        // Build index from entries
        <span class="cov8" title="1">for i, entry := range p.entries </span><span class="cov8" title="1">{
                p.turnIndex[entry.UUID] = i
        }</span>

        <span class="cov8" title="1">return p.turnIndex</span>
}

// SessionPath returns the loaded session file path
// Returns empty string if no session has been loaded
func (p *SessionPipeline) SessionPath() string <span class="cov8" title="1">{
        return p.session
}</span>

// EntryCount returns the number of entries loaded
// Returns 0 if no session has been loaded
func (p *SessionPipeline) EntryCount() int <span class="cov8" title="1">{
        return len(p.entries)
}</span>

// Entries returns the raw session entries
// Useful for advanced processing that needs direct access to entries
func (p *SessionPipeline) Entries() []parser.SessionEntry <span class="cov8" title="1">{
        return p.entries
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
